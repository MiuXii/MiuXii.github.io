<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跨域问题</title>
      <link href="/2025/05/12/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/12/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><blockquote><p>跨域（Cross-Origin）指的是<font color="#FF7D00"><b>浏览器限制客户端直接访问不同源的服务器。</b></font>具体来说，一个页面的协议、域名、端口三者任意一个与请求的目标地址不同，就被视为跨域请求。<br><font color="#FF7D00"><b>前后端开发时，前后端服务器端口不同，所以需要解决跨域问题。</b></font><br><img src="https://sns-webpic-qc.xhscdn.com/202505121118/bd920cc48f841ec9c631f6f83b822af1/spectrum/1040g34o31h73v3tf340g5okaqa98d89t6leahr8!nd_dft_wlteh_webp_3" alt="跨域"><br><img src="https://sns-webpic-qc.xhscdn.com/202505121118/8701a9e588b357d7c9c9fb07c3ddaea0/spectrum/1040g34o31h73v3tf34105okaqa98d89tkl97648!nd_dft_wlteh_webp_3" alt="跨域"></p></blockquote><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="nigix反向代理"><a href="#nigix反向代理" class="headerlink" title="nigix反向代理"></a>nigix反向代理</h2><blockquote><p>允许一个中间服务器来接收客服端的请求，然后将这些请求转发到一个或多个后端服务器，允许前端应用通过同一个源访问多个服务</p></blockquote><p><img src="https://sns-webpic-qc.xhscdn.com/202505121640/51a84cd6d0f5293b74f4d5f07f228cec/1040g00831999ulhjl81g5okfiigod88a83ic4gg!nd_dft_wlteh_webp_3" alt="agent"></p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><blockquote><p>(将客户端代理到指定IP)</p></blockquote><ul><li>代理客户端，局域网中的客户端要访问Internet则需要通过代理服务器访问（VPN）。这里需要设置，必须知道要访问的外部服务器</li><li>VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。</li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><blockquote><p>（将不同域的需求代理到指定服务端）</p></blockquote><ul><li>隐藏服务器</li><li>前端只需要将请求发送到反向代理服务器，<font color="#FF7D00"><b>由反向代理服务器去选择目标服务器获取数据后，再返回给客户端</b></font>，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</li></ul><h2 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h2><blockquote><p>Cross-Origin Resource Sharing(CROS)</p></blockquote><h3 id="CrossOrigin控制器跨域"><a href="#CrossOrigin控制器跨域" class="headerlink" title="@CrossOrigin控制器跨域"></a>@CrossOrigin控制器跨域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, Object&gt; <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&quot;state&quot;</span>, <span class="number">200</span>);</span><br><span class="line">            put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">            put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局跨域——重写WebMvcConfigurer"><a href="#全局跨域——重写WebMvcConfigurer" class="headerlink" title="全局跨域——重写WebMvcConfigurer"></a>全局跨域——重写WebMvcConfigurer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 允许跨域访问的路径</span></span><br><span class="line">                        .allowedOrigins(<span class="string">&quot;http://example.com&quot;</span>) <span class="comment">// 允许跨域访问的域名</span></span><br><span class="line">                        .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>) <span class="comment">// 允许的HTTP方法</span></span><br><span class="line">                        .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 允许的请求头</span></span><br><span class="line">                        .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否允许发送cookie</span></span><br><span class="line">                        .maxAge(<span class="number">3600</span>); <span class="comment">// 预检请求的缓存时间（单位：秒）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局跨域——返回新的-CorsFilte"><a href="#全局跨域——返回新的-CorsFilte" class="headerlink" title="全局跨域——返回新的 CorsFilte"></a>全局跨域——返回新的 CorsFilte</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;        <span class="comment">//1. 添加 CORS配置信息</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();        <span class="comment">//放行哪些原始域</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);        <span class="comment">//是否发送 Cookie</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);        <span class="comment">//放行哪些请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);        <span class="comment">//放行哪些原始请求头部信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);        <span class="comment">//暴露哪些头部信息</span></span><br><span class="line">        config.addExposedHeader(<span class="string">&quot;*&quot;</span>);        <span class="comment">//2. 添加映射路径</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">corsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,config);        <span class="comment">//3. 返回新的CorsFilter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(corsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium总结</title>
      <link href="/2025/01/06/Selenium%E5%85%AB%E5%A4%A7%E5%AE%9A%E4%BD%8D/"/>
      <url>/2025/01/06/Selenium%E5%85%AB%E5%A4%A7%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用于UI(Web方向)自动化测试的开源工具，能够完成界面元素定位、窗口跳转、结果比较。</p><blockquote><p>适合做自动化的web项目：</p><ul><li>功能、业务逻辑较长时间不会频繁变动</li><li>回归测试频繁，需要自动验证稳定性</li><li>界面变化相对固定</li></ul></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>selenium+WebDriver</p></blockquote><p>WebDriver的原理：</p><ul><li>（1）启动web浏览器，后台会同时启动基于Webdriver Wire协议的Web服务器作为selenium的远程服务器，并将其与浏览器绑定。绑定完成之后，服务器就开始监听客户端的操作请求。</li><li>（2）执行测试时，selenium客户端将需要执行的页面操作请求以HTTP请求的方式发送给远程服务器。该HTTP请求的正文以Webdriver Wire协议规定的JSON格式来描述需要浏览器执行的具体操作。</li><li>（3）远程服务器接收到请求后，会对请求进行解析，并将解析结果发送给Webdriver，由Webdriver实际执行浏览器的操作。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><blockquote><p>selenium3版本及以上+Java</p></blockquote><ul><li>1.查看浏览器版本，安装对应的selenium浏览器驱动器</li><li>2.maven工程在pom文件中引入对应的依赖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;版本号&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li>3.导入包，创建驱动对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import org.openqa.selenium.By;</span><br><span class="line">import org.openqa.selenium.WebDriver;</span><br><span class="line">import org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"></span><br><span class="line">public class BaiduSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 1.创建webdriver驱动</span><br><span class="line">        WebDriver driver = new ChromeDriver();</span><br><span class="line">        // 2.打开百度首页</span><br><span class="line">        driver.get(&quot;https://www.baidu.com&quot;);</span><br><span class="line">        // 3.获取输入框，输入selenium</span><br><span class="line">        driver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;selenium&quot;);</span><br><span class="line">        // 4.获取“百度一下”按钮，进行搜索</span><br><span class="line">        driver.findElement(By.id(&quot;su&quot;)).click();</span><br><span class="line">        // 5.退出浏览器</span><br><span class="line">        driver.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="元素八大定位方式"><a href="#元素八大定位方式" class="headerlink" title="元素八大定位方式"></a>元素八大定位方式</h1><p><img src="https://i-blog.csdnimg.cn/direct/0a098a49a9fc415cafa9098fe5e65b49.png" alt="在这里插入图片描述"></p><h2 id="id定位"><a href="#id定位" class="headerlink" title="id定位"></a>id定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/e9801084c32f4a1b89a3ce4963bc26a6.png" alt="在这里插入图片描述"></p><h2 id="name定位"><a href="#name定位" class="headerlink" title="name定位"></a>name定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/5b3785dac12c4736a8b7fd7cb07e5777.png" alt="在这里插入图片描述"></p><h2 id="linkText定位"><a href="#linkText定位" class="headerlink" title="linkText定位"></a>linkText定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/833000f5df28449aae6e25e2d06b4217.png" alt="在这里插入图片描述"></p><h2 id="partialLinkText定位"><a href="#partialLinkText定位" class="headerlink" title="partialLinkText定位"></a>partialLinkText定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/9dc8d44540404a9dabf1621ef5844c9c.png" alt="在这里插入图片描述"></p><h2 id="class定位"><a href="#class定位" class="headerlink" title="class定位"></a>class定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/525d9b7262f741f9bca2f930506468b7.png" alt="在这里插入图片描述"></p><h2 id="CSS定位"><a href="#CSS定位" class="headerlink" title="CSS定位"></a>CSS定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/0abf427da66a4a8dad52ac8fa3b0ce1f.png" alt="在这里插入图片描述"></p><h2 id="TagName定位"><a href="#TagName定位" class="headerlink" title="TagName定位"></a>TagName定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/a73094ff34a14259bca629e55e049511.png" alt="在这里插入图片描述"></p><h2 id="XPath定位"><a href="#XPath定位" class="headerlink" title="XPath定位"></a>XPath定位</h2><p><img src="https://i-blog.csdnimg.cn/direct/57dce248eae6482c80b33f4211fabf3c.png" alt="在这里插入图片描述"></p><h1 id="WebDriver相关"><a href="#WebDriver相关" class="headerlink" title="WebDriver相关"></a>WebDriver相关</h1><p><img src="https://i-blog.csdnimg.cn/direct/f43dfaac327f4971a97b83e9fc3dce54.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/67bfe0083c3d45ae8b6b7075b45cce7b.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/direct/6cf1420c1afd4db0b33268e02b862723.png" alt="在这里插入图片描述"></p><h1 id="WebElement元素交互相关"><a href="#WebElement元素交互相关" class="headerlink" title="WebElement元素交互相关"></a>WebElement元素交互相关</h1><p><img src="https://i-blog.csdnimg.cn/direct/c7afb7fa1a4c4246b1a311ef1053df1f.png" alt="在这里插入图片描述"></p><h1 id="特殊元素操作"><a href="#特殊元素操作" class="headerlink" title="特殊元素操作"></a>特殊元素操作</h1><h2 id="处理弹框"><a href="#处理弹框" class="headerlink" title="处理弹框"></a>处理弹框</h2><blockquote><p>凡是通过 JS 实现的系统弹窗（&#x3D;&#x3D;警告框、确认框、提示框&#x3D;&#x3D;）, ⽆法通过⿏标右键检查选项获取元素信息。<br><code>Alert alert = driver.switchTo().alert();</code></p></blockquote><ul><li><code>getText()</code>获取文本信息</li><li><code>accept()</code>确认</li><li><code>dismiss()</code>取消</li></ul><h2 id="iframe处理"><a href="#iframe处理" class="headerlink" title="iframe处理"></a>iframe处理</h2><blockquote><p>frame是html的框架，所谓框架就是可以在同一个页面显示不止一个区域,iframe多用于嵌套页面。最常见的就是&#x3D;&#x3D;登录窗口&#x3D;&#x3D;了。<br><code>driver.switchTo().frame(id、name、index、WebElement);</code><br>切换完之后再查找默认界面的元素时需要再切换回去。</p></blockquote><h2 id="window多网页窗口处理"><a href="#window多网页窗口处理" class="headerlink" title="window多网页窗口处理"></a>window多网页窗口处理</h2><blockquote><p>用于切换窗口<br>浏览器打开新的页面时，如果不切换句柄将还是在默认页面，想查询新页面需要把句柄切换到这个窗口下</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/62ceb429187048e9b198bf72ee128dbc.png" alt="在这里插入图片描述"></p><h2 id="select下拉框"><a href="#select下拉框" class="headerlink" title="select下拉框"></a>select下拉框</h2><p><img src="https://i-blog.csdnimg.cn/direct/368349d687e342fa82eebee277046b4c.png" alt="在这里插入图片描述"></p><h2 id="JS脚本处理"><a href="#JS脚本处理" class="headerlink" title="JS脚本处理"></a>JS脚本处理</h2><p><img src="https://i-blog.csdnimg.cn/direct/5466bdef46954f0db04b9c2dd680d0b7.png" alt="在这里插入图片描述"></p><blockquote><p>去除仅可读的属性，以免手动输入<br><img src="https://i-blog.csdnimg.cn/direct/e5b02f20c4b3427486588b9a552346a7.png" alt="在这里插入图片描述"></p></blockquote><h2 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h2><ul><li><code>Actions actions = new Actions(driver);</code></li><li>移动鼠标到某个元素上:<code>actions.moveToElement(element).perform();</code></li><li>点击某个元素:<code>actions.click(element).perform();</code></li><li>双击某个元素:<code>actions.doubleClick(element).perform();</code></li><li>右键点击某个元素:<code>actions.contextClick(element).perform();</code></li><li>拖拽元素:<code>actions.dragAndDrop(sourceElement, targetElement).perform();</code></li><li>按下鼠标左键:<code>actions.clickAndHold(element).perform();</code></li></ul><h2 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h2><p>以下是Selenium中常用的键盘操作方法：</p><ul><li><code>sendKeys(Keys.ENTER)</code>：模拟按下Enter键.</li><li><code>sendKeys(Keys.TAB)</code>：模拟按下Tab键，用于在表单元素之间切换焦点.</li><li><code>sendKeys(Keys.BACK_SPACE)</code>：模拟按下Back Space键，用于删除字符.</li><li><code>sendKeys(Keys.DELETE)</code>：模拟按下Delete键，用于删除字符.</li><li><code>sendKeys(Keys.ESCAPE)</code>：模拟按下Esc键，用于退出当前操作或关闭弹窗等.</li><li><code>sendKeys(Keys.SPACE)</code>：模拟按下空格键.</li><li><code>sendKeys(Keys.SHIFT, &quot;text&quot;)</code>：模拟按下Shift键并输入文本，用于输入大写字母或特殊字符.</li><li><code>sendKeys(Keys.CONTROL, &quot;a&quot;)</code>：模拟按下Ctrl+A组合键，用于全选文本.</li><li><code>sendKeys(Keys.CONTROL, &quot;c&quot;)</code>：模拟按下Ctrl+C组合键，用于复制选中的文本.</li><li><code>sendKeys(Keys.CONTROL, &quot;v&quot;)</code>：模拟按下Ctrl+V组合键，用于粘贴文本.</li><li><code>sendKeys(Keys.ALT, &quot;f&quot;)</code>：模拟按下Alt+F组合键，用于打开浏览器菜单等.</li><li><code>sendKeys(Keys.ARROW_UP)</code>：模拟按下向上箭头键，用于在列表或文本框中向上移动光标.</li><li><code>sendKeys(Keys.ARROW_DOWN)</code>：模拟按下向下箭头键，用于在列表或文本框中向下移动光标.</li><li><code>sendKeys(Keys.ARROW_LEFT)</code>：模拟按下向左箭头键，用于在文本框中向左移动光标.</li><li><code>sendKeys(Keys.ARROW_RIGHT)</code>：模拟按下向右箭头键，用于在文本框中向右移动光标.</li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="https://i-blog.csdnimg.cn/direct/3b8aa122148f4a4cb0564da23d3b1d42.png" alt="在这里插入图片描述"></p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><ul><li>去掉验证码[常⽤]: 测试环境下采⽤</li><li>设置万能验证码[常⽤]: ⽣产环境和测试环境下采⽤, 必须注意保密不要外泄万能验证码</li><li>验证码识别技术: 通过 Python-tesseract 来识别图⽚类型验证码；识别率很难达到 100% </li><li>记录 cookie: 通过记录 cookie 进⾏跳过登录, 不能对登陆本身功能进⾏ 测试时使⽤</li></ul><h1 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h1><h2 id="傻等"><a href="#傻等" class="headerlink" title="傻等"></a>傻等</h2><blockquote><p>暂停线程一段时间后，继续执行后续代码，可以使用<code>Thread.sleep</code>&#x2F;<code>TimeUnit.SECONDS.sleep</code>的方式让当前线程暂停执行，二者都可以实现，并无差异。待休眠时间结束，线程可以继续执行。<br>两者区别</p><ul><li><code>Thread.sleep()</code>是<code>java.lang</code>包下的类方法，接收的参数单位是毫秒，若需要让当前线程暂停执行秒，分钟，小时等，需要手动根据毫秒单位来换算；</li><li><code>TimeUnit.SECONDS.sleep()</code>是<code>java.util.concurrent</code>包下的类方法，底层调用的依旧是 <code>Thread.sleep()</code>，是对该方法的包装，多了时间单位转换和验证。</li></ul></blockquote><h2 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h2><blockquote><p>在后续的所有元素查找操作中，如果元素没有立即出现，WebDriver 将在 一段时间内不断轮询页面，直到找到元素或者超时。<img src="https://i-blog.csdnimg.cn/direct/92b981c19e5d4094b93cdd8c7165794c.png" alt="在这里插入图片描述"><br><code>//隐式等待调用方式，设置等待时间为5秒</code><br><code>driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(5));</code></p></blockquote><h2 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h2><blockquote><p>显式等待是针对特定条件进行等待，它明确指定要等待的条件和最长等待时间。只有当特定条件满足时，代码才会继续执行。<img src="https://i-blog.csdnimg.cn/direct/1efafd7415a746a6880c605676e803b8.png" alt="在这里插入图片描述"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openqa.selenium.support.ui.ExpectedCondition;</span><br><span class="line"><span class="keyword">import</span> org.openqa.selenium.support.ui.WebDriverWait;</span><br><span class="line"><span class="comment">//设置5秒的最大等待时间，等待（By.tag_NAME,&quot;title&quot;）这个元素被点击`</span></span><br><span class="line"><span class="type">WebDriverWait</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDriverWait</span>(driver,Duration.ofSeconds(<span class="number">5</span>));</span><br><span class="line">wait.unitl(ExpectedConditions.elementToBClickable(By.tagName(<span class="string">&quot;title&quot;</span>)));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UI自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web自动化 </tag>
            
            <tag> 自动化框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础八股杂烩</title>
      <link href="/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/"/>
      <url>/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><ol><li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li><li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li></ol><img src="/./res\Kernel_Layout.png" alt="Kernel_Layout" style="zoom:67%;"><h3 id="操作系统的管理对象"><a href="#操作系统的管理对象" class="headerlink" title="操作系统的管理对象"></a>操作系统的管理对象</h3><p>OS是计算机系统资源的管理者：对处理器，存储器，IO设备，文件进行管理</p><ol><li>CPU：分配，控制</li><li>存储器：分配，管理，回收</li><li>IO设备：分配，操作，回收</li><li>文件：存取，共享，保护</li></ol><h3 id="Kernel和CPU"><a href="#Kernel和CPU" class="headerlink" title="Kernel和CPU"></a>Kernel和CPU</h3><h4 id="内核（Kernel）"><a href="#内核（Kernel）" class="headerlink" title="内核（Kernel）"></a>内核（Kernel）</h4><ol><li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的<strong>内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</li><li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li></ol><h4 id="中央处理器（CPU，Central-Processing-Unit）"><a href="#中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="中央处理器（CPU，Central Processing Unit）"></a>中央处理器（CPU，Central Processing Unit）</h4><ol><li><strong>CPU 是一台计算机的运算核心（Core）+ 控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li><li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li><li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li></ol><h4 id="CPU-vs-Kernel-内核"><a href="#CPU-vs-Kernel-内核" class="headerlink" title="CPU vs Kernel(内核)"></a>CPU vs Kernel(内核)</h4><ol><li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li><li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li></ol><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态(user mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据。</li><li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程几乎可以访问计算机的任何资源，不受限制。</li></ol><p>在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>这些系统调用按功能大致可分为如下几类：</p><ul><li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li><li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li><li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li><li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li><li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><img src="/./res\L181kk2Eou-compress.jpg" alt="img" style="zoom:67%;"><h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><ol><li>OS实现资源的抽象（抽象为对象，用户对计算机的使用大多集中在IO上），通过一定的抽象资源管理软件，将管理软件逐层覆盖再计算机硬件上，形成虚机器。虚机器是逐层系统软件覆盖再逻辑上而成的逻辑计算机</li></ol><blockquote><ul><li>第一层抽象：对IO设备的管理</li><li>第二层抽象：对文件的管理</li><li>第三层抽象：对图形操作的管理</li></ul></blockquote><ol start="2"><li>操作系统定义：能有效组织和管理四大资源，合理对各类作业进行调度和控制，方便用户使用的软件</li><li>分时系统：在一台主机上连接多个配有显示器和键盘的终端并由此构成的系统。系统允许多个用户同时通过自己的终端，以交互的方式使用计算机，共享主机资源</li><li>多路卡（缓存区池）：即时接收多终端的用户输入，实现分时多路复用。主机以极快的速度周期性扫描中断，用于接收中断数据。中断输入通过多路卡进入主机内存，将来获得CPU资源的计算。</li></ol><img src="/./res\1683451419914-aea0fbad-a8d7-46b4-bf18-ff94d9db2344.png" alt="image.png" style="zoom: 33%;"><ol start="6"><li><p>时间片：每个作业每次运行的最长时间，如果作业运行时间超过此，系统会暂停作业的执行，自动调度下一个作业运行。</p></li><li><p>实时系统：能够及时响应外部事件的请求，并且再规定的时间内完成该事件的处理，并控制所有逝世人物协调一致的运行。</p><blockquote><ul><li>周期性实时任务和非周期性实时任务（又分为 开始截止时间任务（在什么时间必须开始），完成戒截止时间任务（再什么时间必须结束））</li><li>硬实时任务HRT（必须满足时间要求） 和 软实时任务 SRT（seldom可以不满足）</li></ul></blockquote></li><li><p>微机操作系统：（PC机）</p></li><li><p>网络操作系统：同微机操作，服务类型不同</p></li><li><p>云操作系统：一种管理海量的基础硬件和软件资源的云平台综合管理系统（VMWare的VSphere，浪潮的云海，阿里的AliOS）</p></li><li><p>dubbo中的虚拟化可以解决一致性hash算法产生的负载均衡雪崩问题和影响不一致问题，具体方法是进行虚拟化，</p></li></ol><img src="https://cdn.nlark.com/yuque/0/2023/png/29364962/1683453218743-e1266959-f43c-4581-bfe0-df97e999b378.png#averageHue=%23f8daa6&clientId=ubbabcf32-b7f1-4&from=paste&height=914&id=u411ed5e8&originHeight=1142&originWidth=1507&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=381745&status=done&style=none&taskId=ue5a0d8c9-584f-4530-986c-75b82a95735&title=&width=1205.6" alt="image.png" style="zoom:33%;"><h2 id="操作系统特性"><a href="#操作系统特性" class="headerlink" title="操作系统特性"></a>操作系统特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a><strong>并发性</strong></h3><p>并发是指两个事件或者更多的事件在同一时间间隔发生，<strong>区别于并行，并行是在同一时刻运行多个任务，</strong>并发可以提高系统资源利用率，提高系统吞吐量。</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>并发的基本实现就是进程，进程是系统独立运行并作为资源分配的基本单位，由一组指令、数据和堆栈组成，是一个独立运行的活动实体。</p><h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>共享依据对资源复用的方式分为：互斥共享，同时访问</p><h4 id="互斥共享"><a href="#互斥共享" class="headerlink" title="互斥共享"></a>互斥共享</h4><p>可供多个进程，但是同一时刻只能允许一个进程访问</p><h4 id="同时访问"><a href="#同时访问" class="headerlink" title="同时访问"></a>同时访问</h4><p>允许在一段时间内由多个进程同时访问，单处理机实质上是交替访问磁盘，多处理机就是真正的同时访问</p><h3 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h3><p>通过某种技术将一个物理实体变为若干个逻辑上的对应物，此为虚拟。虚拟技术分为：时分复用，空分复用</p><h4 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h4><p>某设备的空闲状态可以为其他用户提供服务</p><h4 id="空分复用"><a href="#空分复用" class="headerlink" title="空分复用"></a>空分复用</h4><h4 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h4><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>不可预知性，不确定性。对于内存中的进程，不确定何时获取到处理器运行，何时由于提出临界资源请求暂停，工作总共需要多少时间才能完成，都是不可预知的，不确定的。<br>一个程序运行多次结果可能不相同，如果OS配置有完善的进程同步机制，在运行环境相同下，运行的结果一定是相同的</p><h4 id="Zookepper-协调性"><a href="#Zookepper-协调性" class="headerlink" title="Zookepper 协调性"></a>Zookepper 协调性</h4><p>分布式协调服务器，实现分布式系统同步运行，实现系统功能的协调推进。实现集群管理，Master选举，分布式锁，分布式队列</p><h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>：是程序一次执行过程，是<strong>系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程。<strong>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位</strong>。</p><img src="/./res\20150603133335514" alt="在这里插入图片描述" style="zoom: 67%;"><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><h5 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h5><img src="/./res\QQ截图20230510150756.png" style="zoom:67%;"><ul><li><p>就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</p><blockquote><p>另外，<strong>就绪进程可以按多个优先级来划分队列</strong>。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。</p></blockquote></li><li><p>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</p></li><li><p>阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</p></li></ul><h5 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h5><img src="/./res\8-进程五个状态.jpg" alt="进程五种状态的变迁" style="zoom:67%;"><ul><li><p><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</p></li><li><p><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</p><ul><li><strong>运行状态(running)</strong> ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li></ul></li><li><p><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</p></li><li><p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</p></li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ul><li><strong>匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程或者兄弟进程之间的通信。</li><li><strong>命名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了命名管道。命名管道严格遵循**先进先出(first in first out)**。命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（匿名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是<strong>最有用</strong>的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。<strong>套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元</strong>，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ul><h5 id="命名管道和匿名管道的区别"><a href="#命名管道和匿名管道的区别" class="headerlink" title="命名管道和匿名管道的区别"></a><strong>命名管道和匿名管道的区别</strong></h5><ul><li>匿名管道由pipe函数创建并打开</li><li>命名管道由mkfifo函数创建，打开用open</li></ul><p>匿名管道由于没有名字，只能用于亲缘关系的进程间通信。</p><p>命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p><h4 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h4><p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p><ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>高响应比优先调度算法</strong>：调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>最高优先级调度算法</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li><li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li></ul><p><strong>抢占式和非抢占式</strong></p><p>非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该<strong>进程完成</strong>或<strong>发生某个事件而被阻塞</strong>时，才会把 CPU 让给其他进程。</p><p>而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p><h5 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h5><p>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong></p><p><strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><img src="/./res\24-先来先服务.jpg" alt="FCFS 调度算法" style="zoom:67%;"><p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p><p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p><h5 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h5><p><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p><img src="/./res\25-最短作业优先算法.jpg" alt="SJF 调度算法" style="zoom:67%;"><p>这显然对长作业不利，很容易造成一种极端现象。</p><p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p><h5 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h5><p><strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</p><p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p><img src="/./res\26-响应比公式.jpg" alt="img" style="zoom:67%;"><ul><li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li><li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li></ul><h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p><img src="/./res\27-时间片轮询.jpg" alt="RR 调度算法" style="zoom:67%;"><p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p><ul><li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li><li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li></ul><p>另外，时间片的长度就是一个很关键的点：</p><ul><li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li><li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li></ul><p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p><h5 id="最高优先级调度算法"><a href="#最高优先级调度算法" class="headerlink" title="最高优先级调度算法"></a>最高优先级调度算法</h5><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p><p>进程的优先级可以分为，静态优先级或动态优先级：</p><ul><li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li></ul><p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p><h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p><strong>多级反馈队列调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><p>顾名思义：</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><img src="/./res\28-多级队列.jpg" alt="多级反馈队列" style="zoom:67%;"><p>来看看，它是如何工作的：</p><ul><li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li><li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li><li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li></ul><p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程</strong>：<strong>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位</strong>。线程是比进程更小的执行单位。一个进程在其执行的过程中，可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。<strong>详细线程解析在java板块中</strong></p><p><img src="/.%5Cres%5C133750_ldwM_1863332.jpg" alt="在这里插入图片描述"></p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p><a href="https://blog.csdn.net/pange1991/article/details/53860651?ops_request_misc=%7B%22request_id%22:%22165753938316781647571786%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165753938316781647571786&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53860651-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81&spm=1018.2226.3001.4187">Java线程的6种状态及切换(透彻讲解)</a></p><ol><li>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(RUNNABLE)<strong>：Java线程中将</strong>就绪（ready）</strong>和<strong>运行中（running）</strong>两种状态笼统的称为“运行”。</li><li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li><li>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>**终止(TERMINATED)**：表示该线程已经执行完毕。</li></ol><img src="/八股笔记.assets/20181120173640764.jpeg" alt="线程状态图" style="zoom: 67%;"><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（就绪）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行中）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><p><strong>线程阻塞的三种情况</strong></p><ol><li><strong>等待阻塞</strong>（Object.wait -&gt; 等待队列）<br>RUNNING 状态的线程执行 Object.wait() 方法后，JVM 会将线程放入等待序列（waitting queue）；</li><li><strong>同步阻塞</strong>（lock -&gt; 锁池）<br>RUNNING 状态的线程在获取对象的同步锁时，若该 同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中；</li><li><strong>其他阻塞</strong>（sleep&#x2F;join）<br>RUNNING 状态的线程执行 Thread.sleep(long ms) 或 Thread.join() 方法，或发出 I&#x2F;O 请求时，<br>JVM 会将该线程置为阻塞状态。当 sleep() 状态超时， join() 等待线程终止或超时. 或者 I&#x2F;O 处理完<br>毕时，线程重新转入可运行状态（ RUNNABLE ）；</li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="死锁的引发"><a href="#死锁的引发" class="headerlink" title="死锁的引发"></a>死锁的引发</h5><p>系统中以下四个条件同时成立，那么就能引起死锁：</p><ol><li><strong>互斥条件</strong>：该资源任意时刻只由一个线程占用。</li><li><strong>请求与保持条件</strong>（持有并等待条件）：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不可剥夺条件</strong>（<strong>非抢占</strong>）：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件</strong>（环路等待条件）：若干线程之间形成一种头尾相接的循环等待资源关系。有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ol><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p><ul><li><strong>预防</strong>是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ul><h5 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h5><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p><p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p><p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所有资源，会导致 <strong>资源利用率下降</strong>。</p><p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p><p><strong>静态分配策略</strong></p><p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指<strong>一个进程必须在执行前就申请到它所需要的全部资源</strong>，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p><p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在进程所占有的资源中，有些资源是在比较靠后的执行时间里才用到，甚至有些资源是在额外的情况下才使用，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p><p><strong>层次分配策略</strong></p><p><strong>层次分配策略破坏了产生死锁的第四个条件(循环等待)。</strong>在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一层的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p><h5 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h5><p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p><p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p><blockquote><p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p></blockquote><p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，&#x3D;&#x3D;银行家算法&#x3D;&#x3D;用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p><p>银行家算法详情可见：<a href="https://blog.csdn.net/qq_33414271/article/details/80245715">《一句话+一张图说清楚——银行家算法》open in new window</a> 。</p><p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p><h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁，等到真的死锁出现了再来解决，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p><p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p><h6 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h6><p>操作系统中的每一刻时刻的<strong>系统状态</strong>都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p><p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p><p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p><img src="/./res\进程-资源分配图.31e353df.jpg" alt="进程-资源分配图" style="zoom: 25%;"><h6 id="死锁检测步骤"><a href="#死锁检测步骤" class="headerlink" title="死锁检测步骤"></a>死锁检测步骤</h6><p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p><ol><li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li><li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li><li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li></ol><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p><ol><li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li><li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><strong>协程：</strong>是一种比线程更加轻量级的存在，<strong>协程不是被操作系统内核所管理，而完全是由程序所控制</strong>（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p><img src="/D:/笔记/八股笔记.assets/6765e36cc4604fba897976638af03524.jpeg" alt="在这里插入图片描述" style="zoom:50%;"> </p><p><strong>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p><h4 id="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"><a href="#协程的特点在于是一个线程执行，那和多线程比，协程有何优势？" class="headerlink" title="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"></a>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</h4><p><strong>极高的执行效率</strong>：因为子程序切换不是线程切换，而是由程序自身控制，因此，<strong>没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显；</p><p><strong>不需要多线程的锁机制</strong>：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><h3 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h3><ul><li><strong>根本区别</strong>：进程是操作系统<strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度和执行</strong>的基本单位</li><li><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有<strong>较大的开销</strong>；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li><strong>执行过程</strong>：每个独立的进程有程序运行的入口。顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。</li></ul><p>对于，线程相比进程能减少开销，体现在：</p><ul><li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li><li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li></ul><p> <strong>总结：</strong> </p><ul><li><p>线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</p></li><li><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p></li><li><p>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p></li></ul><h3 id="并发和并行区别"><a href="#并发和并行区别" class="headerlink" title="并发和并行区别"></a>并发和并行区别</h3><p><strong>并发是指一个处理器同时处理多个任务。</strong><br><strong>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</strong></p><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li></ul><p>当有多个线程在操作时,如果系统只有<strong>一个CPU</strong>,则它根本不可能真正同时进行一个以上的线程,它只能<strong>把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,<strong>在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为</strong>&#x3D;&#x3D;并发&#x3D;&#x3D;</strong>(Concurrent)。</p><p>当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,<strong>两个线程互不抢占CPU资源</strong>,可以同时进行,这种方式我们称之为<strong>并行</strong>(Parallel)。</p><h3 id="同步和异步区别"><a href="#同步和异步区别" class="headerlink" title="同步和异步区别"></a>同步和异步区别</h3><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><h3 id="线程安全和不安全"><a href="#线程安全和不安全" class="headerlink" title="线程安全和不安全"></a>线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><a href="https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)</a></p><h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ul><li><p><strong>内存空间的分配与回收</strong></p><p>操作系统负责对内存空间的分配与回收，对于一个进程来讲，有很多位置可以放置，那么应该放在哪里？所以OS需要记住哪些内存区域已经被分配出去了，哪些还是空闲的，当进程运行结束之后，如何将进程占用的内存空间进行回收？这些都是操作系统对于内存空间的分配和回收功能需要考虑的问题。</p></li><li><p><strong>内存空间的扩充</strong></p><p>操作系统需要提供某种技术从逻辑上对于内存空间进行扩充。</p></li><li><p><strong>地址转换</strong></p><p>操作系统需要提供地址转换功能，负责将程序的逻辑地址与物理地址进行转换。</p></li><li><p><strong>存储保护</strong></p><p>操作系统需要提供内存保护的功能，保证各个进程在各自的存储空间内运行，互相不干扰。</p></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="定义与优点"><a href="#定义与优点" class="headerlink" title="定义与优点"></a>定义与优点</h4><ul><li><strong>定义：虚拟内存是操作系统为每个进程提供的一个连续的虚拟地址空间，并且把内存扩展到硬盘空间</strong>，它让每个进程觉得自己拥有一片连续的可用内存，但是实际上<strong>这片连续的内存空间由多个离散的物理内存页和部分存储在外部磁盘上的文件组成</strong>。因此，我们程序所使用的内存地址叫做虚拟内存地址，实际的内存地址叫做物理内存地址。</li><li><strong>优点</strong><ul><li><strong>隔离进程之间的地址空间</strong>：操作系统将不同进程的虚拟地址与不同的物理内存地址和磁盘文件映射起来，使得各个进程之间的物理内存地址不会发生冲突，当进程要访问内存中的数据时，由操作系统将虚拟内存地址转换为实际的物理内存地址。</li><li><strong>提高内存空间：</strong>虚拟内存将程序的部分数据存储在外部硬盘上，让程序可以拥有超过系统物理内存大小的内存空间，使得大型程序的编写变得更容易</li><li><strong>提高内存利用率：</strong>早期计算机在运行程序的时候将程序全部装入内存，但实际上程序只需要访问一部分内存数据即可正常运行，导致内存中会存在大量暂时用不到的数据，浪费了内存资源。</li></ul></li></ul><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>定义</strong>：局部性原理是指程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。局部性原理表现在以下两个方面：</p><ul><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ul><p><strong>应用</strong>：</p><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。</p><h4 id="虚拟内存技术实现"><a href="#虚拟内存技术实现" class="headerlink" title="虚拟内存技术实现"></a>虚拟内存技术实现</h4><ul><li><p><strong>请求分页存储管理</strong></p><p>建立在分页管理的基础上，增加了请求调页功能和页面置换功能。在请求分页存储管理系统中，在作业开始运行之前，仅装入要执行的部分页面即可运行，将暂时不要的页面存在在外部磁盘中。假如在作业运行的过程中发现要访问的页面不在内存中，操作系统需要将对应的页面从磁盘调入内存中，如果内存中没有空间了，需要使用页面置换算法来将相应的页面调入内存。</p></li><li><p><strong>请求分段存储管理</strong></p></li><li><p><strong>请求段页式存储管理</strong></p></li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>可以简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>分段式管理</strong>、<strong>分页式管理</strong> 和 <strong>段页式管理</strong>。</p><h4 id="分段式管理"><a href="#分段式管理" class="headerlink" title="分段式管理"></a>分段式管理</h4><p><strong>定义</strong>：按照程序自身的逻辑关系将地址空间划分为若干个段，每个段有一个段名，每段从0开始编址，每个段在内存中占据连续的地址空间，但是各段之间可以不相邻。</p><p><strong>逻辑地址结构</strong>：由段号(段名)和段内地址(段内偏移量)所组成。段号的位数决定了每个进程最多可以分为几个段，段内地址位数决定了每个段的最大长度。</p><p><strong>段表</strong>：为每个进程建立的一张段映射表，将逻辑地址与物理地址映射起来。</p><ul><li>每个段对应一个段表项，其中记录了该段在内存中的起始位置(基址)和段的长度(段长)。</li><li>各个段表项的长度是相同的。</li></ul><img src="/D:/笔记/八股笔记.assets/image-20220528195224834.png" alt="image-20220528195224834" style="zoom: 67%;"><p><strong>地址转换</strong>：</p><ul><li>根据逻辑地址得到段号和段内地址</li><li>判断段号是否越界，即若段号大于等于每个进程的最大段数，则产生越界中断</li><li>如果没有越界，则查询段表，找到对应的段表项，得到该段对应的基址</li><li>检查段内地址是否大于段长，若大于则产生越界中断</li><li>如果没有越界，则物理地址&#x3D;段基址+段内地址</li></ul><h4 id="分页式管理"><a href="#分页式管理" class="headerlink" title="分页式管理"></a>分页式管理</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>把内存空间分为一个个大小相等的分区，每个分区叫做一个<strong>页框</strong>，每个页框有一个编号，即<strong>页框号</strong>，页框号从0开始。将用户进程的地址空间也分为与页框大小相等的一个个区域，每个区域称为<strong>页面</strong>，每个页面也有一个编号，即<strong>页面号</strong>，页面号也是从0开始。操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，换句话说就是进程的页面与内存的页框有着一一对应的关系，各个页面不必连续存放，也不必按照先后顺序存放，可以放到不相邻的各个页框中。</p><img src="/D:/笔记/八股笔记.assets/image-20220524161145410.png" alt="image-20220524161145410" style="zoom: 67%;"><h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h5><p>物理地址&#x3D;逻辑地址所在页号对应的起始内存地址+页内偏移量</p><ul><li><p>如何计算页号和页内偏移量：</p><p>页号 &#x3D; 逻辑地址&#x2F;页面长度、页内偏移量 &#x3D; 逻辑地址%页面长度</p></li><li><p>如何找到页号对应的起始内存地址：</p><p>操作系统为每个进程建立了一张页表，进程的每一页对应一个页表项，每个页表项由<strong>页号</strong>和<strong>页框号</strong>组成，页表记录了每个进程中页面与实际存放的内存块之间的对应关系，由于每个页表项的长度是相同的，因此页表中页号是隐含的，即第一个页表项对应第0页，第二个页表项对应第1页，以此类推。</p></li><li><p><strong>地址转换过程</strong>：</p><p>在系统中设置一个页表寄存器(PTR)，用来存放页表在内存中的起始地址F和页面长度M。在进程未执行时，页表的起始地址和页面长度存放在进程控制块(PCB)中，当进程被调度时，操作系统会将他们放到PTR中，那么将逻辑地址转换为物理地址的过程如下：</p><p>a.根据逻辑地址计算出页号与页内偏移量。</p><p>b.根据PTR得到页表的起始地址和页面长度，判断页号是否越界，即页号是否大于等于页面长度，如果越界则产生越界中断。</p><p>c.如果未越界，则查询页表得到该页号对应的页表项，从而得到对应的页框号</p><p>d.通过页框号和页内偏移量得到物理地址</p></li></ul><h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><ul><li><p>为什么需要多级页表：</p><p>因为单级页表会占用大量的内存空间。从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址，假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了，所以页表一定要覆盖全部虚拟地址空间，假设每个进程有4GB的虚拟地址空间，每个页面大小为4KB，则不分级的页表就需要1M个页表项来映射，每个页表项占4B，即每个进程的页表大小为4MB，由于<strong>操作系统可以同时运行非常多的进程，意味着内存中有大量的空间用来存储页表，造成了内存空间的浪费。使用多级页表可以压缩页表占用的内存，有效的节约了内存空间</strong>。<strong>多级页表属于时间换空间，解决了虚拟地址空间大导致的页表占用大量内存的问题</strong>。</p></li><li><p>二级分页：</p><p>假设虚拟地址空间为4GB，页面大小为4KB，将上述不分级的1M个页表项先使用一个一级页表进行再分页，分为1K个一级页表项，每个一级页表下面又分为了1K个二级页表，每个一级页表项中存储的是它对应的二级页表项的首地址。</p><img src="/D:/笔记/八股笔记.assets/image-20220531094738155.png" alt="image-20220531094738155" style="zoom: 67%;"></li><li><p><strong>二级分页为什么能节约内存</strong>：</p><ul><li><p><strong>二级页表可以不存在</strong></p><p>​一级页表覆盖了整个4GB虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。</p></li><li><p><strong>二级页表可以不在主存</strong></p><p>​在请求分页存储管理中，根据局部性原理，当需要用到某个页面时，将此页面从磁盘调入到内存；当内存中页面满了时，将内存中的页面调出到磁盘，由于虚拟内存地址存在着局部性，因此所有的二级页表中只会有很少的一部分在某一时刻正在使用，我们就可以把其余的二级页表放入磁盘中，在需要时才调入内存。</p></li></ul></li></ul><h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><ul><li><p>为什么引入快表：</p><p>在使用多级页表之后虽然解决了内存空间上的问题，但是导致虚拟地址到物理地址的转换多了几道工序，降低了虚拟地址到物理地址的转换速度，因此引入快表来加速虚拟地址到物理地址的转换。</p></li><li><p>什么是快表：</p><p>可以把快表理解为一种高速缓存（Cache），其中存储的是程序最常访问的几个页表项。</p></li><li><p><strong>加入快表后的地址转换流程</strong>：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol></li></ul><h4 id="分段VS分页"><a href="#分段VS分页" class="headerlink" title="分段VS分页"></a>分段VS分页</h4><p><strong>共同点</strong></p><p>​分段和分页都是离散的内存管理方式，目的都是为了提高内存利用率和减少内存碎片。</p><p><strong>区别</strong></p><ul><li>页是信息的物理单位，分页仅仅是为了满足操作系统内存管理的需求，完全是系统行为，对用户是不可见的；而段是信息的逻辑单位，一个段通常包含着一组属于一个逻辑模块的信息，分段对用户是可见的，用户编程时需要显示地给出段名。</li><li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li></ul><h4 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h4><p><strong>定义</strong>：先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；地址结构由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p><strong>地址变换：</strong></p><ul><li><p>用于段页式地址变换的数据结构：</p><p>每个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号。</p></li><li><p>地址变换过程：</p><p>第一次访问段表，得到页表起始地址；第二次访问页表，得到物理页号；第三次将物理页号与页内位移组合得到物理地址。</p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>​在地址映射过程中，如果所要访问的页面不在内存中，就会发生<strong>缺页中断</strong>，此时需要操作系统将要访问的页面调入主存后再进行访问。如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。</p><h4 id="常见的页面置换算法"><a href="#常见的页面置换算法" class="headerlink" title="常见的页面置换算法"></a>常见的页面置换算法</h4><p><strong>最佳页面置换算法</strong></p><p>​最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</p><p><strong>FIFO 页面置换算法</strong></p><p>​选择在内存中驻留时间最久的页面进行淘汰。</p><p><strong>LRU 页面置换算法</strong></p><p>​赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当必须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p><p><strong>LFU 页面置换算法</strong></p><p>​选择在之前时期使用最少的页面作为淘汰页。</p><h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><h3 id="微内核的特征"><a href="#微内核的特征" class="headerlink" title="微内核的特征"></a>微内核的特征</h3><ol><li>提供基础核心功能（支持功能和资源管理功能）</li><li>基于C&#x2F;S模式 （消息传递机制实现信息交互，通过调用内核提供的系统调用实现）</li><li>机制与策略原理 （机制区别于策略，机制在底层，策略在高层）</li></ol><h3 id="内核提供的支撑功能"><a href="#内核提供的支撑功能" class="headerlink" title="内核提供的支撑功能"></a>内核提供的支撑功能</h3><p>内核提供给OS其他服务进程（服务器）的基本功能，是其他服务进程模块功能实现的支撑</p><p><strong>中断处理</strong></p><p>中断处理是内核最基本的功能，是整个OS工作的基础，没有中断处理就没有OS的并发，CPU的中断时短暂的，在经过短暂的中断后，CPU会转入到其他进程完成工作</p><p><strong>时钟管理</strong></p><p>时间片轮转调度中，当时间片用完，时钟会触发一个中断信号，调度程序会重新进行调度</p><p><strong>原语操作</strong></p><p>要么全做，要么全不做</p><h3 id="内核提供的资源管理功能"><a href="#内核提供的资源管理功能" class="headerlink" title="内核提供的资源管理功能"></a>内核提供的资源管理功能</h3><p><strong>进程管理</strong></p><p>OS可以实现对进程的基础化管理，基础化管理功能使用频率很高</p><p><strong>存储器管理</strong></p><p>OS存储器管理相关进程的运行平吕很高，放入内核中，可以提升存储器的运行效率，提高读写速度</p><p><strong>设备管理</strong></p><p>设备管理与计算机硬件紧密相关，大部分功能都是常驻内核的</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p><strong>inode 是 linux&#x2F;unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p><p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p><p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p><p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux&#x2F;Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p><p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p><ul><li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li><li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li></ul><h4 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h4><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p><ul><li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li><li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li><li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li><li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li><li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li><li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li><li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li></ul><h3 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h3><p>Linux 命令在线速查手册：<a href="https://www.w3xue.com/manual/linux/">https://www.w3xue.com/manual/linux/</a> </p><h4 id="查看系统性能"><a href="#查看系统性能" class="headerlink" title="查看系统性能"></a><strong>查看系统性能</strong></h4><h5 id="查看内存和CPU信息"><a href="#查看内存和CPU信息" class="headerlink" title="查看内存和CPU信息"></a><strong>查看内存和CPU信息</strong></h5><p>cpu信息   cat &#x2F;proc&#x2F;cpuinfo  </p><p>内存信息  cat &#x2F;proc&#x2F;meminfo |grep MemTotal </p><p>查看物理cpu个数：cat &#x2F;proc&#x2F;cpuinfo | grep ‘physical id’ | sort | uniq | wc -l</p><p>查看逻辑cpu个数：cat &#x2F;proc&#x2F;cpuinfo | grep ‘processor’ | wc -l</p><p>查看单cpu是几核：cat &#x2F;proc&#x2F;cpuinfo | grep ‘cores’ |uniq</p><p>查看cpu主频：   cat &#x2F;proc&#x2F;cpuinfo | grep ‘MHz’</p><p>查看cpu是32位还是64位： getconf LONG_BIT、echo $HOSTTYPE、uname -a</p><h5 id="查看主机运行时间和Linux系统负载"><a href="#查看主机运行时间和Linux系统负载" class="headerlink" title="查看主机运行时间和Linux系统负载"></a><strong>查看主机运行时间和Linux系统负载</strong></h5><p>uptime:</p><p><img src="/.%5Cres%5Cwps1.jpg" alt="img"> </p><p>10:19:04 &#x2F;&#x2F;系统当前时间</p><p>up 257 days, 18:56 &#x2F;&#x2F;主机已运行时间，时间越大，说明你的机器越稳定。</p><p>12 user &#x2F;&#x2F;用户连接数，是总连接数而不是用户数</p><p>load average &#x2F;&#x2F; 系统平均负载，统计最近1，5，15分钟的系统平均负载</p><p>信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。系统平均负载是指在特定时间间隔内运行队列中的平均进程数。在0.00-1.00之间正常</p><h5 id="实时监控cpu"><a href="#实时监控cpu" class="headerlink" title="实时监控cpu"></a>实时监控cpu</h5><p>①<strong>top</strong>命令是Linux下常用的<strong>性能分析工具</strong>，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p><img src="https://img-blog.csdnimg.cn/20210415155339881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ2NTM5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;"><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234603901.png" alt="image-20240118234603901"></p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234700032.png" alt="image-20240118234700032"></p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234714597.png" alt="image-20240118234714597"></p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234801672.png" alt="image-20240118234801672"></p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234814306.png" alt="image-20240118234814306"></p><p>②Vmstat是最常见的Linux&#x2F;Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。</p><h5 id="实时监控内存"><a href="#实时监控内存" class="headerlink" title="实时监控内存"></a>实时监控内存</h5><p>free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存</p><p>查看内存实时情况</p><p>free –h （以G为单位）</p><p>free –m （以M为单位）</p><p>free （以K为单位）</p><p>free –s 10（间隔10s刷新一次）周期性查看内存使用情况</p><h4 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h4><p>cd usr： 切换到该目录下usr目录</p><p>cd ..（或cd..&#x2F;）： 切换到上一层目录</p><p>cd &#x2F;： 切换到系统根目录</p><p>cd ~： 切换到用户主目录</p><p>cd -： 切换到上一个操作所在目录</p><h4 id="目录的操作命令（增删改查）"><a href="#目录的操作命令（增删改查）" class="headerlink" title="目录的操作命令（增删改查）"></a>目录的操作命令（增删改查）</h4><p>①mkdir 目录名称： 增加目录</p><p>②ls或者ll（ll是ls -l的别名，ll命令可以看到该<strong>目录下的所有目录和文件的详细信息</strong>）：查看目录信息</p><p>③find 目录 参数：寻找目录（查）</p><p>④mv 目录名称 新目录名称：修改目录的名称（改）</p><p>注意： mv命令用来对文件或目录<strong>重新命名</strong>，或者将文件从一个目录<strong>移到</strong>另一个目录中。</p><p>mv 目录名称 目录的新位置：移动目录的位置—剪切（改）</p><p>注意：另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p><p>⑤cp -r 目录名称 目录拷贝的目标位置：拷贝目录（改），-r代表递归拷贝</p><p>注意：拷贝文件和压缩包时不用写-r递归</p><p>⑥rm [-rf] 目录: 删除目录（删）</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录&#x2F;文件&#x2F;压缩包</p><h4 id="文件的操作命令（增删改查）"><a href="#文件的操作命令（增删改查）" class="headerlink" title="文件的操作命令（增删改查）"></a>文件的操作命令（增删改查）</h4><p>①touch 文件名称: 文件的创建（增）</p><p>②cat&#x2F;more&#x2F;less&#x2F;tail 文件名称: 文件的查看（查）</p><p>cat： 查看显示文件内容</p><p>more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</p><p>less： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</p><p>tail-10 ： 查看文件的后10行，Ctrl+C结束</p><p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控文件的变化</p><p>③vim 文件： 修改文件的内容（改）</p><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p><p>④rm -rf 文件：删除文件（删）</p><h4 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h4><p>①打包并压缩文件：</p><p>tar -zcvf 打包压缩后的文件名 要打包压缩的文件 其中：z：调用gzip压缩命令进行压缩；c：打包文件；v：显示运行过程；f：指定文件名；</p><p>②解压压缩包：</p><p>tar [-xvf] 压缩文件</p><p>x：代表解压</p><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>1）pwd： 显示当前所在位置</p><p>2）sudo + 其他命令：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p><p>3）grep 要搜索的字符串 要搜索的文件 –color： 搜索命令，–color代表高亮显示</p><p>4）ps -ef&#x2F;ps -aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程），也可使用 pgrep redis -a。</p><p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p><p>5）kill -9 进程的pid：杀死进程（-9 表示强制终止）</p><p>先用ps查找进程，然后用kill杀掉</p><p>6）查看当前系统的网卡信息：ifconfig</p><p>7）查看与某台机器的连接情况：ping</p><p>8）查看当前系统的端口使用：netstat -an</p><p>9）net-tools 和 iproute2 ： net-tools起源于BSD的TCP&#x2F;IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。</p><p>10）shutdown -h now： 指定现在立即关机；</p><p>11）shutdown +5 “System will shutdown after 5 minutes”：指定5分钟后关机，同时送出警告信息给登入用户。</p><p>12）reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）</p><p>13）&#x2F;proc：Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储了当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态</p><p>14）wc：命令用于计算字数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-clw][--help][--version][文件...]</span><br></pre></td></tr></table></figure><ul><li>-c或–bytes或–chars 只显示Bytes数。</li><li>-l或–lines 显示行数。</li><li>-w或–words 只显示字数。</li><li>–help 在线帮助。</li><li>–version 显示版本信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> testfile testfile_1 testfile_2  <span class="comment">#统计三个文件的信息</span></span>  </span><br><span class="line">3 92 598 testfile                    #第一个文件行数为3、单词数92、字节数598  </span><br><span class="line">9 18 78 testfile_1                   #第二个文件的行数为9、单词数18、字节数78  </span><br><span class="line">3 6 32 testfile_2                    #第三个文件的行数为3、单词数6、字节数32  </span><br><span class="line">15 116 708 总用量                    #三个文件总共的行数为15、单词数116、字节数708 </span><br></pre></td></tr></table></figure><h3 id="Linux-IO"><a href="#Linux-IO" class="headerlink" title="Linux IO"></a>Linux IO</h3><h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><ul><li>阻塞 IO: 在内核将数据准备好之前, 系统调用会一直等待。所有的套接字, 默认都是阻塞方式。</li><li>非阻塞 IO: 如果内核还未将数据准备好, 系统调用仍然会直接返回, 并且返回 EWOULDBLOCK 错误码.非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符, 这个过程称为轮询. 这对CPU来说是较大的浪费, 一般只有特定场景下才使用.</li><li>信号驱动 IO: 内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作。</li><li>IO 多路复用: 虽然从流程图上看起来和阻塞IO类似. 实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态.</li><li>异步 IO: 由内核在数据拷贝完成时, 通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据).</li></ul><h4 id="IO多路复用（select、poll、epoll）"><a href="#IO多路复用（select、poll、epoll）" class="headerlink" title="IO多路复用（select、poll、epoll）"></a>IO多路复用（select、poll、epoll）</h4><ul><li><p>select：时间复杂度 O(n)<br>select 仅仅<strong>知道有 I&#x2F;O 事件发生</strong>，<strong>但并不知道是哪几个流</strong>，所以只能<strong>无差别轮询所有流</strong>，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><ul><li>内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。<ul><li>每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大</li><li>同时，每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大</li><li>select支持的文件描述符数量太小，默认最大支持1024个</li><li>主动轮询效率很低</li></ul></li></ul></li><li><p>poll：时间复杂度 O(n)<br>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后<strong>查询每个 fd（文件描述符） 对应的设备状态</strong>， 但是它<strong>没有最大连接数的限制</strong>，原因是它是基于链表来存储的。</p><ul><li>无最大连接数限制，因其基于链表存储，缺点：<ul><li>大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</li><li>若报告了fd后，没有被处理，则下次poll时会再次报告该fd</li></ul></li></ul></li><li><p>epoll：时间复杂度 O(1)<br>epoll 模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以 epoll 模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p><p>epoll 可以理解为 event poll，epoll <strong>会把哪个流发生了怎样的 I&#x2F;O 事件通知我们</strong>。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。</p></li></ul><blockquote><p> select，poll，epoll 都是 IO 多路复用的机制。I&#x2F;O 多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O 的实现会负责把数据从内核拷贝到用户空间。</p></blockquote><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>计算机网络体系可以分为三种：<strong>OSI 七层模型</strong>、<strong>OSI 五层模型</strong>、<strong>TCP&#x2F;IP四层模型</strong></p><ul><li>OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li><li>OSI五层模型：将上三层合并为一层，做了一定的简化</li><li>TCP&#x2F;IP四层模型：从实际应用中总结出来，实质上TCP&#x2F;IP主要实现上三层，底层不涉及</li></ul><img src="/./res\网络模型.png" style="zoom: 67%;"><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><img src="/./res\osi-7-model.png" style="zoom:67%;"><p><strong>七层网络</strong>体系结构各层的主要功能：</p><ul><li>应用层：<strong>为应用程序提供交互服务</strong>。在互联网中的应用层协议很多，如域名系统 <strong>DNS</strong>，支持万维网应用的 <strong>HTTP</strong> 协议，支持电子邮件的 <strong>SMTP</strong> 协议等。</li><li>表示层：主要<strong>负责数据格式的转换</strong>，如加密解密、转换翻译、压缩解压缩等。格式有，JPEG、ASCll、DECOIC、加密格式等。</li><li>会话层：负责<strong>在网络中的两节点之间建立、维持和终止会话</strong>，如服务器验证用户登录便是由会话层完成的。</li><li>传输层：向主机进程<strong>提供通用的数据传输服务</strong>。该层主要有以下两种协议：<ul><li><strong>TCP</strong>：提供面向连接的、可靠的数据传输服务；</li><li><strong>UDP</strong>：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li></ul></li><li>网络层：进行<strong>逻辑地址寻址</strong>，<strong>实现不同网络之间的路径选择</strong>。选择合适的路由和交换结点，确保数据及时传送协议有：ICMP IGMP <strong>IP</strong>（IPV4 IPV6） ARP RARP。</li><li>数据链路层：<strong>建立逻辑连接、进行硬件地址寻址、差错校验等功能。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。</strong><ul><li>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li></ul></li><li>物理层 ：实现相邻节点间<strong>比特流的透明传输</strong>，尽可能屏蔽传输介质和通信手段的差异。</li></ul><p><strong>五层模型</strong>就是将<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>合并为<strong>应用层</strong>。</p><p><strong>缺点：</strong>OSI 的协议实现起来<strong>过分复杂</strong>，而且<strong>运行效率很低</strong>，<strong>层次划分不太合理</strong>，有些功能在多个层次中重复出现。</p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h2><img src="/./res\封装.png" style="zoom:50%;"><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li><strong>功能</strong></li></ul><p>​<strong>主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输</strong>。 把应用层交互的<strong>数据单元称为报文</strong>。</p><ul><li><strong>应用层协议</strong>：HTTP：超文本传输协议，SMTP：电子邮件传输协议，FTP：文件传输协议，DNS：域名服务，Telnet：远程终端协议， WebSocket：双工通信协议</li><li><strong>路由</strong>：<strong>数据格式到数据格式</strong></li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul><li><p><strong>功能</strong></p><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p></li></ul><p>​为应用层提供网络支持，作为应用间数据传输的媒介，帮助实现应用到应用的通信，但是<strong>并没有实际的传输功能</strong>。传输层的<strong>数据单元为TCP报文段（UDP数据报）</strong></p><ul><li><strong>传输层协议</strong><ul><li><p>TCP</p><ol><li><p>TCP 叫做传输控制协议，大部分应用使用的都是 TCP 传输层协议，TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p></li><li><p>如果应用需要传输的数据包大于MSS(TCP最大报文段长度)，需要将数据包分段，即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包，把每个分块称为一个TCP段</p></li></ol></li><li><p>UDP：叫做用户数据包协议，只负责发送数据包，不保证数据包是否能抵达对方，但它<strong>实时性相对更好，传输效率也高</strong></p></li></ul></li><li><strong>路由</strong>：<strong>应用程序到应用程序</strong>，两个地址的<strong>端口之间</strong>的通信</li></ul><h3 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h3><ul><li><strong>功能</strong>：<strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，<strong>网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送</strong>。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>，简称数据报，<strong>数据单元：IP数据报</strong>。</li><li><strong>网络层协议</strong>：<ul><li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP&#x2F;IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是<strong>网络层地址和链路层地址之间的转换问题</strong>，实际上是<strong>网络层和网络接口层之间的协议</strong>。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>NAT : 网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——<strong>网络地址转换，应用于内部网到外部网的地址转换过程中</strong>。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li></ul></li><li><strong>路由</strong>：<strong>网络地址到网络地址</strong>，信源到信宿，两个网络地址之间的通信</li></ul><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><ul><li><strong>功能</strong>：网络接口层负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。网络接口层的<strong>数据单元为以太网帧</strong>。</li><li><strong>MAC地址</strong>：网络层生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>在 IP 头部的前面加上 MAC 头部，并封装成<strong>数据帧（Data frame）</strong>发送到网络上。以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</li><li><strong>路由</strong>：<strong>物理机到物理机</strong>，网络硬件设备使用的网络物理地址，路途上每个区间的起点和终点</li></ul><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><p><strong>IP的作用</strong>：网络层主要作用是实现主机与主机之间的通信，IP 的作用是在复杂的网络环境中将数据包发送给目的主机。</p></li><li><p><strong>网络层 (IP) 与网络接口层 (MAC) 的区别</strong>：MAC 的作用是实现「直连」的两个设备之间通信， IP 负责在「没有直连」的两个网络之间通信。即 MAC 只负责某一个区间之间的通信传输，而 IP 负责将数据包发送给最终的目的地址，<strong>源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><img src="/./res\image-20220812082433369.png" alt="image-20220812082433369" style="zoom: 33%;"></li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><pre><code>    IP地址(IPv4)由32位二进制来表示，为了方便记忆采用点分十进制的表示方式，将 32 位 IP 地址以每 8 位为组，共分为 `4` 组，每组以「`.`」隔开，再将每组转换成十进制。所以IP地址最大值为 2^32 = 4294967296</code></pre><img src="/./res\image-20220812083108967.png" alt="image-20220812083108967" style="zoom: 33%;"><h4 id="分类地址"><a href="#分类地址" class="headerlink" title="分类地址"></a>分类地址</h4><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul><li><strong>定义：</strong>ARP协议是Address Resolution Protocol的缩写，翻译过来也就是地址解析协议，它是根据IP地址获取物理地址(MAC)的一个TCP&#x2F;IP协议</li><li><strong>原理</strong><ul><li>在源IP地址向目的IP地址发送数据时，IP数据报总是需要知道下一跳（物理上的下一个目的地）该去往何处。所以要先根据主机的路由表确定数据下一个路由器的IP地址，然后通过ARP协议获取对应的MAC地址，ARP协议是借助ARP请求和ARP响应来确定MAC地址的</li><li>首先主机会通过广播发送ARP请求，这个包中包含了想要知道MAC地址的主机IP地址，当同个链路中的所有设备收到 ARP 请求时，如果其目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机。</li><li>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</li></ul></li><li><strong>安全性</strong><ul><li><strong>ARP欺骗</strong>：ARP协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</li><li><strong>ARP泛洪攻击</strong>：如果攻击者发送大量伪造的 ARP 应答报文，造成主机 ARP 表项溢出，导致无法缓存正常的 ARP 表项，从而影响报文的正常转发，这就是大名鼎鼎的拒绝服务攻击（DDoS）或 ARP 泛洪攻击。会导致网络不稳定、断网、信息泄漏等</li><li><strong>解决方案：</strong>安装 ARP 防火墙或者自己手动绑定局域网 IP 和 MAC 的映射关系</li></ul></li></ul><h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><ul><li><p><strong>功能</strong>：ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。其功能就是<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p></li><li><p><strong>ICMP包头格式</strong>：ICMP报文是封装在IP包里面，它工作在网络层</p><img src="/D:/笔记/八股笔记.assets/image-20220812091906508.png" alt="image-20220812091906508" style="zoom: 50%;"></li><li><p><strong>ICMP类型</strong></p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li></ul></li><li><p><strong>查询报文类型</strong>：查询消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。通过向目标主机发送回送请求消息，然后接收目标主机发回来的回送应答消息，可以判断发送主机与目标主机之间可否可达。</p><ul><li><strong>标识符：</strong>用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li><strong>序号：</strong>序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li><li><strong>选项数据：</strong><code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短</li></ul></li><li><p><strong>差错报文类型</strong></p></li></ul><h4 id="PING工作原理"><a href="#PING工作原理" class="headerlink" title="PING工作原理"></a>PING工作原理</h4><pre><code>    ping本质上使用了ICMP的查询报文来判断发送主机与目标主机之间可否可达。以局域网内两个主机A(192.168.1.1)和B(192.168.1.2)为例，其发送和接收过程如下：</code></pre><ul><li>ping命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包，为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</li><li>由 ICMP 协议将这个<strong>数据包连同地址</strong> 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</li><li>通过ARP协议获取对应的MAC地址，由网络接口层构建成一个数据帧发送出去</li><li>目标主机接收到数据帧后，将 IP 数据包从帧中提取出来，交给本机的 IP 层。IP 层检查后，将有用的信息提取后交给 ICMP 协议。</li><li>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包再发送给主机 A。</li><li>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="头部格式"><a href="#头部格式" class="headerlink" title="头部格式"></a>头部格式</h4><img src="/./res\image-20230412140211742.png" style="zoom:50%;"><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><h5 id="1-三次握手详解"><a href="#1-三次握手详解" class="headerlink" title="1.  三次握手详解"></a>1.  三次握手详解</h5><img src="/./res\三次握手.png" style="zoom: 33%;"><ul><li><p>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</p></li><li><p><strong>第一次握手：</strong>客户端会随机初始化序列号 <code>client_isn</code>，将此序列号置于 TCP 首部的「<strong>序列号</strong>」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> <strong>同步</strong>报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</p></li><li><p><strong>第二次握手：</strong>服务端收到客户端的 <code>SYN</code> 报文后，服务端也会随机初始化自己的序列号 <code>server_isn</code> ，并将此序列号填入 TCP 首部的「<strong>序列号</strong>」字段中，其次把 TCP 首部的「<strong>确认应答号</strong>」字段填入 <code>client_isn + 1</code>，接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</p></li><li><p><strong>第三次握手：</strong>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</p></li><li><p>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</p></li></ul><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><blockquote><p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p></blockquote><h5 id="2-为什么是三次握手？"><a href="#2-为什么是三次握手？" class="headerlink" title="2. 为什么是三次握手？"></a>2. 为什么是三次握手？</h5><p>为什么选择三次：</p><ul><li>三次握手才可以<strong>阻止重复历史连接的初始化</strong>（主要原因）</li><li>三次握手才可以<strong>同步双方的初始序列号</strong></li><li>三次握手才可以避免资源浪费</li></ul><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><p><strong>避免历史连接</strong>——客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li></ul><p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p><p>服务端收到旧的SYN报文后就进入了<code>ESTABLISHED</code> 状态，说明此时服务端可以向客户端发送数据，直到客户端收到服务器回传的报文，发现这是个历史连接并中止此次连接。因此在两次握手的情况下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，并发送了无效数据。</p><p><strong>同步双方初始序列号</strong>——序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以<strong>去除重复</strong>的数据；</li><li>接收方可以根据数据包的序列号<strong>按序接收</strong>；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li></ul><p>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当<strong>服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应</strong>，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p><strong>避免资源浪费</strong></p><p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ；过了一段时间，客户端的<code>SYN</code> 请求到达了，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p><p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p><blockquote><p>很多人问，两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？</p><p>我这里两次握手是假设「由于没有第三次握手，<strong>服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认报文</strong>，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接」这个场景。</p><p>当然你要实现成类似三次握手那样，根据上下文丢弃 syn 历史报文也是可以的，两次握手没有具体的实现，怎么假设都行。</p></blockquote><p><strong>为什么不是四次呢？</strong></p><p>因为<strong>三次握手已经可以确认双方的发送接收能力正常</strong>，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p><ul><li><strong>第一次握手</strong>：服务端确认“自己收、客户端发”报文功能正常。</li><li><strong>第二次握手</strong>：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li><li><strong>第三次握手</strong>：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li></ul><h5 id="3-初始化的序列号"><a href="#3-初始化的序列号" class="headerlink" title="3. 初始化的序列号"></a>3. 初始化的序列号</h5><p><strong>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</strong></p><p>主要原因有两个方面：</p><ul><li><p><strong>为了防止历史报文被下一个相同四元组的连接接收</strong>（主要方面）；</p><ul><li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的<strong>连接就消失</strong>了，于是在收到客户端的数据包的时候就会发送 <strong>RST 报文</strong>。</li><li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li><li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li></ul><p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而<strong>很大程度</strong>上避免了历史报文</p></li><li><p>为了安全性，<strong>防止黑客伪造的相同序列号的 TCP 报文被对方接收</strong>；</p></li></ul><p><strong>初始序列号 ISN 是如何随机产生的？</strong></p><p>起始 <code>ISN</code> 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p><p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p><h5 id="4-握手丢失会怎么样？"><a href="#4-握手丢失会怎么样？" class="headerlink" title="4. 握手丢失会怎么样？"></a>4. 握手丢失会怎么样？</h5><p>重传机制</p><ol><li><p>第一次握手：<strong>重传 SYN 报文</strong>,<code>tcp_syn_retires</code> 的参数来限制第一次握手的重传次数，<strong>默认为5次</strong>。</p><blockquote><p>当客户端想发送 SYN 报文，然后进入到 <code>SYN_SENT</code> 状，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发<strong>「超时重传」</strong>机制，重传 SYN 报文。</p><p><strong>超时时间</strong>：</p><p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p><p><strong>重传次数</strong>：</p><blockquote><p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p></blockquote><p>在 Linux 里，客户端的 SYN 报文最大重传次数由 &#x3D;&#x3D;<code>tcp_syn_retries</code>&#x3D;&#x3D;内核参数控制，这个参数是可以自定义的，<strong>默认值一般是 5</strong>。</p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p><p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p></blockquote></li><li><p>第二次握手：<strong>客户端重传 SYN 报文</strong>，<strong>服务端重传 SYN-ACK 报文</strong>， tcp_synack_retires的参数来限制第二次握手（ack+syn包）的重传次数，<strong>默认为5次</strong>。</p><blockquote><p>当服务端收到客户端的第一次握手后，就会回 <code>SYN-ACK</code> 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p><blockquote><p> 第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 </p><ul><li>第二次握手里的 ACK， 是对第一次握手的确认报文</li><li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li></ul></blockquote><ul><li><p><strong>客户端重传 SYN 报文</strong></p><p>第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p></li><li><p><strong>服务端重传 SYN-ACK 报文</strong></p><p>因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p></li></ul></blockquote></li><li><p>第三次握手： <strong>服务端重传 SYN-ACK 报文</strong>，因为ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</p><blockquote><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p><ul><li><p><strong>服务端重传 SYN-ACK 报文</strong></p><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p></li></ul><p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p></blockquote></li></ol><p><strong>tcp_retries2</strong> :<strong>客户端发送了数据包</strong>，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到**重传次数超过 tcp_retries2 值（默认值 15 次）*<em>后，客户端就会*<em>断开 TCP 连接。</em></em></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h5 id="1-四次挥手详解"><a href="#1-四次挥手详解" class="headerlink" title="1. 四次挥手详解"></a>1. 四次挥手详解</h5><img src="/./res\四次挥手.png" style="zoom: 50%;"><ul><li><strong>第一次挥手</strong>：客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li><strong>第二次挥手</strong>：服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li><strong>第三次挥手</strong>：等待服务端处理完数据后，就会向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li><strong>第四次挥手</strong>：客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态。服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code>（最长报文段寿命） 后，也进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</li></ul><h5 id="2-为什么是四次挥手？"><a href="#2-为什么是四次挥手？" class="headerlink" title="2. 为什么是四次挥手？"></a>2. 为什么是四次挥手？</h5><p><strong>服务器在收到客户端的 FIN 报文段后，服务端可能还有数据需要处理和发送，</strong>所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p><h5 id="3-挥手丢失会怎么样？"><a href="#3-挥手丢失会怎么样？" class="headerlink" title="3. 挥手丢失会怎么样？"></a>3. 挥手丢失会怎么样？</h5><ol><li><p>第一次挥手：<strong>客户端重传 FIN 报文</strong></p><blockquote><p><strong>客户端重传 FIN 报文</strong>：</p><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。</p><p>如果第一次挥手丢失了，那么<strong>客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文</strong>，<strong>重发次数由 <code>tcp_orphan_retries</code> 参数控制</strong>。当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，直接进入到 <code>close</code> 状态。</p></blockquote></li><li><p>第二次挥手：<strong>客户端重传 FIN 报文</strong>：</p><blockquote><p><strong>客户端重传 FIN 报文</strong>：</p><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p><p>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果<strong>服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p></blockquote></li><li><p>第三次挥手：<strong>服务端重发 FIN 报文</strong>：</p><blockquote><p><strong>服务端重发 FIN 报文</strong>：</p><p>当服务端第二次挥手后处于 <code>CLOSE_WAIT</code> 状态，等待应用进程调用 close 函数关闭连接。</p><p>内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p><p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retrie</code>s 参数控制，这<strong>与客户端重发 FIN 报文的重传次数控制方式是一样的</strong>。</p></blockquote></li><li><p>第四次挥手：<strong>服务端重发 FIN 报文</strong>：</p><blockquote><p><strong>服务端重发 FIN 报文</strong>：</p><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p><p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p><p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p></blockquote></li></ol><p><strong>重发次数由 <code>tcp_orphan_retries</code> 参数控制</strong>，默认是7。sysctl_tcp_orphan_retries 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成)。</p><h5 id="4-TCP-关闭连接的方式和区别"><a href="#4-TCP-关闭连接的方式和区别" class="headerlink" title="4. TCP 关闭连接的方式和区别"></a>4. TCP 关闭连接的方式和区别</h5><p><a href="https://blog.csdn.net/qq_41950508/article/details/125829221?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125829221-blog-123183858.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125829221-blog-123183858.pc_relevant_aa&utm_relevant_index=2">【网络编程】双向的TCP如何关闭？close ？shutdown？_</a></p><p>客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p><ul><li>对于 <strong>close 函数</strong>关闭的连接，由于<strong>无法再发送和接收数据</strong>，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。这意味着对于调用 close 关闭的连接，如果<strong>在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭</strong>。</li><li>如果主动关闭方使用 <strong>shutdown 函数</strong>关闭连接，指定了<strong>只关闭发送方向，而接收方向并没有关闭</strong>，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么<strong>主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态</strong>（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）</li></ul><p><strong>close关闭的是读和写两个方向的传送，当一方完成了数据传送，但是另一方仍然有数据需要传送的时候，需要使用shutdown来达到半关闭的状态,使得对方的数据能够正确到达。</strong></p><h5 id="5-TIME-WAIT-状态"><a href="#5-TIME-WAIT-状态" class="headerlink" title="5.  TIME-WAIT 状态"></a>5.  TIME-WAIT 状态</h5><p>主动关闭方在收到被动关闭方的 FIN 报文并返回 ACK 后，会进入 TIME_WAIT 状态，TIME_WAIT 状态又称 2MSL 状态，MSL 指最大报文段生存时间，在网络传输中超过这个时间的报文段将被丢弃。在 TIME_WAIT 状态停留 2MSL 时间，可以保证旧连接的四元组（客户端 IP 地址、端口号、服务器 IP 地址、端口号）从网络中消失，防止历史连接中的数据被后面相同四元组的连接错误接收。</p><p><strong>为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</strong></p><p>TIME-WAIT (2MSL 状态) 存在主要有两个原因：</p><ul><li><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p><p>确保主动关闭方的最后的ACK可以达到对端。如果客户端直接CLOSED，然后又再向服务端发起一个新连接，假设新连接和已经关闭的老连接端口号是一样的，且前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达服务端，由于新连接和老连接的四元组是相同的，TCP协议会认为那些延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接需要TIME_WAIT状态且等待时间为2MSL，这样可以保证历史连接的所有数据都从网络中消失。</p></li><li><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong><br>第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超<br>时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN 报文，然后客户端重传一<br>次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</p></li></ul><p>为什么要等待2MSL：</p><ul><li>一个<code>MSL</code>是确保主动关闭方最后的<code>ACK</code>能够到达对端。</li><li>一个<code>MSL</code>是确保被动关闭方重发的<code>FIN</code>能够被主动关闭方收到。</li></ul><p><strong>TIME-WAIT 状态过多会产生什么后果？怎样处理？</strong></p><p>危害：</p><ul><li><p>从<strong>服务器</strong>来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，<strong>会占用系统资源</strong>，比如文件描述符、内存资源、CPU 资源、线程资源等，此时部分客户端就会显示连接不上。<strong>但并不会导致端口资源受限，因为服务端只监听一个端口</strong>，会占用系统资源。</p></li><li><p>从<strong>客户端</strong>来讲，客户端TIME_WAIT过多，就会导致<strong>端口资源被占用</strong>，因为端口就65536个，被占满就会导致无法创建新的连接。</p></li></ul><p>解决办法：</p><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><p>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</p><p><strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p><p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse <span class="operator">=</span> <span class="number">1</span> 表示开启重用。允许将<span class="type">TIME</span><span class="operator">-</span>WAIT sockets重新用于新的TCP连</span><br><span class="line">接，默认为<span class="number">0</span>，表示关闭；</span><br></pre></td></tr></table></figure><p><strong>说明：如果使用tcp_tw_reuse，请激活tcp_timestamps，否则无效。</strong>打开对 TCP 时间戳的支持，即</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=1（默认即为 1）</span><br></pre></td></tr></table></figure><p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p><blockquote><p><strong>net.ipv4.tcp_tw_recycle</strong></p><p>net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<br>0，表示关闭。</p><p>net.ipv4.tcp_tw_recycle &#x3D; 0 （不要开启，现在互联网NAT结构很多，可能直接无法三次握手）</p></blockquote><p><strong>方式二：net.ipv4.tcp_max_tw_buckets</strong></p><p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p><p><strong>方式三：程序中使用 SO_LINGER</strong></p><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">0</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么<strong>调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭</strong>。</p><p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><p>linger  英&#x2F; ˈlɪŋɡə(r) 缓慢消失</p><h4 id="连接故障"><a href="#连接故障" class="headerlink" title="连接故障"></a>连接故障</h4><h5 id="客户端出现故障"><a href="#客户端出现故障" class="headerlink" title="客户端出现故障"></a>客户端出现故障</h5><p>TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒发送一个探测报文段，若一连发送 9个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p><p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75  </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure><ul><li>tcp_keepalive_time&#x3D;7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制；</li><li>tcp_keepalive_intvl&#x3D;75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes&#x3D;9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p><img src="/./res\format,png" alt="img" style="zoom:50%;"><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，<strong>对端程序是正常工作的</strong>。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>第二种，<strong>对端程序崩溃并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li><li>第三种，<strong>是对端程序崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li></ul><h5 id="服务端进程崩溃"><a href="#服务端进程崩溃" class="headerlink" title="服务端进程崩溃"></a>服务端进程崩溃</h5><ol><li>我自己做了个实验，使用 kill -9 来模拟<strong>进程崩溃</strong>的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</li><li>服务器<strong>主机崩溃</strong><br>客户端在给服务器发送数据时，由于收不到服务器端回传的ACK确认报文，正常情况下，客户端TCP均会进行超时重传，<del>一般为重传12次大约9分钟后才放弃重传</del>，并关闭客户端TCP链接。</li><li>服务器<strong>主机崩溃后重启</strong><br>如果服务器主机在崩溃重启的这段时间里，客户端没有向服务器发送数据，即客户端没有因重传次数超过限制关闭TCP链接。则在服务器重启后，当客户端再向服务器发送TCP报文时，由于<strong>服务器中的TCP链接已经关闭，会直接向客户端回复RST报文</strong>，客户端在接收RST报文后关闭自己的TCP链接。</li></ol><h5 id="客户端拔掉网线"><a href="#客户端拔掉网线" class="headerlink" title="客户端拔掉网线"></a>客户端拔掉网线</h5><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。</p><p><strong>有数据传输</strong>的情况：</p><ul><li>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端<strong>重传次数没有达到最大值之前，客户端就插回了网线，</strong>那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。</li><li>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端<strong>重传次数达到了最大值时</strong>，<strong>服务端就会断开 TCP 连接</strong>。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 <strong>RST 报文</strong>，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。（<strong>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传</strong>。）</li></ul><p><strong>没有数据传输</strong>的情况：</p><ul><li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li><li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li></ul><p>除了客户端拔掉网线的场景，还有客户端「宕机和进程崩解」的两种场景。</p><ul><li><p><strong>客户端宕机：</strong>这件事跟拔掉网线是一样无法被服务端的感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p><p>所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</p></li><li><p><strong>客户端的进程崩解</strong>后，客户端的内核就会向服务端发送 FIN 报文，<strong>与服务端进行四次挥手</strong>。</p><p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p></li></ul><h4 id="TCP保证可靠传输"><a href="#TCP保证可靠传输" class="headerlink" title="TCP保证可靠传输"></a>TCP保证可靠传输</h4><p>TCP主要提供了检验和、序列号&#x2F;确认应答、超时重传、滑动窗口、拥塞控制、流量控制等方法实现可靠性传输。</p><ul><li><strong>序列号</strong>：序列号的作用不仅仅是应答，可以根据序列号对接收到的数据排序，并去掉序列号重复的数据。</li><li><strong>校验和</strong>：通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<strong>发送方</strong>：在发送数据之前计算校验和，并进行校验和的填充。<strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。</li><li><strong>滑动窗口</strong>：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</li><li><strong>超时重传</strong>：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</li><li><strong>拥塞控制</strong>：在数据传输过程中，如果因为网络状态造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</li><li><strong>流量控制</strong>：<strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止包丢失。</strong>如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，<br>若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效<br>率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的<br>数据量。流量控制与TCP协议报头中的窗口大小有关。<strong>TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</strong></li><li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。自动重传请求（Automatic Repeat-reQuest）</li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul><li><p><strong>提出背景</strong>：TCP 是每发送一个数据，都要进行一次确认应答。如果当上一个数据包收到了应答了， 再发送下一个，<strong>通信的效率比较低</strong>。</p></li><li><p><strong>窗口定义：</strong>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p></li><li><p><strong>窗口大小</strong>：窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。<strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong>通常窗口的大小是<strong>由接收方的窗口大小</strong>来决定的。</p></li><li><p><strong>累计确认（累计应答）：</strong>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p></li></ul><img src="/./res\15.jpg" alt="15" style="zoom:50%;"><h5 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h5><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><img src="/./res\19.jpg" alt="SND.WND、SND.UN、SND.NXT" style="zoom: 67%;"><ul><li><p><code>SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</p></li><li><p><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</p></li><li><p><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</p></li><li><p>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</p></li></ul><p>那么可用窗口大小的计算就可以是：</p><p><strong>可用窗口大 &#x3D; SND.WND -（SND.NXT - SND.UNA）</strong></p><h5 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h5><ul><li>#1 + #2 是<strong>已成功接收并确认</strong>的数据（等待应用进程读取）；</li><li>#3 是<strong>未收到数据但可以接收</strong>的数据；</li><li>#4 <strong>未收到数据并不可以接收</strong>的数据；</li></ul><img src="/D:/笔记/八股笔记.assets/20.jpg" alt="接收窗口" style="zoom: 67%;"><p>其中三个接收部分，使用两个指针进行划分:</p><ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li><li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><h6 id="接受窗大小≈发送窗大小"><a href="#接受窗大小≈发送窗大小" class="headerlink" title="接受窗大小≈发送窗大小"></a>接受窗大小≈发送窗大小</h6><p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p><p>因为滑动窗口并<strong>不是一成不变的</strong>。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>①<strong>定义</strong>：在发送数据时，<strong>设定一个定时器</strong>，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p><strong>②发生条件：</strong>TCP 会在以下两种情况<strong>发生超时重传</strong>：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p>③<strong>超时重传时间：</strong></p><p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><p><code>RTT</code>（Round-Trip Time 往返时延）：<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是<strong>报文的往返时间</strong>。</p><p>超时重传时间 <code>RTO</code> （Retransmission Timeout 超时重传时间）：</p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，降低了网络传输效率，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p><p>④<strong>超时重发的数据，再次超时</strong>：</p><p><strong>超时间隔加倍。</strong>也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔<strong>设为先前值的两倍</strong>。两次超时，就说明网络环境差，不宜频繁反复发送。</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p><strong>①定义</strong>：TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p><strong>②发生条件</strong>：<strong>发送方收到三个相同的ACK，就会触发重传机制。</strong></p><img src="/./res\10.jpg" alt="快速重传机制" style="zoom:50%;"><p><strong>③问题：</strong>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p><p>举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p><ul><li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。</li><li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</li></ul><p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p><h5 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h5><p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p><p><strong>定义：</strong>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）</p><h5 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h5><p>为了更好的反应网络情况，RFC 2883在SACK选项的基础上提出了D-SACK（即Duplicate SACK）</p><p><strong>定义：</strong>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul><li><p><strong>背景</strong>：发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p></li><li><p><strong>定义</strong>：<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，TCP 利用滑动窗口实现流量控制</strong>。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p></li></ul><h5 id="减少缓存和收缩窗口"><a href="#减少缓存和收缩窗口" class="headerlink" title="减少缓存和收缩窗口"></a>减少缓存和收缩窗口</h5><p><strong>TCP 不允许减少缓存的同时收缩窗口，而是先收缩窗口，过段时间再减少缓存，这样可以避免丢包</strong></p><h5 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h5><p>定义：<strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p><ul><li><strong>窗口关闭潜在的危险</strong>：</li></ul><p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致<strong>发送方一直等待接收方的非 0 窗口通知</strong>，<strong>接收方也一直等待发送方的数据</strong>，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p><ul><li><strong>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</strong></li></ul><p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <strong><code>RST</code> 报文</strong>来中断连接</p><h5 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h5><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p><p>我们的 <code>TCP + IP</code> 头有 <code>40</code> 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p><p>糊涂窗口综合症的现象是可以发生在发送方和接收方：</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送方可以发送小数据</li></ul><p>要<strong>解决</strong>糊涂窗口综合症，：</p><ul><li><p>让接收方不通告小窗口给发送方</p><p>当「窗口大小」小于 min( MSS，缓存空间&#x2F;2 ) ，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 &gt;&#x3D; MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p></li><li><p>让发送方避免发送小数据</p><p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才能可以发送数据：</p><ul><li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 和 数据大小 &gt;&#x3D; <code>MSS</code>；</li><li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li></ul></li></ul><p><strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul><li><strong>背景</strong>：流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</li><li><strong>定义</strong>：避免「发送方」的数据填满整个网络。<strong>TCP 发送方</strong>会维持一个 <strong>拥塞窗口(cwnd)<strong>的状态变量，它会根据</strong>网络的拥塞程度动态变化</strong>的。加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</li></ul><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，那么就由小到大逐渐增大拥塞窗口，</p><p>cwnd 初始值为 1，<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1，</strong>每经过一个传播轮次就加倍，<strong>指数增长</strong>。同时有一个<strong>慢启动门限 <code>ssthresh</code></strong> （slow start threshold）状态变量，当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法；当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」</p><img src="/./res\27.jpg" alt="27" style="zoom: 50%;"><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，每经过一个往返时间 RTT 就把发送方的cwnd 加 1。可以发现拥塞避免算法就是将原本慢启动算法的指数增长变成了<strong>线性增长</strong>，还是增长阶段，但是增长速度缓慢了一些。</p><img src="/./res\28.jpg" alt="28" style="zoom:50%;"><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：<strong>超时重传</strong>和<strong>快速重传</strong>。这两种使用的算法是不同的：</p><ul><li><strong>超时重传</strong>：<code>ssthresh</code> 设为 <code>cwnd/2</code>，<code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）。慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，<strong>会造成网络卡顿</strong>。</li></ul><img src="/./res\29.jpg" alt="29" style="zoom:50%;"><ul><li><p><strong>快速重传</strong>：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分， <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：<code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;<code>ssthresh = cwnd</code>，并进入快速恢复算法</p></li></ul><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>快速重传和快速恢复算法一般同时使用，快速恢复算法认为还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><img src="/./res\拥塞发生-快速重传.drawio.png" alt="拥塞发生-快速重传.drawio" style="zoom:50%;"><h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称 SYN 队列；服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK；</li><li>全连接队列，也称 Accept 队列；服务端收到第三次握手的 ACK 后，<strong>内核会把半连接队列中的连接移除，并创建新的全连接添加到 accept 队列中，然后等待进程调用 accept 函数时把连接取出来。</strong></li></ul><p>半连接队列和全连接队列都有最大长度限制，超过限制时内核会直接丢弃，<strong>或返回 RST 包</strong>。</p><img src="/./res\3.jpg" alt="半连接队列与全连接队列" style="zoom: 33%;"><h5 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h5><h6 id="队列大小"><a href="#队列大小" class="headerlink" title="队列大小"></a>队列大小</h6><p><strong>①TCP 全连接队列的最大值sk_max_ack_backlog 取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong></p><ul><li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li><li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li></ul><p><strong>②怎么查看全连接队列大小</strong></p><p>在服务端可以使用 <code>ss</code> 命令，来查看 TCP 全连接队列的情况：</p><p>Recv-Q 表示 <strong>receive queue 中的 bytes 数量</strong>；Send-Q 表示 send queue 中的 bytes 数值。</p><ul><li><p>在「LISTEN 状态」时</p><ul><li>Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接</li><li>Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务，最大全连接长度为 128</li></ul></li><li><p>「非 LISTEN 状态」时</p><ul><li>Recv-Q：已收到但未被应用进程读取的字节数；</li><li>Send-Q：已发送但未收到确认的字节数；</li></ul></li></ul><h6 id="队列已满的回应策略"><a href="#队列已满的回应策略" class="headerlink" title="队列已满的回应策略"></a>队列已满的回应策略</h6><p><strong>tcp_abort_on_overflow</strong> 共有两个值分别是 0 和 1，其分别表示：</p><ul><li><p>0(默认) ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；</p></li><li><p>1 ：如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接；</p></li><li><p>tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。</p><p>当 TCP 全连接队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次<strong>重发</strong>。如果服务器上的进程只是<strong>短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。</strong></p></li><li><p>如果要想知道<strong>客户端连接不上服务端</strong>，<strong>是不是服务端 TCP 全连接队列满的原因</strong>：</p><p>那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 <code>connection reset by peer</code> 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。</p></li></ul><h5 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h5><p><strong>①半连接队列大小</strong></p><h6 id="队列大小-1"><a href="#队列大小-1" class="headerlink" title="队列大小"></a>队列大小</h6><p>服务端处于 <code>SYN_RECV</code> 状态的 TCP 连接，就是 TCP 半连接队列。</p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt;&#x3D; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li></ul><p>max_qlen_log 是<strong>理论</strong>半连接队列最大值，并不一定代表服务端处于 SYN_REVC 状态的最大个数。</p><p><strong>②如何查看半连接队列长度？</strong></p><img src="/./res\21.jpg" alt="img" style="zoom: 33%;"><p>wc -l   显示行数。</p><p>netstat：显示网络状态</p><h6 id="TCP-第一次握手（收到-SYN-包）时会被丢弃的三种条件"><a href="#TCP-第一次握手（收到-SYN-包）时会被丢弃的三种条件" class="headerlink" title="TCP 第一次握手（收到 SYN 包）时会被丢弃的三种条件"></a>TCP 第一次握手（收到 SYN 包）时会被丢弃的三种条件</h6><ol><li><strong>如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；</strong></li><li><strong>若全连接队列满了，<del>且没有重传 SYN+ACK 包的连接请求多于 1 个</del>，则会丢弃；</strong></li><li><strong>如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)，则会丢弃；</strong></li></ol><p>假设条件 1 当前半连接队列的长度 「没有超过」理论的半连接队列最大值 max_qlen_log，那么如果条件 3 成立，则依然会丢弃 SYN 包，也就会使得服务端处于 SYN_REVC 状态的最大个数不会是理论值 max_qlen_log。</p><h6 id="syncookies"><a href="#syncookies" class="headerlink" title="syncookies"></a>syncookies</h6><ul><li><p><strong>如果 SYN 半连接队列已满，只能丢弃连接吗？</strong></p><p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</p></li><li><p><strong>实现：</strong>服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p></li></ul><img src="/./res\39.jpg" alt="开启 syncookies 功能" style="zoom:50%;"><p>syncookies 参数主要有以下三个值：</p><ul><li>0 值，表示关闭该功能；</li><li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li><li>2 值，表示无条件开启功能；</li></ul><p>那么在应对 SYN 攻击时，只需要设置为 1 即可：</p><img src="/./res\40.jpg" alt="img" style="zoom: 33%;"><h5 id="syn洪泛攻击"><a href="#syn洪泛攻击" class="headerlink" title="syn洪泛攻击"></a>syn洪泛攻击</h5><p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><ul><li>在三次握手过程中，服务器发送<code>[SYN/ACK]</code>包（第二个包）之后、收到客户端的 <code>[ACK] </code>包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV （等待客户端响应）状态。如果接收到客户端的<code> [ACK]</code> ，则 TCP 连接成功，如果未接受到，则会不断重发请求直至成功。</li><li>SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复<code>[SYN/ACK]</code>包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li><li>这些伪造的 <code>[SYN] </code>包将长时间占用半连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li></ul><p><strong>检测：</strong>当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次SYN 攻击。</p><h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><ul><li>通过防火墙、路由器等过滤网关防护。</li><li>增大半连接队列；</li><li>开启 tcp_syncookies 功能</li><li>减少 SYN+ACK 重传次数</li></ul><h6 id="增大半连接队列"><a href="#增大半连接队列" class="headerlink" title="增大半连接队列"></a>增大半连接队列</h6><p><strong>要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列</strong>。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</p><blockquote><h5 id="半连接队列大小"><a href="#半连接队列大小" class="headerlink" title="半连接队列大小"></a>半连接队列大小</h5><p>服务端处于 <code>SYN_RECV</code> 状态的 TCP 连接，就是 TCP 半连接队列。</p><ul><li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li><li>当 max_syn_backlog &lt;&#x3D; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li></ul><p>TCP 全连接队列的最大值sk_max_ack_backlog是 min(somaxconn, backlog)**</p><ul><li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li><li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li></ul></blockquote><p>增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：</p><img src="/./res\41.jpg" alt="img" style="zoom: 25%;"><p>增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：</p><img src="/./res\42.jpg" alt="img" style="zoom: 25%;"><p>最后，改变了如上这些参数后，要重启 Nginx 服务，因为半连接队列和全连接队列都是在 listen() 初始化的。</p><h6 id="开启-tcp-syncookies-功能"><a href="#开启-tcp-syncookies-功能" class="headerlink" title="开启 tcp_syncookies 功能"></a>开启 tcp_syncookies 功能</h6><p>如果不断受到 SYN 攻击，就会导致 SYN 队列（半连接队列）被占满，从而导致无法在建立新的连接。</p><p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure><ul><li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li></ul><img src="/./res\43.jpg" alt="img" style="zoom: 25%;"><h6 id="减少-SYN-ACK-重传次数"><a href="#减少-SYN-ACK-重传次数" class="headerlink" title="减少 SYN+ACK 重传次数"></a>减少 SYN+ACK 重传次数</h6><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</p><img src="/./res\44.jpg" alt="img" style="zoom:25%;"><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><h5 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h5><h6 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a><strong>客户端优化</strong></h6><p>根据网络的稳定性和目标服务器的繁忙程度<strong>修改 SYN 的重传次数</strong>，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</p><ul><li><p>客户端作为主动发起连接方，首先它将发送 SYN 包，于是客户端的连接就会处于 <code>SYN_SENT</code> 状态。如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，默认是 5 次：</p></li><li><p>第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后……。<strong>每次超时的时间是上一次的 2 倍</strong>。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手。所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p></li></ul><h6 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h6><p>见上面SYN洪泛攻击、全连接异常、半连接</p><h6 id="绕过三次握手"><a href="#绕过三次握手" class="headerlink" title="绕过三次握手"></a>绕过三次握手</h6><p><strong>问题</strong>：三次握手建立连接造成的后果就是，HTTP 请求必须在<strong>一个 RTT</strong>（从客户端到服务器一个往返的时间）后才能发送。</p><p><strong>解决</strong>：在 Linux 3.7 内核版本之后，提供了 <strong>TCP Fast Open</strong> 功能，这个功能可以减少 TCP 连接建立的时延。</p><p><strong>工作原理：</strong></p><ul><li><p>在客户端<strong>首次建立连接时</strong>的过程：</p><ol><li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li><li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li><li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li></ol><p>第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。</p></li><li><p>客户端<strong>再次向服务器建立连接</strong>时的过程：</p><ol><li>客户端发送 SYN 报文，该报文包含<strong>「数据」</strong>（对于非 TFO 的普通 TCP 握手过程，SYN 报文中不包含「数据」）以及此前记录的 <strong>Cookie</strong>；</li><li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：<ul><li>如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；</li><li>如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li></ul></li><li>如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，<strong>这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li><li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；</li><li>此后的 TCP 连接的数据传输过程和非 TFO 的正常情况一致。</li></ol></li></ul><img src="/./res\22.jpg" alt="开启 TCP Fast Open 功能" style="zoom:50%;"><h5 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h5><h6 id="主动方优化"><a href="#主动方优化" class="headerlink" title="主动方优化"></a>主动方优化</h6><p>①关闭连接</p><p><strong>关闭连接的方式通常有两种</strong></p><ul><li><strong>RST 报文关闭：</strong>如果进程收到 RST 报文，就直接关闭连接了，不需要走四次挥手流程，是一个暴力关闭连接的方式。</li><li><strong>FIN 报文关闭：</strong>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）</li></ul><p> <strong>close 函数和 shutdown 函数有什么区别？</strong></p><ul><li><p>调用了 close 函数意味着完全断开连接，<strong>完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。</strong></p></li><li><p>使用 close 函数关闭连接是不优雅的。于是，就出现了一种优雅关闭连接的 <code>shutdown</code> 函数，<strong>它可以控制只关闭一个方向的连接</strong>：</p></li></ul><p><strong><code>shutdown</code> 函数：</strong></p><img src="/./res\26.jpg" alt="img" style="zoom:67%;"><p>第二个参数决定断开连接的方式，主要有以下三种方式：</p><ul><li>SHUT_RD(0)：<strong>关闭连接的「读」这个方向</strong>，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。</li><li>SHUT_WR(1)：<strong>关闭连接的「写」这个方向</strong>，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端。</li><li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，<strong>关闭套接字的读和写两个方向</strong>。</li></ul><p><strong>②FIN_WAIT1 状态的优化</strong></p><p><strong>内核会定时重发 FIN 报文，其中重发次数由 tcp_orphan_retries 参数控制</strong></p><h6 id="被动方优化"><a href="#被动方优化" class="headerlink" title="被动方优化"></a>被动方优化</h6><h4 id="连接个数"><a href="#连接个数" class="headerlink" title="连接个数"></a>连接个数</h4><p>源地址和<strong>目的地址的字段（32位）</strong>是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和<strong>目的端口的字段（16位）</strong>是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><blockquote><p>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</p></blockquote><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:</p><img src="/./res\image-20220810182852935.png" alt="image-20220810182852935" style="zoom: 67%;"><p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p><h4 id="RST报文段"><a href="#RST报文段" class="headerlink" title="RST报文段"></a>RST报文段</h4><p>RST即复位字段。</p><p><strong>出现RST包的情况：</strong></p><ul><li><p>连接请求到达时，目的端口不存在。</p></li><li><p>向一个已经关闭的连接发送数据。</p></li><li><p>向一个已经崩溃的对端发送数据。</p></li><li><p>TCP收到了一个历史连接上的报文。超时。 接收端在接收数据超时时，会发送RST包。</p></li><li><p>关闭socket时，直接丢弃接收缓冲区未读取的数据，并给对方发一个RST。</p></li><li><p>处理半打开连接时。一方关闭了连接，另一方却由于网络故障等原因没有收到结束报文，还维持着原来的连接，这种状态就叫做半打开连接。此时另一方往处于半打开状态的连接写数据的话，对方就会回应RST。</p></li></ul><h4 id="MSS最大报文长度"><a href="#MSS最大报文长度" class="headerlink" title="MSS最大报文长度"></a>MSS最大报文长度</h4><ul><li><code>MTU</code>：（maximum transmission unit）<strong>最大传输单元</strong>，一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：（Maximum segment size）<strong>最大报文长度</strong>，除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p><strong>IP层分片：如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p><p><strong>TCP层MSS</strong>：如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片。</p><p>达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p><p>![握手阶段协商 MSS](.\res\握手阶段协商 MSS.png)</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="UDP实现可靠传输"><a href="#UDP实现可靠传输" class="headerlink" title="UDP实现可靠传输"></a>UDP实现可靠传输</h4><p><a href="https://www.jianshu.com/p/6c73a4585eba">UDP如何实现可靠传输 </a></p><p><a href="https://blog.csdn.net/qq_38731735/article/details/121444828">UDP如何实现可靠传输</a></p><p>基于应用层的可靠传输，udp可靠设计需要根据具体的使用场景。</p><p>（1）丢包 ——–负荷、信号  —&gt; 重传 应答</p><p>（2）乱序  —————————&gt;  重排   加上序号</p><ul><li>一个是<strong>重传机制</strong>，丢包需要进行重传，可以添加 seq&#x2F;ack 机制，确保数据发送到对端的方式；</li><li>第二是<strong>重排机制</strong>，我们在收到乱序数据一定需要增加一个缓冲区进行数据重排；</li><li>第三是<strong>超时机制</strong>，长时间没收收到对方的回复需要进行重试；</li><li>第四，流量控制，在局域网内一般是不考虑这部分，实现起来比较复杂，收益不是那么大。</li></ul><h5 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协议设计：</span><br><span class="line">|同步字|总字节大小|分片数|分片编号|载荷大小|预留|荷载|</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct packet</span><br><span class="line">&#123;</span><br><span class="line">    int recv_pieces;//当前已经接收的数量；</span><br><span class="line">    int total_size; //总数据大小</span><br><span class="line">    int left; //最后一片大小</span><br><span class="line">    int paiece_size; //分片大小</span><br><span class="line">    int recv_len;  //接收数据长度</span><br><span class="line">    uint8_t *recv_buf;//保存接收数据</span><br><span class="line">    uint8_t * send_pt; //指向发送数据buffer</span><br><span class="line">   uint8_t piece_buf[PIECE_FIX_SIZE+HEAD_SIZE+1] ;//单帧的buf</span><br><span class="line">   circular_buffer_t *circular_buffer; //环形缓存</span><br><span class="line">&#125;packet;</span><br></pre></td></tr></table></figure><h4 id="最大传输长度"><a href="#最大传输长度" class="headerlink" title="最大传输长度"></a>最大传输长度</h4><p><a href="https://blog.csdn.net/luojian5900339/article/details/78472137">https://blog.csdn.net/luojian5900339/article/details/78472137</a></p><p>■ MTU：以太网（Ethernet）数据帧的长度必须在46-1500字节之间，这是由以太网 的物理特性决定的。这个1500字节被称为链路层的<strong>MTU（最大传输单元）</strong>。<code>MTU</code>：（maximum transmission unit）<strong>最大传输单元</strong></p><p>■单个UDP传输的最大内容1472（1500-20-8，如果有可选字节＞28）字节，但由于 不同的网络中转设备设置的MTU值并不相同。Internet上的标准MTU值为576 字节，建议在进行Internet的UDP编程时.最好将UDP的数据长度控件在548字节(576-8-20)以内.</p><p>ip报头 20字节 UDP报头 8字节</p><img src="/./res\image-20220815150754894.png" alt="  " style="zoom: 50%;"><p><strong>当我们发送的UDP数据大于1472的时候会怎样呢？</strong></p><p>这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要**分片(fragmentation).**把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,<strong>当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报</strong>。</p><h4 id="UDP编程问题"><a href="#UDP编程问题" class="headerlink" title="UDP编程问题"></a>UDP编程问题</h4><ul><li><strong>UDP乱序问题：</strong>一般采用接收缓冲区进行排序</li><li><strong>发送包大小：</strong>sendto一次发送1400字节，需要小于最小的MTU，以太网数据帧一般是1500字节<br>经验值：1400 （实时通讯）500（游戏）主要是包比较小有一定的优先权</li><li><strong>接收数据</strong><ul><li>recvfrom一次需要完整读取报文</li><li>udp一次只能收一个包，没有边界问题（报文传输）</li><li>tcp一次可以收一部分数据，有粘包问题（流式传输）</li></ul></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h4><p>​<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong></p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><img src="/./res\image-20220510171751577.png" alt="image-20220510171751577" style="zoom:50%;"><h5 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h5><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态。</p><h5 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h5><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求。</p><ul><li><strong>[200 OK]</strong>:表示一切正常，如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li><strong>[204 No Content]</strong>:与 200 OK 基本相同，但响应头没有 body 数据。</li><li><strong>[206 Partial Content]</strong>:应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><h5 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h5><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong></p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓存文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><h5 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h5><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><h5 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h5><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h4 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h4><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>Host字段在客户端发送请求时，用来指定服务器的域名</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p><code>Connection</code> 字段用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。这样就在客户端和服务器端建立起了一个可以复用的TCP连接，直到客户端或服务器主动关闭连接。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure><h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p><code>Accept</code> 字段声明客户端可以接受哪些数据格式。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*//表明客户端可以接受任何形式的数据</span><br></pre></td></tr></table></figure><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p><code>Accept-Encoding</code> 字段说明客户端可以接受哪些压缩方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br></pre></td></tr></table></figure><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p><code>Content-Type</code> 字段用于服务器回应时，指明本次数据的格式。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8//服务器回传数据的格式为网页，字符编码为utf-8</span><br></pre></td></tr></table></figure><h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><p><code>Content-Encoding</code> 字段表示服务器返回的数据使用了什么压缩格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip//服务器返回的数据采用了gzip方式压缩，告知客户端需要用此方式解压</span><br></pre></td></tr></table></figure><h4 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h4><ul><li><p>PUT：上传文件，向服务器添加数据，可以看作增</p></li><li><p>DELETE：删除文件</p></li><li><p>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</p></li><li><p>GET：获取资源，查询服务器资源</p></li></ul><h5 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h5><ul><li><p><strong>GET</strong></p><ul><li>GET请求是从服务器获取指定的资源，如文本、页面和图片等</li><li>GET请求的参数是写在URL中的，由于URL只支持ASCII，所以GET请求的参数只允许使用ASCII，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</li></ul></li><li><p><strong>POST</strong></p><ul><li>POST请求是根据报文中的body内容对指定的资源进行处理(如修改或提交数据)，具体的处理方式视资源类型而不同</li><li>POST 请求携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</li></ul></li><li><p><strong>安全与幂等</strong></p><ul><li><p><strong>安全</strong>是指请求方法不会<strong>破坏</strong>服务器上的资源</p></li><li><p><strong>幂等</strong>是指多次执行相同的操作，结果都是<strong>相同</strong>的。</p></li></ul></li><li><p><strong>GET方法是安全和幂等的</strong>：GET方法是<strong>只读</strong>操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p></li><li><p><strong>POST方法是不安全和不幂等的</strong>：POST方法是<strong>新增或提交数据</strong>的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p></li></ul><h4 id="HTTP长连接和短连接"><a href="#HTTP长连接和短连接" class="headerlink" title="HTTP长连接和短连接"></a>HTTP长连接和短连接</h4><ul><li><strong>在HTTP&#x2F;1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</strong>。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话</li><li>从 <strong>HTTP&#x2F;1.1</strong>起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： Connection:keep-alive。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</li><li><strong>HTTP</strong> 协议的长连接和短连接，实质上是 <strong>TCP</strong> 协议的长连接和短连接。</li></ul><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><ul><li><p><strong>请求报文</strong></p><ol><li>请求行(请求方法+URI协议+版本)</li><li>请求头</li><li>空行</li><li>请求主体</li></ol><img src="/./res\image-20220811160939535.png" alt="image-20220811160939535" style="zoom:50%;"></li><li><p><strong>响应报文</strong></p><ul><li>状态行(版本+状态码+原因短语)</li><li>响应首部</li><li>空行</li><li>响应主体</li></ul><img src="/./res\image-20220811161041748.png" alt="image-20220811161041748" style="zoom:50%;"></li></ul><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><h4 id="为什么要使用HTTP缓存"><a href="#为什么要使用HTTP缓存" class="headerlink" title="为什么要使用HTTP缓存"></a>为什么要使用HTTP缓存</h4><p>​对于一些具有重复性的 HTTP 请求，如果每次请求得到的数据都一样的，就可以把<strong>请求-响应</strong>的数据都<strong>缓存在本地</strong>，下次就直接读取本地的数据，能大大提升HTTP的性能。避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动权在浏览器 。</p><img src="/./res\image-20220511155626000.png" alt="image-20220511155626000" style="zoom:50%;"><p>其中from disk cache就表明使用了强制缓存</p><p>相关HTTP字段</p><p>强制缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间；</li><li><code>Expires</code>，是一个绝对时间；</li></ul><p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>实现流程</p><ul><li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</p></li><li><p>浏览器再次请求访问服务器中的该资源时，会<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小来判断该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</p></li><li><p>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p></li></ul><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是浏览器与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p><img src="/./res\image-20220511164352086.png" alt="image-20220511164352086" style="zoom:50%;"><p>如上图所示，当浏览器要访问的资源存在于缓存中，但是过期了，浏览器会向服务器发起请求来请求该过期资源，服务器端收到请求后判断该过期的缓存资源是否发生了修改，如果发生修改说明该缓存资源不可用，返回 200 状态码和修改后的新资源；如果未发生修改说明该过期的缓存资源仍可用，返回 304 状态码，浏览器收到 304 后就继续使用该过期的缓存资源。</p><p>实现流程</p><p>通过<code>If-Modified-Since</code> 字段和<code>Last-Modified</code> 字段实现</p><ul><li>浏览器第一次访问某个资源时，服务器的响应头部中会带上<code>Last-Modified</code> 字段，表示该资源的最后修改时间。</li><li>当浏览器第二次访问该资源，且该资源在缓存中过期时，浏览器在向服务器发送HTTP请求时，会在<code>If-Modified-Since</code> 字段上带上Last-Modified 的时间。</li><li>服务器收到请求后发现有 If-Modified-Since 字段，则与服务器中被请求资源的最后修改时间进行对比，如果最后修改时间较大，说明资源又被改过，则返回最新资源和HTTP 200 OK；如果最后修改时间较小，说明资源无新修改，返回HTTP 304，则浏览器直接使用缓存中的数据。</li></ul><p>通过<code>If-None-Match</code> 字段和<code>ETag</code> 字段实现</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的。</li><li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识。</li><li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较，<strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识。</li><li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li></ul><img src="/./res\image-20220511170730679.png" alt="image-20220511170730679" style="zoom:50%;"><img src="/./res\QQ截图20230510135655.png" style="zoom: 67%;"><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul><li><p><strong>新方法</strong>：<strong>PUT</strong>、DELETE、<strong>OPTIONS</strong>、<strong>PATCH</strong>等方法</p></li><li><p><strong>长连接</strong>：HTTP 1.1支持长连接（Persistent Connection），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启 Connection： keep-alive ，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li><li><p><strong>管道机制</strong>：它指的是在一个TCP连接内，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容（返回还是要顺序，已经没人用了）。</p></li><li><p><strong>并发连接</strong>：一个域名的请求允许分配多个长连接（缓解队头阻塞问题）</p></li><li><p><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的Cache-Control,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略(If-Modified-Since，<strong>If-None-Match</strong>)。</p></li><li><p><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持<strong>断点续传</strong>功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个<strong>错误状态响应码</strong>，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><strong>新的二进制格式</strong>：<strong>HTTP1.1的解析是基于文本</strong>。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑<strong>HTTP2.0的协议解析决定采用二进制格式</strong>，实现方便且健壮。</li><li><strong>多路复用</strong>：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>头部压缩</strong>：HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</li><li><strong>数据流</strong>：由于HTTP&#x2F;2版本的数据包不是按照顺序发送的，同一个TCP连接里面相连的两个数据包可能是属于不同的响应，因此，必须要有一种方法来区分每一个数据包属于哪个响应。HTTP&#x2F;2版本中，每个请求或者响应的所有数据包，称为一个数据流（stream），并且每一个数据流都有一个唯一的编号ID，请求数据流的编号ID为奇数，响应数据流的编号ID为偶数。每个数据包在发送的时候带上对应数据流的编号ID，这样服务器和客户端就能分区是属于哪一个数据流。最后，客户端还能指定数据流的优先级，优先级越高，服务器会越快做出响应。</li></ul><h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>HTTP&#x2F;3 现在还没正式推出，不过自 2017 年起， HTTP&#x2F;3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。</p><h4 id="HTTP-2不足"><a href="#HTTP-2不足" class="headerlink" title="HTTP&#x2F;2不足"></a><strong>HTTP&#x2F;2不足</strong></h4><p>HTTP&#x2F;2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP&#x2F;1.1 的性能，而美中不足的是 HTTP&#x2F;2 协议是基于 TCP 实现的，于是存在的<strong>缺陷有三个</strong>。</p><ul><li><strong>队头阻塞</strong>，HTTP&#x2F;2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；</li><li><strong>TCP 和 TLS 握手时延</strong>，TCP 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li><li><strong>连接迁移需要重新连接</strong>，移动设备从 4G 网络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li></ul><p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP&#x2F;2 在怎么设计都无法逃脱。要解决这个问题，就必须把<strong>传输层协议替换成 UDP</strong>，这个大胆的决定，HTTP&#x2F;3 做了！</p><h5 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a><strong>队头阻塞</strong></h5><p>HTTP&#x2F;2 <strong>多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</strong></p><p>因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</p><p>比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 和 Stream 4 请求。</p><img src=".\res\http2阻塞.jpeg" alt="img" style="zoom: 50%;"><h5 id="TCP-与-TLS-的握手时延迟"><a href="#TCP-与-TLS-的握手时延迟" class="headerlink" title="TCP 与 TLS 的握手时延迟"></a><strong>TCP 与 TLS 的握手时延迟</strong></h5><p>发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。</p><p>另外， TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生”减速”效果。</p><img src="/./res\TCP+TLS.gif" alt="img" style="zoom: 67%;"><h5 id="网络迁移需要重新连接"><a href="#网络迁移需要重新连接" class="headerlink" title="网络迁移需要重新连接"></a><strong>网络迁移需要重新连接</strong></h5><p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</p><img src="/./res\27-HTTP3.png" alt="HTTP/1 ~ HTTP/3" style="zoom:80%;"><h4 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h4><blockquote><p> 我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。</p></blockquote><p><strong>HTTP&#x2F;3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。</strong>它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p><p>QUIC 协议的<strong>特点</strong>：</p><ul><li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；</li><li><strong>建立连接速度快</strong>，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li><li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li></ul><h5 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h5><ul><li><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与<strong>多路复用</strong>的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p></li><li><p>由于 QUIC 使用的<strong>传输协议是 UDP</strong>，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</p></li><li><p>不过 QUIC 协议<strong>会保证数据包的可靠性</strong>，每个数据包都有<strong>一个序号唯一标识</strong>。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP&#x2F;3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP&#x2F;3。<strong>而其他流的数据报文只要被完整接收，HTTP&#x2F;3 就可以读取到数据</strong>。这与 HTTP&#x2F;2 不同，<strong>HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</strong></p></li></ul><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><img src="/./res\quic无阻塞.jpeg" alt="img" style="zoom: 50%;"><h5 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h5><ul><li>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</li><li>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程<strong>只需要 1 RTT</strong>，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</li><li>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</li></ul><h5 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h5><ul><li>在前面我们提到，<strong>基于 TCP 传输协议的 HTTP 协议</strong>，由于是通过<strong>四元组</strong>（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的<strong>迁移成本是很高的</strong>。</li><li>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</li></ul><h4 id="HTTP3-协议"><a href="#HTTP3-协议" class="headerlink" title="HTTP3 协议"></a>HTTP3 协议</h4><ul><li><p>HTTP&#x2F;3 同 HTTP&#x2F;2 一样采用二进制帧的结构，不同的地方在于 HTTP&#x2F;2 的二进制帧里需要定义 Stream，而 HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP&#x2F;3 的帧的结构也变简单了。</p></li><li><p>HTTP&#x2F;3 帧头只有两个字段：<strong>类型和长度</strong>。根据帧类型的不同，大体上分为<strong>数据帧</strong>和<strong>控制帧</strong>两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p></li></ul><p><img src="/.%5Cres%5Chttp3frame.png" alt="img"></p><ul><li><strong>HTTP&#x2F;3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP&#x2F;2 的 HPACK 队头阻塞问题。</strong>HTTP&#x2F;3 在头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP&#x2F;2 中的 HPACK 编码方式相似，HTTP&#x2F;3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。<ul><li>对于静态表的变化，HTTP&#x2F;2 中的 HPACK 的静态表只有 61 项，而 HTTP&#x2F;3 中的 QPACK 的静态表扩大到 91 项。</li><li>HTTP&#x2F;2 和 HTTP&#x2F;3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</li><li>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</li></ul></li></ul><p><strong>HTTP&#x2F;3 的 QPACK 解决了这一问题，那它是如何解决的呢？</strong></p><p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p><ul><li>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li><li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li></ul><p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTP-1-1的优缺点"><a href="#HTTP-1-1的优缺点" class="headerlink" title="HTTP&#x2F;1.1的优缺点"></a>HTTP&#x2F;1.1的优缺点</h4><ul><li><strong>优点</strong><ul><li><strong>简单</strong>：HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong></li><li><strong>灵活和易于扩展</strong>：HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong></li><li><strong>应用广泛和跨平台</strong></li></ul></li><li><strong>缺点</strong>：<strong>不安全</strong><ul><li><strong>窃听风险</strong>：通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li><li><strong>冒充风险</strong>：不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li><li><strong>篡改风险</strong>：无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li></ul></li><li><strong>双刃剑</strong><ul><li><strong>无状态</strong><ul><li><p>优点：服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担</p></li><li><p>缺点：服务器没有记忆能力，在完成有关联性的操作时会非常麻烦。（如身份认证）</p></li><li><p>解决方案：Cookie、Session</p></li></ul></li><li><strong>明文传输</strong><ul><li>优点：通过浏览器控制台或抓包工具可以直接查看传输的信息，便于调试</li><li>缺点：HTTP传输的信息容易被窃取</li></ul></li></ul></li></ul><h4 id="HTTPS的优缺点"><a href="#HTTPS的优缺点" class="headerlink" title="HTTPS的优缺点"></a>HTTPS的优缺点</h4><ul><li><p><strong>优点</strong>：<strong>安全性</strong></p><ul><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li></ul></li><li><p><strong>缺点：</strong></p><ul><li><p>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</p></li><li><p>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</p></li><li><p>在现有的证书机制下，中间人攻击依然有可能发生。</p></li><li><p>HTTPS 需要更多的服务器资源，也会导致成本的升高。</p></li></ul></li></ul><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul><li>HTTP 的端口号是 <strong>80</strong>，HTTPS 的端口号是 <strong>443</strong>。</li><li>HTTP 是明文传输，存在安全风险；HTTPS 是加密传输，在TCP和HTTP之间加入了<strong>SSL&#x2F;TLS安全协议</strong></li><li>HTTP在TCP三次握手之后便可进行HTTP的报文传输，而HTTPS在TCP三次握手之后还需要进行<strong>SSL&#x2F;TLS的握手过程</strong>，才可进行加密报文的传输</li><li>HTTPS 协议需要向 CA（证书权威机构）申请<strong>数字证书</strong>，来保证服务器的身份是可信的。</li></ul><h4 id="HTTPS如何解决HTTP的三大风险"><a href="#HTTPS如何解决HTTP的三大风险" class="headerlink" title="HTTPS如何解决HTTP的三大风险"></a>HTTPS如何解决HTTP的三大风险</h4><h5 id="信息加密"><a href="#信息加密" class="headerlink" title="信息加密"></a>信息加密</h5><p>使用<strong>混合加密</strong>(<strong>对称加密</strong>和<strong>非对称加密</strong>结合)的方式实现信息加密，解决了信息被窃听的风险</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」。</li><li>在通信过程中使用<strong>对称加密</strong>的「会话秘钥」来加密明文数据。</li></ul><img src="/./res\image-20220512144208892.png" alt="image-20220512144208892" style="zoom: 67%;"><h5 id="校验机制"><a href="#校验机制" class="headerlink" title="校验机制"></a>校验机制</h5><p>使用<strong>摘要算法</strong>为数据生成独一无二的<strong>指纹</strong>，用于校验数据的完整性，解决了数据被篡改的风险</p><ul><li>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器</li><li>服务器解密后，用相同的摘要算法算出发送过来的明文的「指纹」，比较客户端携带的「指纹」和当前算出的「指纹」，若「指纹」相同，说明数据是完整的。</li></ul><img src="/./res\image-20220512144444136.png" alt="image-20220512144444136" style="zoom:67%;"><h5 id="身份证书"><a href="#身份证书" class="headerlink" title="身份证书"></a>身份证书</h5><p>使用<strong>数字证书</strong>的方式保证服务器公钥的身份，解决冒充的风险</p><img src="/./res\image-20220512144835190.png" alt="image-20220512144835190" style="zoom: 67%;"><h4 id="TSL握手过程"><a href="#TSL握手过程" class="headerlink" title="TSL握手过程"></a>TSL握手过程</h4><h5 id="TSL第一次握手"><a href="#TSL第一次握手" class="headerlink" title="TSL第一次握手"></a>TSL第一次握手</h5><ul><li>客户端首先会向服务器端发送一个「<strong>Client Hello</strong>」消息</li><li>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数</strong>(<strong>Client Random</strong>)，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</li></ul><img src="/./res\image-20220512153744665.png" alt="image-20220512153744665" style="zoom:50%;"><h5 id="TSL第二次握手"><a href="#TSL第二次握手" class="headerlink" title="TSL第二次握手"></a>TSL第二次握手</h5><ul><li><p>服务端收到客户端的「<strong>Client Hello</strong>」消息后，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了<strong>随机数（Server Random）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p><img src="/./res\image-20220512154535008.png" alt="image-20220512154535008" style="zoom: 50%;"><p>服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p><p>基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」。</p><p>Server Random和Client Random作为后续生成「会话密钥」的条件。</p></li><li><p>服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p></li></ul><img src="/./res\image-20220512155412391.png" alt="image-20220512155412391" style="zoom: 67%;"><ul><li>服务端发送「<strong>Server Hello Done</strong>」消息给客户端，本次握手完毕</li></ul><h5 id="TSL第三次握手"><a href="#TSL第三次握手" class="headerlink" title="TSL第三次握手"></a>TSL第三次握手</h5><ul><li>客户端首先验证服务器端的数字证书，如果可信则继续完成以下内容</li><li>客户端会生成一个新的<strong>随机数 (*pre-master*)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Change Cipher Key Exchange</strong>」消息传给服务端。</li></ul><img src="/./res\image-20220512160414534.png" alt="image-20220512160414534" style="zoom:67%;"><ul><li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。此时客户端和服务端都共享了三个随机数：Client Random、Server Random和pre-master，双方根据这三个随机数生成**会话密钥(Master Secret)**，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</li><li>生成完会话密钥后，客户端发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端开始使用加密方式发送消息。</li></ul><img src="/./res\image-20220512160739718.png" alt="image-20220512160739718" style="zoom:67%;"><ul><li>最后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</li></ul><img src="/./res\image-20220512160907522.png" alt="image-20220512160907522" style="zoom:67%;"><h5 id="TSL第四次握手"><a href="#TSL第四次握手" class="headerlink" title="TSL第四次握手"></a>TSL第四次握手</h5><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成，后续就用「会话密钥」加解密 HTTP 请求和响应了。</p><h4 id="HTTPS如何优化"><a href="#HTTPS如何优化" class="headerlink" title="HTTPS如何优化"></a>HTTPS如何优化</h4><p>具体看这个连接<a href="https://blog.csdn.net/qq_36638788/article/details/124850298">(16条消息) 【HTTPS】HTTPS如何优化？_https优化_再夏的博客-CSDN博客</a></p><h5 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h5><p>HTTPS协议是极端密集型，而不是I&#x2F;O密集型，所以，应该提升CPU硬件。</p><p>一个好的CPU，可以提高计算性能，因为HTTPS连接过程中就由大量需要计算密钥的过程，所以这样可以加速TLS握手过程。</p><p>另外，如果可以，应该选择可以支持AES-NI特性的CPU，因为这种款式的CPU能在指令级别优化了AES算法，这样便可以加速数据的加解密传输过程。</p><p>如过我们的CPU支持AES_NI特性，那么对于对称加密的算法应该选择AES算法。否则可以选择ChaCha20对称加密算法，因为ChaCha20算法的运算指令相比AES换发会对CPU更友好一点。</p><h5 id="密钥交换算法优化"><a href="#密钥交换算法优化" class="headerlink" title="密钥交换算法优化"></a><strong>密钥交换算法优化</strong></h5><p>TLS1.2版本如果使用的是RSA密钥交换算法，那么需要4次握手，也就是要花费2RTT，才可以进行应用数据的传输，而且RSA密钥交换算法不具备前向安全性。总之使用RSA密钥交换算法的TLS握手过程，不仅慢，而且安全性也不高。</p><p>因此如果可以，尽量选用ECDHE密钥交换算法替换RSA算法，因为该算法支持False Start ，它是抢跑的意思，客户端可以在TLS协议的第三次握手后，第四次握手前，发送加密的应用数据，一次将TLS握手的消息往返由2RTT减少到1RTT，而且安全性也高，具备前向安全性。ECDHE算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不高，应该尽量选择x25519曲线，该曲线是目前最快的椭圆曲线。</p><p>在对称加密算法方面，如果对安全性不是特别高的要求，可以选用AES_128_GCM,它比AES_256_GCM快一些，因为密钥的长度短一些。比如在Nginx上，可以使用ssl_ciphers指令配置想使用的非对称加密算法和对称加密算法，也就是密钥套件，而且把性能最快最安全的算法放在最前面。</p><h5 id="TLS升级"><a href="#TLS升级" class="headerlink" title="TLS升级"></a>TLS升级</h5><p>如果可以，直接把TLS1.2成绩成TLS1.3， TLS1.3大幅度简化了握手的步骤，完成TLS握手只要1RTT，而且安全性更高。</p><p>在TLS1.2的握手中，一般是需要4次握手，先要通过Client hello（第1次握手）和Server Hello（第2次握手）消息协商出后续使用的加密算法，在互相交换公钥（第3和第4次握手），然后计算出最终的会话密钥。</p><img src="/./res\58150e7d93bd6f541c3aeed691f5daf1.png" alt="58150e7d93bd6f541c3aeed691f5daf1" style="zoom: 33%;"><p>可以发现TLS1.3把Hello和公钥交换这两个消息合并成了一个消息，于是这样就减少到主要1RTT就能完成TLS握手。具体的做法是，客户端在Client Hello消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p><p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这1个RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就快出进行应用数据的加密传输了。</p><p>而且，TLS1.3对密码太监进行“减肥”了，对于密钥交换算法，飞出了不支持前向安全性的RSA和DH算法，只支持ECDHE算法。</p><p>对于对称加密和签名算法，只支持目前最安全的几个密码套件，比如openssl中仅支持下面5中密码套件：</p><p>TLS_AES_256_GCM_SHA384<br>TLS_CHACHA20_POLY1305_SHA256<br>TLS_AES_128_GCM_SHA256<br>TLS_AES_128_CCM_8_SHA256<br>TLS_AES_128_CCM_SHA256<br>之所以TLS1.3仅支持这么少的密码套件，是因为TLS1.2由于支持各种古老不安全的密码套件，中间人可以利用降级攻击，伪造客户端的Client Hello消息，替换客户端支持的密码套件为一些不安全的密码套件，使得服务器被迫使用这个密码套件进行HTTPS连接，从而破解密文。</p><p><strong>证书优化</strong></p><p>为了验证服务器的身份，服务器会在TLS握手过程中，把自己的证书发给客户端，一次证明自己身份是可信的。</p><p>对于证书的优化，可以有两个方向：</p><ul><li><p>一个是证书传输</p></li><li><p>一个是证书验证</p></li></ul><p><strong>证书传输优化</strong><br>要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是RSA证书，因为在相同安全强度下，ECC密钥长度比RSA短的多。</p><p><strong>证书验证优化</strong><br>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要用CA公钥解密证书以及用签名算法验证证书的完整性，而且为了知道证书是否被CA吊销，客户端优势还会再去访问CA，下载CRL或者OCSP数据，以此确认证书的有效性。</p><p>这个访问过程是HTTP访问，因此又会产生一系列网络通信的开销，如DNS查询、建立连接、收发数据等。</p><h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>​<strong>Cookie是在客户端记录信息来确定用户状态</strong>。Cookie实际上是一小段的文本信息，客户端请求服务器时如果服务器需要记录用户状态，就使用response向客户端浏览器发送一个Cookie，客户端浏览器会把Cookie保存起来；当客户端再次请求该网站时，浏览器会把请求的网址和Cookie一同提交给服务器。服务器会检查该Cookie来辨认用户状态。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​<strong>Session是在服务器端记录客户端状态</strong>，使用上比Cookie简单一些，相应的也<strong>增加了服务器的存储压力</strong>。客户端浏览器访问服务器时，服务器会把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从Session中查找客户端状态就可以了。</p><h4 id="Cookie和Session配合使用"><a href="#Cookie和Session配合使用" class="headerlink" title="Cookie和Session配合使用"></a>Cookie和Session配合使用</h4><ul><li>用户第一次请求服务器时，服务器根据用户提交的信息创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，将此信息存入到 Cookie 中。同时，Cookie 会记录这个SessionID 属于哪个域名。</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在就自动将 Cookie 信息发送给服务端，服务端会从 Cookie 中获取 SessionID ，再根据 SessionID 查找对应的Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><h4 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h4><p>如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。分布式 Session 一般会有以下几种解决方案：</p><ul><li><p>客户端存储：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</p></li><li><p><strong>Nginx ip_hash</strong> 策略：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p></li><li><p><strong>Session</strong> 复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</p></li><li><p>将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</p></li></ul><p>建议采用<strong>共享Session</strong>的方案</p><h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h3 id="DDos攻击"><a href="#DDos攻击" class="headerlink" title="DDos攻击"></a>DDos攻击</h3><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul><li><p><strong>定义：</strong>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果程序忽略了检查，那么这些注入进去的 SQL 语句就会被误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。SQL注入有以下几种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlInject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Course&gt; <span class="title function_">orderList</span><span class="params">(String studentId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,course_id,student_id,status from course where student_id = &quot;</span>+ studentId;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>(Course.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>恶意拼接查询</li><li>利用注释执行非法命令</li><li>传入非法参数</li><li>添加额外条件</li></ul></li><li><p><strong>防止SQL注入</strong></p><ul><li><h5 id="避免将用户输入直接放入SQL语句中"><a href="#避免将用户输入直接放入SQL语句中" class="headerlink" title="避免将用户输入直接放入SQL语句中"></a>避免将用户输入直接放入SQL语句中</h5></li><li><p>使用 <strong>PreparedStatement</strong> 进行 SQL 的预编译：sql 注入只在编译 sql 语句时有破坏作用，而 PreparedStatement 在执行阶段只是把输入作为数据处理, 不对 sql 语句进行解析, 因此避免了 sql 注入问题</p></li><li><p><strong>确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储</strong></p></li><li><p><strong>规定数据长度，能在一定程度上防止sql注入</strong></p></li><li><p><strong>严格限制数据库权限，能最大程度减少sql注入的危害</strong></p></li><li><p><strong>过滤参数中含有的一些数据库关键词</strong></p></li></ul></li></ul><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h3><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>支持多线程（ <del>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</del>）；</li><li>可靠性；</li><li>安全性；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><h3 id="JVM、JRE、JDK"><a href="#JVM、JRE、JDK" class="headerlink" title="JVM、JRE、JDK"></a>JVM、JRE、JDK</h3><p>JDK包含JRE，JRE包含JVM。</p><ul><li><p><strong>JDK是（Java Development Kit）</strong>的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p></li><li><p><strong>JRE是Java Runtime Environment</strong>缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，<strong>它不能用于创建新程序。</strong></p></li></ul><p><img src="/.%5Cres%5Cimage-20220715093402677.png" alt="image-20220715093402677"></p><h3 id="字节码、编译和解释并存"><a href="#字节码、编译和解释并存" class="headerlink" title="字节码、编译和解释并存"></a>字节码、编译和解释并存</h3><p>在 Java 中，<strong>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件）</strong>，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p><strong>在Java中一般是用javac命令编译源代码为字节码文件</strong>，一个.java文件从编译到运行的示例如图所示。</p><p><img src="/.%5Cres%5Cjava%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png" alt="Java程序转变为机器代码的过程"></p><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 <strong>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行</strong>，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT即时（just-in-time compilation） 编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong>。</p><h3 id="Oracle-JDK和Open-JDK"><a href="#Oracle-JDK和Open-JDK" class="headerlink" title="Oracle JDK和Open JDK"></a>Oracle JDK和Open JDK</h3><ul><li>Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；</li><li><strong>OpenJDK</strong> 是一个参考模型并且是<strong>完全开源</strong>的，而 <strong>Oracle JDK 是OpenJDK 的一个实现</strong>，并<strong>不是完全开源</strong>的；</li><li><strong>Oracle JDK 比 OpenJDK 更稳定</strong>。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPLv2 许可获得许可。</li></ul><h3 id="Java和C"><a href="#Java和C" class="headerlink" title="Java和C++"></a>Java和C++</h3><p><strong>都是面向对象的语言，都支持封装、继承和多态</strong></p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是<strong>接口可以多继承</strong>。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要手动释放无用内存。</li><li>C ++支持方法重载和操作符重载，Java 只支持方法重载。</li></ul><h3 id="成员变量、局部变量"><a href="#成员变量、局部变量" class="headerlink" title="成员变量、局部变量"></a>成员变量、局部变量</h3><ul><li><strong>语法形式</strong> ：<ul><li><strong>成员变量是属于类的</strong>，而局部变量是在代码块或方法中定义的变量或参数；</li><li>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，<strong>局部变量不能被访问控制修饰符及 <code>static</code> 所修饰</strong>；</li><li>但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li></ul></li><li><strong>存储方式</strong> ：<ul><li><strong>使用 <code>static</code> 修饰的成员变量</strong>是属于类的，<strong>存在于堆中</strong></li><li><strong>没有使用 <code>static</code> 修饰的成员变量</strong>是属于<strong>实例对象</strong>的，<strong>存在于堆内存</strong></li><li><strong>局部变量则存在于栈内存</strong>。</li></ul></li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看<ul><li>成员变量是对象的一部分，<strong>随着对象的创建而存在</strong></li><li>局部变量随着方法的调用而生成，<strong>随着方法的结束而消亡</strong>。</li></ul></li><li><strong>默认值</strong> ：从变量是否有默认值来看<ul><li><strong>成员变量</strong>如果没有初值，<strong>会自动以类型的默认值赋值</strong>（一种情况例外：<strong>被 <code>final</code> 修饰的成员变量必须显式地赋值</strong>），</li><li><strong>局部变量则不会自动赋值</strong>。</li></ul></li></ul><h4 id="何为成员变量"><a href="#何为成员变量" class="headerlink" title="何为成员变量"></a>何为成员变量</h4><ul><li>成员变量就是定义在<strong>类里</strong>、<strong>方法外</strong>的变量，也叫全局变量。</li><li>成员变量又分为：<strong>实例变量</strong>(没有 static )和<strong>类变量</strong>(有 static 修饰)。</li></ul><p><strong>实例变量</strong>存放在<strong>堆</strong>中，栈中放指向堆的引用地址</p><p><strong>类变量</strong>存放在<strong>堆</strong>中</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final、finally、finalize"><a href="#final、finally、finalize" class="headerlink" title="final、finally、finalize"></a>final、finally、finalize</h4><h5 id="final："><a href="#final：" class="headerlink" title="final："></a>final：</h5><ul><li>被 <code>final</code> 关键字修饰的类不能被继承</li><li>修饰的方法不能被重写</li><li>修饰的变量是基本数据类型则值不能改变，</li><li>修饰的变量是引用类型则不能再指向其他对象。</li></ul><p>final修饰的实例变量一般添加：static，变为静态，称为常量。常量名全部大写，单词之间用下划线衔接。</p><h5 id="finally："><a href="#finally：" class="headerlink" title="finally："></a><strong>finally：</strong></h5><ul><li><p>作为异常处理的一部分，只能用于 try-catch-finally 结构中，<strong>无论是否捕获或处理异常，finally块里的语句都会被执行</strong>；</p></li><li><p>当 try 块或 catch 块中有 return 语句时，finally 语句块将在方法返回之前被执行，经常被用在需要释放资源的情况下。</p></li></ul><p>在以下4种特殊情况下，finally 块不会被执行：</p><ul><li>在 finally 语句块中发生了异常。</li><li>在前面的代码中用了 <code>System.exit() </code>退出程序。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ul><p><strong>finalize：</strong> </p><p>finalize 是 Object 类里定义的方法，每个对象都存在该方法，这个方法会在对象被回收时调用。<strong>一个对象的 finalize 方法只会被调用一次</strong>，finalize 被调用不一定会立即回收该对象，有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此<strong>不推荐使用 finalize 方法</strong>。</p><blockquote><p> 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行</p><p> 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p></blockquote><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><ul><li>可以修饰类和方法，<strong>不能修饰属性和构造方法</strong></li><li>abstract 修饰的类是抽象类，需要被继承；修饰的方法是抽象方法，需要被重写</li><li><strong>抽象类不一定非要有抽象方法</strong></li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li><p>static 可以修饰<strong>类、方法、变量和代码块</strong></p></li><li><p>static 修饰的类是静态内部类、修饰的方法是静态方法、修饰的变量是类变量、修饰的代码块是静态代码块</p></li><li><p><strong>static 不能用来修饰构造方法，因为 static 修饰的是与对象无关的内容，而构造确实生成对象的五大方法之一</strong></p></li></ul><p><strong>为什么要用 static 关键字？</strong></p><ul><li>通常来说，用 new 创建类的对象时，数据存储空间才被分配。但有时我们只想<strong>为特定域分配单一存储空间</strong>，不考虑要创建多少对象或者说根本就不创建任何对象。</li><li>再就是我们想<strong>在没有创建对象的情况下调用方法</strong>。在这两种情况下，static关键字，满足了我们的需求。</li></ul><p><strong>static关键字是什么意思？</strong>Java 中是否可以<strong>重写</strong>一个 private 或者是 static 的方法？</p><ul><li>static 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</li><li>Java中static方法<strong>不能被重写</strong>，因为方法<strong>重写是运行时动态绑定的</strong>，而<strong>static方法是编译时静态绑定</strong>的。static方法跟类的任何实例都不相关，所以概念上不适用。</li></ul><p><strong>是否可以在 static 环境中访问非 static 资源？</strong></p><p><strong>不可以</strong>，当类被 Java 虚拟机载入时就会对 static 资源进行初始化，此时非 static 资源还没有被 new 创建出来，无法被 static 资源访问到。</p><h4 id="switch-关键字"><a href="#switch-关键字" class="headerlink" title="switch 关键字"></a>switch 关键字</h4><p>1、switch 后的变量可以是 <strong>byte</strong>、<strong>short</strong>、<strong>int</strong>、<strong>char</strong>、<strong>String</strong>、<strong>枚举类型</strong></p><p>2、case 之后的值必须和 switch 变量的<strong>类型一致</strong>；</p><p>3、default 是在没有 case 语句的值和变量值相等的时候执行。 default 不是必须的，可以不写。</p><p>版本迭代</p><ul><li>Java 5之前，switch(expr)中expr只能是byte、short、int、char</li><li>Java 5引入了枚举类型，即expr也可以是enum类型</li><li>Java 7开始expr还可以是String，<strong>但不支持long类型</strong></li><li>Java 17开始可以使用模式匹配 case … -&gt;</li></ul><h3 id="访问修饰符-public、protected、private、default"><a href="#访问修饰符-public、protected、private、default" class="headerlink" title="访问修饰符(public、protected、private、default)"></a>访问修饰符(public、protected、private、default)</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>public</strong> : 对<strong>所有类</strong>可见。使用对象：类、接口、变量、方法</li><li><strong>protected</strong> : 对<strong>同一包下的类和所有子类</strong>可见。使用对象：变量、方法。注意：不能修饰类（外部类）。</li><li><strong>default</strong>: <strong>同一包内可见</strong>，不使用任何修饰符。使用对象：类、接口、变<br>量、方法。</li><li><strong>private</strong> : 在<strong>同一类</strong>内可见。使用对象：变量、方法。注意：<strong>不能修饰类</strong>（外部类）</li></ul><img src="/./res\image-20220819205455466.png" alt="image-20220819205455466" style="zoom:67%;"><h3 id="重载（Overload）和重写（Override）"><a href="#重载（Overload）和重写（Override）" class="headerlink" title="重载（Overload）和重写（Override）"></a>重载（Overload）和重写（Override）</h3><img src="/./res\image-20220718094147831.png" alt="image-20220718094147831" style="zoom: 67%;"><p>重载就是<strong>同一个类中多个同名方法根据不同的传参</strong>来执行不同的逻辑处理。</p><p><strong>方法的重写要遵循“两同两小一大”</strong></p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是<strong>子类方法的访问权限应比父类方法的访问权限更大</strong>或相等。</li></ul><p>关于 <strong>重写的返回值类型</strong> ：如果方法的返回类型是 void 和基本数据类型，重写时返回值不可修改。如果方法的返回值是引用类型，重写时可以返回该引用类型的子类。</p><h3 id="静态方法和静态变量"><a href="#静态方法和静态变量" class="headerlink" title="静态方法和静态变量"></a>静态方法和静态变量</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p><strong>类变量（静态变量）</strong>存放在<strong>堆</strong>中</p><p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，都共享同一份静态变量。</p><p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>类方法是属于类的</p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，</p><p>而实例方法只有<code>对象.方法名</code>这种方式。也就是说，<strong>调用静态方法可以不创建对象</strong> 。</p><blockquote><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p></blockquote><h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h4><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li><p><strong>静态方法是属于类的</strong>，在类加载的时候就会分配内存，可以通过<strong>类名直接访问</strong>。</p><p>而<strong>非静态成员属于实例对象</strong>，只有在对象实例化之后才存在，需要通过<strong>类的实例对象去访问</strong>。</p></li><li><p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p></li></ol><h4 id="静态变量、代码块、和静态方法的执行顺序"><a href="#静态变量、代码块、和静态方法的执行顺序" class="headerlink" title="静态变量、代码块、和静态方法的执行顺序"></a><strong>静态变量、代码块、和静态方法的执行顺序</strong></h4><p>基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块</p><p>代码块执行顺序<strong>静态代码块——&gt; 构造代码块 ——&gt; 构造函数——&gt; 普通代码块</strong></p><p>继承中代码块执行顺序：<strong>父类静态变量和静态代码块（先声明的先执行）——&gt;子类静态变量和静态代码块（先声明的先执行）——&gt;父类的变量和代码块（先声明的先执行）——&gt;父类构造器——&gt;子类的变量和代码块（先声明的先执行）——&gt;子类构造器</strong></p><h2 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型：<ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code></li></ul><p><img src="/.%5Cres%5CQQ%E6%88%AA%E5%9B%BE20230524155004.png"></p><p>另外，对于<code>boolean</code>，官方文档未明确定义，它依赖于JVM厂商的具体实现。逻辑上理解是占用1位，但是实际中会考虑计算机高效存储因素。</p><p><a href="https://leetcode.cn/circle/discuss/bAOPBU/">面试官竟然问我这么简单的题目：Java 中 boolean 占多少字节？我脱出而出…… - 力扣（LeetCode）</a></p><blockquote><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）</p></blockquote><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h4><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li></ul><p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>大部分包装类都实现<strong>类常量池缓存技术</strong>，**<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code>** 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>，两种浮点数类型的包装类 <code>Float</code>，<code>Double</code> 并没有实现缓存机制。</p><ul><li><p><strong>如果要创建的数值在缓存范围内，直接从缓存中取出相应对象即可，如果超出范围需要去创建新的对象。</strong></p></li><li><p><strong>如果是通过 new 关键字来创建对象，则不管在不在缓存范围内都是一个新对象。</strong></p></li></ul><p>由于缓存机制，对于<strong>在 -128 到 127 之间的 Integer 可以使用 &#x3D;&#x3D; 来进行比较</strong>，但是在这个区间之外会创建新的对象，这个时候需要使用 equals 方法进行判断，因此<strong>包装类型推荐使用 equals 方法进行判断</strong>。</p><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><ul><li><strong>装箱</strong>：将基本数据类型用它们对应的包装类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><p>这个和计算机保存浮点数的机制有很大关系。我们知道<strong>计算机是二进制的</strong>，而且计算机在表示一个数字时，宽度是有限的，<strong>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况</strong>。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>如何解决</strong></p><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure><h3 id="超过Long的数据表示"><a href="#超过Long的数据表示" class="headerlink" title="超过Long的数据表示"></a>超过Long的数据表示</h3><p><strong><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</strong>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低</p><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。在 Java 中，64 位 long 整型是最大的整数类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​封装是指<strong>把一个对象的属性隐藏在对象内部，不允许外部直接访问</strong>，但是可以提供一些可以被外部访问的方法来操作属性。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li><p><strong>定义：继承是使用已存在的类的定义作为基础建立新类的技术</strong>，新类可以增加新的数据或方法，也可以用父类的方法，但<strong>不能选择性地继承父类</strong>。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p></li><li><p><strong>关于继承如下 3 点请记住：</strong></p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是<strong>父类中的私有属性和方法子类是无法访问的</strong>，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li><p><strong>定义</strong>：表示一个对象具有多种状态，具体表现为<strong>父类的引用指向子类的实例</strong>。</p></li><li><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量调用的方法到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li></ul></li><li><p><strong>多态存在的三个必要条件</strong></p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<strong>Parent p &#x3D; new Child();</strong></li></ul></li><li><p><strong>多态的实现方式</strong></p><ul><li><p><strong>方式一：重写：</strong></p></li><li><p><strong>方式二：接口</strong></p><p>1、生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</p><p>2、java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 <a href="https://www.runoob.com/java/java-interfaces.html">java接口</a> 这一章节的内容。</p></li><li><p><strong>方式三：抽象类和抽象方法</strong></p><p>详情请看 <a href="https://www.runoob.com/java/java-abstraction.html">Java抽象类</a> 章节。</p></li></ul></li><li><p><strong>多态的优点</strong></p><p>可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><ul><li>提高了程序的扩展性</li><li>降低了代码之间的耦合</li></ul></li></ul><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法</strong>，<strong>如果没有，则编译错误；如果有，再去调用子类的同名方法</strong>。</p><h3 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h3><ul><li>面向过程把解决问题的过程<strong>拆成一个个方法</strong>，通过一个个方法的执行解决问题。</li><li>面向对象会先<strong>抽象出对象</strong>，然后用对象执行方法的方式解决问题。</li></ul><p>面向对象开发的程序一般<strong>更易维护、易复用、易扩展。</strong></p><blockquote><p><strong>面向过程 ：面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，<strong>而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机器码。</strong></p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p></blockquote><h3 id="对象相等和引用相等"><a href="#对象相等和引用相等" class="headerlink" title="对象相等和引用相等"></a>对象相等和引用相等</h3><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）</p><ul><li>对象相等一般比较的是内存中存放的<strong>内容</strong>是否相等。</li><li>引用相等一般比较的是他们指向的<strong>内存地址</strong>是否相等。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><strong>类的构造方法的作用是什么?</strong></p><ul><li>构造方法是一种特殊的方法，主要作用是<strong>完成对象的初始化工作</strong>。</li></ul></li><li><p><strong>如果一个类没有声明构造方法，该程序能正确执行吗?</strong></p><ul><li>如果一个类没有声明构造方法，<strong>会有默认的不带参数的构造方法</strong>。</li><li>如果我们<strong>自己添加了类的构造方法</strong>（无论是否有参），<strong>Java 就不会再添加默认的无参数的构造方法</strong>。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</li></ul></li><li><p><strong>构造方法有哪些特点？</strong></p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul></li><li><p><strong>构造方法不能被 override（重写）</strong>，但是可以 <strong>overload（重载）</strong>，<strong>一个类中可以有多个构造函数</strong>。</p></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>定义：抽象方法和常量值的集合(所有的方法都是抽象方法)。它是**一种特殊的抽象类(会生成一个 xxx.class 文件，编译器会自动在 interface 关键字前加上 abstract)**。</p><p>特点：</p><ul><li><p>接口中定义的方法，默认加 **public abstract ** (如果是什么都不写，编译器会自动帮你写上)</p></li><li><p>接口中可以定义 default 方法</p></li><li><p>接口中定义的变量，全部为全局常量，默认加 <strong>public static final</strong> (如果什么都不写，<strong>编译器会自动帮你写上</strong>)</p></li><li><p>接口可以用 extends 继承已有的接口。</p></li><li><p>类可以用 implements 实现<strong>一个或多个接口</strong>中的<strong>所有</strong>方法(包括这个接口的<strong>父接口中的方法</strong>)</p></li><li><p>抽象类可以用 implements 实现接口中的<strong>部分方法</strong></p></li><li><p>类可以 extends 一个父类的同时 implements 多个接口，但是 extends 关键字必须在 implements 关键字之前。</p></li></ul><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>定义：抽象类是它所有子类的公共属性的集合</p><p>特点：</p><ul><li>抽象类，其修饰符必须为 public 或者 protected，不能是 private，因为创建抽象类，就是要被其他类继承，用 private 修饰了，则不能被子类继承，子类便无法实现该方法。</li><li>抽象类可以有抽象方法，但是不一定非要有抽象方法</li><li>抽象类不能用来创建对象，即抽象类不能被直接实例化，要通过其普通子类进行实例化。</li><li>如果一个普通子类继承一个抽象父类，子类一定要重写父类的抽象方法。如果该子类仍然是一个抽象类，这也是允许的，就不必重写实现该父类的抽象方法，但必须用abstract修饰。</li><li>抽象级别：抽象类是对整体类的抽象，包含属性和方法。</li><li>实现类的范围不同：抽象类，其实是从子类中提取共性部分，然后抽象出来，反之，子类继承该父类就可以了，也就是说里面的抽象方法一般来自同一个类别。</li><li>设计方式不同：抽象类是要先有子类，然后才抽象出父类，是一种从下往上的构建法则。</li></ul><h4 id="共同点和区别"><a href="#共同点和区别" class="headerlink" title="共同点和区别"></a>共同点和区别</h4><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li><strong>都可以有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于<strong>约束类的行为，实现了某个接口就有了对应的行为</strong>。抽象类是对一种事物的抽象，<strong>主要用于代码复用，强调的是所属关系</strong>。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法</li></ul><h3 id="深拷贝、浅拷贝、引用拷贝"><a href="#深拷贝、浅拷贝、引用拷贝" class="headerlink" title="深拷贝、浅拷贝、引用拷贝"></a>深拷贝、浅拷贝、引用拷贝</h3><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象，如果原对象的属性是引用类型，浅拷贝会直接复制原对象属性的引用地址。Object 类的clone() 方法采用的是浅拷贝。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，在内存中生成一个新的对象。</li><li><strong>引用拷贝</strong> ：引用拷贝就是两个不同的引用指向同一个对象。</li></ul><img src="/./res\shallow&deep-copy.8d5a2e45.png" alt="img" style="zoom:50%;"><h4 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h4><p>实现了 <code>Cloneable</code> 接口，并重写 <code>clone()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (A) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h4><p>（不推荐）递归实现所有对象的拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">clone</span> <span class="operator">=</span> (A) <span class="built_in">super</span>.clone();</span><br><span class="line">            clone.b = <span class="built_in">this</span>.b.clone();</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（推荐）通过序列化(Serializable)的方法，将对象写到流里，然后再从流中读取出来，实现深拷贝。可以直接使用序列化工具进行序列化和反序列化，例如JSON。</p><h2 id="重要的类（Object、String）"><a href="#重要的类（Object、String）" class="headerlink" title="重要的类（Object、String）"></a>重要的类（Object、String）</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">// native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">// naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">// 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">// native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">// native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">// native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h4><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><blockquote><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code> 方法存在于 <code>Object</code> 类中，而 <code>Object</code> 类是所有类的直接或间接父类，因此所有的类都有 <code>equals()</code> 方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象的属性是否相等；若它们的属性相等，则返回 true</li></ul><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有对象的值和要创建的对象的值相同，如果有就把这个对象赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode()"></a>hashcode()</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><img src="/.%5Cres%5Cjava-hashcode-method.png" alt="hashCode() 方法"></p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 <code>HashSet</code> 的过程）！</p><p>我们在前面也提到了添加元素进 <code>HashSet</code> 的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p><p>这是因为两个对象的 <code>hashCode</code> 值相等并不代表两个对象就相等。</p><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象返回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p><strong>总结下来就是：</strong></p><ul><li>如果两个对象的 <code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的 <code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，才认为这两个对象相等。</li><li>如果两个对象的 <code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><p><strong>为什么重写 equals() 时必须重写 hashCode() 方法？</strong></p><p>因为两个相等的对象的 <code>hashCode</code> 必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 却不相等。</p><p><strong>总结</strong>：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><p><strong>作用</strong></p><ul><li>使当前的线程进行等待</li><li>释放当前的锁；</li><li>被唤醒时，重新尝试获取这个锁</li></ul><p><strong>用法</strong></p><p>需要和 <strong>synchronized</strong> 配合使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><strong>过程分析</strong></p><ol><li>线程获取被 synchronized 修饰的 object 的锁（monitor）</li><li>线程调用 object.wait() 方法</li><li>线程释放 object 的锁，并立即进入</li></ol><p><strong>结束条件</strong></p><p><strong>wait结束等待的条件 :</strong></p><ul><li>其他线程（也可以不是线程）调用了该对象的 notify 或 notifyAll 方法</li><li>其他线程（也可以不是线程）调用该等待线程的 interrupted 方法</li><li>等待时间超时：wait（有参）</li></ul><p>注意:wait(0)表示的是无限等待</p><h4 id="notifiy"><a href="#notifiy" class="headerlink" title="notifiy()"></a>notifiy()</h4><p><strong>作用</strong></p><ul><li>notify()： 唤醒一个与该锁对象关联的在等待队列中的线程，一次唤醒一个，而且是任意的。</li><li>notifyAll()：唤醒全部：可以将线程池中的所有 wait() 线程都唤醒。</li></ul><p><strong>用法</strong></p><p>需要和 <strong>synchronized</strong> 配合使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object object=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        object.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><strong>wait 结束等待的条件 :</strong></p><ul><li>1.其他线程（也可以不是线程）调用了该对象的notify或notifyAll方法</li><li>2.其他线程（也可以不是线程）调用该等待线程的interrupted方法</li><li>3.等待时间超时：wait（有参）</li></ul><p>注意:wait(0)表示的是无限等待</p><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<strong>JDK1.7 字符串常量池被从方法区拿到了堆中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aa&quot;</span>); </span><br></pre></td></tr></table></figure><p>使用 new 关键字创建一个字符串对象时，Java 虚拟机会<strong>先在字符串常量池中查找有没有值为 “aa” 的字符串对象</strong>。</p><ul><li><strong>如果没有</strong>，<strong>先在字符串常量池中创建一个 ‘aa’ 的字符串对象，然后再在堆中创建一个 ‘aa’ 的字符串对象</strong>，然后将堆中 ‘aa’ 字符串对象的地址赋值给变量 s。</li><li><strong>如果有</strong>，就<strong>不会在字符串常量池中创建 ‘aa’ 对象，直接在堆中创建 ‘aa’ 的字符串对象</strong>，然后将堆中 ‘aa’ 对象的地址赋值给变量s。</li></ul><p>通常情况下会<strong>采用双引号的方式</strong>来创建字符串对象，而不是通过 new 关键字的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>执行 String s &#x3D; “bb” 时，会先在字符串常量池中查找有没有 “bb” 这个字符串对象。<br><strong>如果有，不创建任何对象，直接返回字符串常量池中 “bb” 对象的地址</strong>，赋给变量 s；<br><strong>如果没有，在字符串常量池中创建“bb”对象，然后将其地址返回</strong>，赋给变量 s。</li><li>有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了。</li><li><strong>new 的方式始终会在堆中创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。</strong></li></ul><h4 id="String-的-equals"><a href="#String-的-equals" class="headerlink" title="String 的 equals()"></a>String 的 equals()</h4><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h4 id="String-的-intern"><a href="#String-的-intern" class="headerlink" title="String 的 intern()"></a>String 的 intern()</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p><ul><li>如果<strong>字符串常量池中保存了</strong>对应的字符串对象的引用，就<strong>直接返回该引用</strong>。</li><li>如果<strong>字符串常量池中没有保存</strong>了对应的字符串对象的引用，那就在常量池中<strong>创建</strong>一个指向该字符串对象的<strong>引用并返回</strong>。</li></ul><h4 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h4><p><strong>可变性</strong></p><p><code>String</code> 是不可变的（底层是 final 修饰的 char[]）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[]; </span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 对象是不可变的，线程安全。</p><p><code>StringBuffer</code> 对方法加了同步锁，是<strong>线程安全</strong>的。</p><p><code>StringBuilder</code> 没有对方法加同步锁，是<strong>非线程安全</strong>的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型的变量进行修改，都会生成一个新的 <code>String</code> 对象，然后将新的 <code>String</code> 对象的地址赋值给变量。</p><p><code>StringBuffer</code> 每次都是对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象。</p><p>相同情况下使用 <code>StringBuilder</code> 比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h4 id="、"><a href="#、" class="headerlink" title="+、+&#x3D;"></a>+、+&#x3D;</h4><p>Java 语言本身并不支持运算符重载，“+” 和 “+&#x3D;” 是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><p><strong>字符串对象通过 “+” 的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</strong></p><p><strong>在循环内使用 “+” 进行字符串的拼接</strong>的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac  编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Exception-和-Error"><a href="#Exception-和-Error" class="headerlink" title="Exception 和 Error"></a>Exception 和 Error</h3><p>在 Java 中，<strong>所有的异常</strong>都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类：</p><ul><li><strong><code>Exception</code></strong> ：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception </code> 又可以分为<strong>运行时异常</strong>(<strong>RuntimeException</strong>, 又叫<strong>非受检查异常</strong>，可以不处理)和<strong>非运行时异常</strong>(又叫<strong>受检查异常</strong>，必须处理) 。<ul><li><strong>运行时异常</strong>：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。<code>NullPointerException</code><strong>(空指针异常)<strong>，<code>IndexOutOfBoundsException</code><strong>（数组越界异常）</strong>，<code>ClassCastException</code>（</strong>类型转换异常</strong>），<code>NumberFormatException</code>（<strong>字符串转换为数字格式异常）</strong>等。</li><li><strong>非运行时异常</strong>：除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</li><li><strong>区别</strong>：<strong>受检查异常</strong>没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<strong>非受检查异常</strong> ，Java 代码在编译过程中 ，我们即使<strong>不处理非受检查异常也可以正常通过编译</strong>。</li></ul></li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，不建议通过 <code>catch</code> 捕获 。例如 Java 虚拟机运行错误（<code>Virtual Machine Error</code>）、虚拟机内存不足错误 (<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>），<code>StackOverflowError</code> 堆栈溢出错误等 。这些异常发生时，Java 虚拟机一般会选择线程终止。</li></ul><blockquote><p>为什么不该捕获 Error 呢？<strong>Error 是指不应该被捕获的严重错误</strong>，出现 Error 会导致程序无法运行，捕获了也没有任何意义。</p></blockquote><h3 id="运行时异常和一般异常"><a href="#运行时异常和一般异常" class="headerlink" title="运行时异常和一般异常"></a>运行时异常和一般异常</h3><p>Checked Exception 和 Unchecked Exception 有什么区别？</p><ul><li><p><strong>非受检查异常（运行时异常）</strong>：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p><ul><li><code>NullPointerException</code><strong>(空指针异常)</strong></li><li><code>IllegalArgumentException</code>(参数异常，比如方法传入参类型异常)</li><li><code>NumberFormatException</code>（<strong>字符串转换为数字格式错误</strong>，<code>IllegalArgumentException</code>的子类）</li><li><code>IndexOutOfBoundsException</code><strong>（数组越界异常）</strong></li><li><code>ClassCastException</code>（<strong>类型转换异常</strong>）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li>ArrayStoreException (<strong>数据存储异常</strong>，操作数组时类型不一致)</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul></li><li><p><strong>受检查异常（一般异常）</strong>：除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p></li><li><p><strong>区别</strong>：<strong>受检查异常</strong>没有被 <code>catch </code>或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<strong>非受检查异常</strong> ，Java 代码编译过程中 ，即使<strong>不处理非受检查异常也可以正常通过编译</strong>。</p></li></ul><h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><strong>出现异常时将异常捕获，并自定义相应的处理方法。</strong></p><ul><li><code>try</code> 块 ：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code> 块 ：用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中有 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>注意：不要在 finally 语句块中使用 return</strong>！当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><p><strong>catch 可以省略</strong>。更为严格的说法其实是：<strong>try <strong>只适合处理</strong>运行时异常</strong>，<strong>try + catch <strong>适合处理</strong>运行时异常+普通异常</strong>。也就是说，如果你只用 try 去处理普通异常却不加以 catch 处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch 显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch 可以省略，加上 catch 编译器也觉得无可厚非。</p><h4 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h4><p>遇到问题不进行具体处理，而是继续抛给调用者。</p><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以<strong>通过 <code>throws</code>关键字在方法上声明该方法要拋出的异常</strong>，或者<strong>在方法内部通过<code> throw</code> 拋出异常对象</strong>。</p><ul><li><strong>throw</strong> 关键字用<strong>在方法内部</strong>，只能抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li><li><strong>throws</strong> 关键字用<strong>在方法声明上</strong>，<strong>可以抛出多个异常</strong>，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h4 id="异常使用时需要注意的点"><a href="#异常使用时需要注意的点" class="headerlink" title="异常使用时需要注意的点"></a>异常使用时需要注意的点</h4><ul><li><p>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</p><p>怎么理解  <strong>异常定义为静态变量，会导致异常栈信息错乱</strong></p><p>类似于定义一个Exceptions类来汇总所有的异常，把异常存放在静态字段中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exceptions</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">BusinessException</span> <span class="variable">ORDEREXISTS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;订单已经存在&quot;</span>, <span class="number">3001</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把异常定义为静态变量<strong>会导致异常信息固化</strong>，这就和异常的栈一定是需要根据当前调用来动态获取相矛盾。</p></li><li><p>抛出的异常信息一定要有意义。</p></li><li><p>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</p></li><li><p>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</p></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>定义</strong>：泛型是 JDK1.5 的一个新特性，本质是指<strong>类型参数化，在编译时才确定具体的参数。</strong>可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p><p><strong>泛型的作用</strong>:</p><ul><li>使用泛型可在编译期间进行类型检测。</li><li>使用 object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li><li>泛型可以使用自限定类型如 T extends Comparable</li></ul><blockquote><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p></blockquote><h3 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h3><p><strong>泛型类</strong>：在类名后面添加类型参数声明部分，可以包含一个或多个类型参数，参数间用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型接口</strong> ：实现泛型接口，可以选择指定或者不指定类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p><strong>Java 的泛型是伪泛型，在编译期间，会擦除所有的泛型信息，也就是通常所说类型擦除。</strong>编译器在编译期间会动态地将泛型 <code>T</code> 擦除为 <code>0bject</code> 或将 <code>T extends xxx</code> 擦除为限定类型 <code>xxx</code>。</p><p>类型擦除的目的是<strong>通过擦除将泛型类转化为一般类，保证引入泛型机制的同时不创建新的类型，减少虚拟机的运行开销。</strong></p><p><strong>既然编译器要把泛型擦除，那为什么还要用泛型呢？用 Object 代替不行吗?</strong><br>这个问题其实在变相考察<strong>泛型的作用</strong>:</p><ul><li>使用泛型可在编译期间进行类型检测。</li><li>使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li><li>泛型可以使用自限定类型如 T extends Comparable</li></ul><h3 id="泛型的限制"><a href="#泛型的限制" class="headerlink" title="泛型的限制"></a>泛型的限制</h3><p>泛型的限制一般是由泛型擦除机制导致的。擦除为 Object 后无法进行类型判断</p><ul><li>只能声明不能实例化T类型变量。</li><li><strong>泛型参数不能是基本类型</strong>。因为基本类型不是Object子类，应该用基本类型对应的<strong>引用类型</strong>代替。</li><li>不能实例化泛型参数的数组。擦除后为Object后无法进行类型判断。</li><li>不能实例化泛型数组。</li><li>泛型无法使用 Instance of 和 getclass() 进行类型判断。</li><li>不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突</li><li><strong>不能使用 static 修饰泛型变量</strong></li></ul><blockquote><p><strong>关于静态方法为什么不能使用类的泛型</strong>？</p><p>泛型只是一个占位符，必须传递类型后才能使用。而<strong>类实例化时才能真正的的传递类型参数</strong>，但是<strong>静态方法的加载先于类的实例化</strong></p></blockquote><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>泛型类型是固定的，某些场景下使用起来不太灵活，于是，通配符就来了。通配符可以允许类型参数变化，用来解决泛型无法协变的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制类型为 Person 的子类</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// 限制类型为 Manager 的父类</span></span><br><span class="line">&lt;? <span class="built_in">super</span> Manager&gt;</span><br></pre></td></tr></table></figure><h4 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h4><ul><li><p><strong>限定通配符</strong>：对类型进行了限制。有两种限定通配符，</p><ul><li><strong>上边界通配符</strong>：&lt;? extends T&gt;它通过<strong>确保类型必须是T的子类来设定类型的上界</strong>，</li><li><strong>下边界通配符</strong>：&lt;? super T&gt;它通过<strong>确保类型必须是T的父类来设定类型的下界</strong>。</li><li>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</li></ul></li><li><p><strong>非限定通配符 ？</strong>:可以用任意类型来替代。如List&lt;?&gt; 的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A> ，也可以是List<B> ,或者List<C> 等等。</C></B></A></p></li></ul><h4 id="通配符-和常用的泛型-T-之间有什么区别"><a href="#通配符-和常用的泛型-T-之间有什么区别" class="headerlink" title="通配符 ? 和常用的泛型 T 之间有什么区别?"></a>通配符 <code>?</code> 和常用的泛型 T 之间有什么区别?</h4><ul><li>T 可以用于声明变量或常量而 <code>?</code> 不行。</li><li>T 一般用于声明泛型类或方法，通配符 <code>?</code> 一般用于泛型方法的调用代码和形参。</li><li>T 在编译期会被擦除为限定类型或 0bject，通配符用于捕获具体类型。</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射赋予了我们<strong>在运行时分析类以及执行类中方法的能力</strong>。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p><h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p><strong>优点</strong> ： 可以让<strong>代码更加灵活</strong>、为各种框架提供开箱即用的功能。</p><p><strong>缺点</strong> ：让我们<strong>在运行时有了分析操作类的能力</strong>，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p><h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h3><p>[Java获取反射的四种方法](<a href="https://www.cnblogs.com/firecode7/p/13268311.html#:~:text=Java%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95">https://www.cnblogs.com/firecode7/p/13268311.html#:~:text=Java获取反射的四种方法</a> 1. 通过new对象实现反射机制（ 对象.getClass (),） 2. 通过路径实现反射机制（ Class.forName (“包名.类名”) ）)</p><ol><li><p>通过new对象实现反射机制（对象.getClass() ）</p></li><li><p>通过路径实现反射机制（Class.forName(“包名.类名”) ）</p></li><li><p>通过类名实现反射机制 （类名.Class）</p></li><li><p>通过类加载器 <code>xxxClassLoader.loadClass()</code>传入类路径获取：通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p></li></ol><h3 id="反射使用的步骤"><a href="#反射使用的步骤" class="headerlink" title="反射使用的步骤"></a>反射使用的步骤</h3><ol><li>反射的核心就是获取想要操作的类的 Class 对象，通过 Class 对象可以调用类中任意方法。</li><li>调用 Class 类中的方法，就是反射的使用阶段。</li><li>使用反射 API 来操作这些信息。</li></ol><p>一般情况下我们使用反射获取一个对象的步骤：</p><ol><li><p>获取类的 Class 对象实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.zhenai.api.Apple&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>根据 Class 对象实例获取 Constructor 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">appleConstructor</span> <span class="operator">=</span> clz.getConstructor();</span><br></pre></td></tr></table></figure></li><li><p>使用 Constructor 对象的 newInstance() 方法获取反射类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">appleObj</span> <span class="operator">=</span> appleConstructor.newInstance();</span><br></pre></td></tr></table></figure></li><li><p>根据 Class 对象获取方法的 Method 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">setPriceMethod</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure></li><li><p>利用 invoke() 方法调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="反射机制的原理"><a href="#反射机制的原理" class="headerlink" title="反射机制的原理"></a>反射机制的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class actionClass=Class.forName(“MyClass”); </span><br><span class="line">Object action=actionClass.newInstance(); </span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> actionClass.getMethod(“myMethod”,<span class="literal">null</span>); </span><br><span class="line">method.invoke(action,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><ul><li><code>Class.forName()</code>：获取对应类的 Class 对象，如果类还没有加载则由 JVM 先进行类的加载</li><li><code>actionClass.newInstance()</code>： 主要做了三件事<ul><li>权限检测，如果不通过直接抛出异常；</li><li>查找无参构造器，并将其缓存起来；</li><li>调用具体方法的无参构造方法，生成实例并返回。</li></ul></li><li><code>actionClass.getMethod(“myMethod”,null)</code>：<strong>获取 Method 对象</strong>，JVM 为每个类管理一个独一无二的 Class 对象，Class 对象里维护了该类的所有 Method，Field，Constructor 的 cache，这份 cache 也可以被称作根对象。每次 getMethod 获取到的Method对象都持有对根对象的引用，所有代表<strong>同一个方法的Method对象都共享着根对象的 MethodAccessor</strong>，每一次创建都会调用根对象的copy方法复制一份</li><li><code>method.invoke(action,null)</code>：调用Method.invoke之后，会直接去调MethodAccessor.invoke。MethodAccessor就是上面提到的所有同名method共享的一个实例，由ReflectionFactory创建。</li></ul><img src="/./res\image-20220818144823351.png" alt="image-20220818144823351" style="zoom:67%;"><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><ul><li>反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。</li><li>反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。</li><li>测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。</li></ul><p><strong>实例1 JDBC数据库连接</strong></p><p>在JDBC 的操作中，如果要想进行数据库的连接</p><ol><li><strong>通过<code>Class.forName()</code>加载数据库的驱动程序 （通过反射加载</strong>，前提是引入相关了Jar包）；</li><li>通过<code>DriverManager</code>类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码；</li><li>通过Connection 接口接收连接。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionJDBC</span> &#123;</span><br><span class="line">    <span class="comment">//驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBDRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="comment">//连接地址是由各个数据库生产商单独提供的，所以需要单独记住</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBURL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    <span class="comment">//连接数据库的用户名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBUSER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="comment">//连接数据库的密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBPASS</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//表示数据库的连接对象</span></span><br><span class="line">        Class.forName(DBDRIVER); <span class="comment">//1、使用CLASS 类加载驱动程序 ,反射机制的体现</span></span><br><span class="line">        con = DriverManager.getConnection(DBURL, DBUSER, DBPASS); <span class="comment">//2、连接数据库</span></span><br><span class="line">        System.out.println(con);</span><br><span class="line">        con.close(); <span class="comment">// 3、关闭数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实例2 JDK动态代理</strong></p><p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类中的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p><p>可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。获取到注解之后，就可以做进一步的处理。</p><p><strong>实例3 Spring 框架的使用</strong></p><p>Spring 通过 XML 配置模式装载 Bean 的过程：</p><ol><li>将程序内所有 XML 或 Properties 配置文件加载到内存中；</li><li>解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串及相关属性信息；</li><li><strong>利用反射机制，根据字节码字符串获得类的 Class 实例；</strong></li><li>动态配置 Class 实例的属性。</li></ol><p>Spring这样做的好处是：</p><ul><li>不用每一次都要在代码里面去new或者做其他的事情；</li><li>以后要改的话直接改配置文件，代码维护起来就很方便了；</li><li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annotation</code> 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量</p><p>注解本质<strong>是一个继承了 <code>Annotation</code> 的特殊接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以<strong>自定义注解</strong></p><h3 id="注解的类型"><a href="#注解的类型" class="headerlink" title="注解的类型"></a>注解的类型</h3><p>Java注解分类的话，大致可以分为三类，分别是标准注解，元注解与自定义注解。</p><h4 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h4><p>标准注解就是 java 内置的注解，主要有 @Override，@Deprecated，@SuppressWarnings，@FunctionalInterface</p><ul><li><p><strong>@Override：</strong>检查该注解标注的方法是否是重写方法，如果不是重写方法的话编译会不通过会报错。</p></li><li><p><strong>@Deprecated：</strong>标记该方法可能要废弃了，使用的话会报个警告。</p></li><li><p><strong>@SuppressWarnings：</strong>告诉编译器忽视一些警告。其常见的参数有：</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">deprecation</td><td align="center">使用了不赞成使用的类或方法的警告</td></tr><tr><td align="center">unchecked</td><td align="center">执行了未检查的转换时的警告，例如使用集合时没有用泛型来指定集合保存的类型</td></tr><tr><td align="center">fallthrough</td><td align="center">当switch程序块两个case之间没有break时</td></tr><tr><td align="center">path</td><td align="center">在类路径，源文件路径中有不存在的路径时的警告</td></tr><tr><td align="center">serial</td><td align="center">在可序列化的类上缺少serialVersionUID定义时的警告</td></tr><tr><td align="center">all</td><td align="center">所有的警告</td></tr></tbody></table></li><li><p><strong>@FunctionalInterface:</strong> 用于指示被修饰的接口是函数式接口，在 jdk8 被引入</p></li></ul><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>主要有 @Retention，@Documented，@Target，@Inherited，@Repeatable</p><ul><li><p><strong>@Retention：</strong>用来定义注解的生命周期，一个注解只能定义一个级别。具体有三个级别：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>SOURCE</td><td>在编译时被丢弃，不包含在类文件中，既不参与编译也不能在运行时被获取到</td></tr><tr><td>CLASS</td><td>JVM 加载时被丢弃，包含在类文件中，但是不能在运行时被获取到，默认值</td></tr><tr><td>RUNTIME</td><td>由 JVM 加载并包含在类文件中，能在运行时被获取到，一般开发自定义注解使用该级别</td></tr></tbody></table><p>三者是包含关系 source（javac编译时丢弃），class（.class被加载前丢弃），runtime（jvm会将其加载在类文件里）</p></li><li><p><strong>@Documented：</strong>被该元注解修饰的注解能出现在 javadoc 中，如果没有被该元注解修饰，则不会出现在 javadoc 中</p></li><li><p><strong>@Target：</strong>用来表示该注解的适用范围，一个注解可以有多个适用范围，每个使用范围之间在大括号内用逗号隔开。如：<br><code>@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</code><br>使用范围的值总共有十个：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">TYPE</td><td align="center">应用于类、接口(包括注解类型)或枚举</td></tr><tr><td align="center">FIELD</td><td align="center">应用于字段(包括枚举常量)</td></tr><tr><td align="center">METHOD</td><td align="center">应用于方法</td></tr><tr><td align="center">PARAMETER</td><td align="center">应用于方法的参数</td></tr><tr><td align="center">CONSTRUCTOR</td><td align="center">应用于构造函数</td></tr><tr><td align="center">LOCAL_VARIABLE</td><td align="center">应用于局部变量</td></tr><tr><td align="center">ANNOTATION_TYPE</td><td align="center">应用于注解</td></tr><tr><td align="center">PACKAGE</td><td align="center">应用于包</td></tr><tr><td align="center">TYPE_PARAMETER</td><td align="center">应用于类型参数，JDK1.8引入</td></tr><tr><td align="center">TYPE_USE</td><td align="center">应用于任何类型，JDK1.8引入</td></tr></tbody></table></li><li><p><strong>@Inherited：</strong>该注解说明子类可以继承父类的注解，被该元注解修饰的注解，能够在子类继承父类的时候把注解也继承过去。但是，被该元注解修饰的注解只有应用在类上的时候才能够被继承过去，应用在方法或其他地方时是没有的。</p></li><li><p><strong>@Repeatable：</strong>被该元注解修饰的注解能够重复使用，也就是可以在一个方法上使用多次该注解，可以说将该注解用一个数组容器包了起来。</p></li></ul><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解大致可以分为三步：1.定义注解，2.配置注解，3.解析注解</p><p><strong>定义注解 也就是声明一个注解，创建一个注解对象</strong></p><p>注解与方法、变量、枚举等声明方式相似，唯一不同的是其关键字为@interface，也就是只要是声明时使用了该关键字，底层在实现的时候都会继承java.lang.annotation.Annotation接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在注解的方法体里面只能写一个东西：注解类型元素，也就是注解的属性。其格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 数据类型 属性名() default 默认值;</span><br></pre></td></tr></table></figure><ul><li>其中修饰符必须是public，所以可以直接不写，其默认值即是public</li><li>其中可以写的数据类型有：八种基本类型(int，short，long，double，byte，char，boolean，float)，String，Class，注解类型，枚举类以及上面任一种类型的数组形式。</li><li>其中的属性名是自定义的</li><li>其中的()并不是定义参数的地方，只是一种语法而已</li></ul><p>default表示该属性的默认值，其默认值与前面的数据类型一致，有个要注意的点是如果没有设置默认值，则该注解在使用的时候一定要赋值。如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">@interface</span> LogAnnotation &#123;</span><br><span class="line">    <span class="comment">// 值描述</span></span><br><span class="line">    String <span class="built_in">value</span>() default &quot;&quot;;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    String <span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置注解-也就是对上面定义的注解配置其作用范围及生命周期</strong></p><p>配置注解则是利用上面记录的几种元注解对自定义的注解进行修饰，来描述自定义注解的生命周期与作用范围。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">    <span class="comment">// 值描述</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析注解-也就是在程序运行时检测注解，并进行一系列操作</strong></p><p>注解的解析主要是通过java的反射来实现的，可以通过反射来获取相应的类、方法或字段，通过获取的类、方法、字段来判断其上是否使用了该注解，使用的话则获取该注解与该注解内各个元素的值。例子如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mcj.music.<span class="keyword">annotation</span>;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line">    <span class="meta">@LogAnnotation(name = <span class="string">&quot;mcj&quot;</span>, value = <span class="string">&quot;10.09测试&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> void printString() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;输出一个字符串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;TestAnnotation&gt; testAnnotationClass = TestAnnotation.<span class="keyword">class</span>;</span><br><span class="line">        Method[] methods = testAnnotationClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(LogAnnotation.<span class="keyword">class</span>)) &#123;</span><br><span class="line">                LogAnnotation <span class="keyword">annotation</span> = method.getAnnotation(LogAnnotation.<span class="keyword">class</span>);</span><br><span class="line">                String name = <span class="keyword">annotation</span>.name();</span><br><span class="line">                String value = <span class="keyword">annotation</span>.value();</span><br><span class="line">                System.<span class="keyword">out</span>.println(String.format(<span class="string">&quot;方法%s用了LogAnnotation注解，注解值name为：%s，value为：%s&quot;</span>, method.getName(), name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的解析方法"><a href="#注解的解析方法" class="headerlink" title="注解的解析方法"></a>注解的解析方法</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者网络传输 Java 对象，都需要用到序列化。</p><ul><li><strong>序列化</strong>： 序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</li><li><strong>反序列化</strong>：将在序列化过程中生成的二进制字节流转换成对象的过程</li></ul><p>核心作用是<strong>对象状态的保存与重建</strong>。Java对象保存在 JVM 堆内存中，如果 JVM 堆不存在了，对象也就跟着消失了。</p><h3 id="Java-IO流分类"><a href="#Java-IO流分类" class="headerlink" title="Java IO流分类"></a>Java IO流分类</h3><ul><li><p>按照流的方向：输入流（inputStream）和输出流（outputStream）；</p></li><li><p>按照处理数据的单位： <strong>字节流和字符流</strong>。</p></li><li><p>按照实现功能分：<strong>节点流</strong>（可以从或向一个特定的地方读写数据，如 FileReader）和<strong>处理流</strong>（是对一个已存在的流的连接和封装，通过封装的流的功能实现读写， 如BufferedReader，<strong>处理流的构造方法总是要带一个其他的流对象做参数</strong>。一个流对象经过其他流的多次包装，称为流的链接。）</p></li></ul><p>Java IO 流的 40 多个类都是从如下 <strong>4 个抽象类基类</strong>中派生出来的。</p><ul><li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是<strong>字节输入流</strong>，后者是<strong>字符输入流</strong>。</li><li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是<strong>字节输出流</strong>，后者是<strong>字符输出流</strong>。</li></ul><h4 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h4><ul><li><p><strong>字节流</strong>：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节</strong></p></li><li><p><strong>字符流</strong>：如果我们不知道编码类型的话，使用字节流很容易出现乱码问题，所以就需要字符流。但是<strong>字符流</strong>是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</p></li></ul><p><strong>区别</strong></p><ul><li><strong>字节</strong>流操作的基本单位是<strong>字节</strong>，<strong>字符流</strong>操作的基本单位是<strong>字符</strong>(2个字节)</li><li><strong>字节流</strong>通常用于<strong>处理二进制数据</strong>，<strong>字符流</strong>通常<strong>处理文本数据</strong>。</li><li><strong>字符流处理文本</strong>要比字节流处理文本<strong>要方便</strong>。</li><li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择<strong>字符流</strong>。只是读写文件，和文件内容无关时，一般选择<strong>字节流</strong>。</li></ul><p><strong>转换方式：</strong></p><ul><li>字节输入流转字符输入流通过<code>InputStreamReader</code> 实现，该类的构造函数可以传入 <code>InputStream</code> 对象。</li><li>字节输出流转字符输出流通过 <code>OutputStreamWriter</code> 实现，该类的构造函数可以传入 <code>OutputStream</code> 对象。</li></ul><h3 id="Java-IO的设计模式"><a href="#Java-IO的设计模式" class="headerlink" title="Java IO的设计模式"></a>Java IO的设计模式</h3><p><strong>装饰器模式</strong>：在不改变原有对象的情况下拓展其功能，比如使用 <code> BufferedInputStream</code> (字节缓冲输入流) 来增强 <code>FileInputStream </code>。</p><p><strong>适配器模式</strong>：用于接口互不兼容的类的协调工作，比如 <code>InputStreamReader</code> 和 <code>InputStream</code>。IO 流中的字符流和字节流的接口不同，它们之间的协调工作就是基于适配器模式的。通过适配器，可以将字节流对象适配成一个字符流对象。</p><h3 id="Java-IO分类"><a href="#Java-IO分类" class="headerlink" title="Java IO分类"></a>Java IO分类</h3><img src="/./res\33b193457c928ae02217480f994814b6.png" alt="img" style="zoom: 50%;"><h4 id="BIO（Blocking-IO）"><a href="#BIO（Blocking-IO）" class="headerlink" title="BIO（Blocking IO）"></a>BIO（Blocking IO）</h4><p><strong>BIO 属于同步阻塞 IO 模型</strong>。<code>InputStream</code>&#x2F;<code>Reader</code> 和 <code>OutputStream</code>&#x2F;<code>Writer</code> 都属于 BIO。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。在客户端连接数量不高的情况下是没问题的。但是面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p><h4 id="NIO（Non-Blocking-IO）"><a href="#NIO（Non-Blocking-IO）" class="headerlink" title="NIO（Non-Blocking IO）"></a>NIO（Non-Blocking IO）</h4><p>NIO 是面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。</p><h4 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h4><p>AIO 是 NIO 的改进版，是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，应用操作之后会直接返回，不会堵塞。当后台处理完成后，操作系统会通知相应的线程进行后续操作。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p>对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><ul><li><code>List</code>: 存储的元素是有序的、可重复的。</li><li><code>Set</code>: 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>: 存储键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</li></ul><h3 id="底层数据结构总结"><a href="#底层数据结构总结" class="headerlink" title="底层数据结构总结"></a>底层数据结构总结</h3><p><code>Collection</code> 接口下面的集合</p><p><strong>List</strong></p><ul><li><code>ArrayList</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><p><strong>Set</strong></p><ul><li><code>HashSet</code>: 基于 <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，内部基于 <code>LinkedHashMap</code> 实现。</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><p><strong>Queue</strong></p><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现<strong>二叉堆</strong></li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p><code>Map</code> 接口下面的集合。</p><p><strong>Map</strong></p><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组 + 链表组成的，数组是 <code>HashMap</code> 的主体，链表是为了解决哈希冲突问题。JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，会将链表转化为红黑树，以减少搜索时间</strong>。链表在转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，它的底层也是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表是为了解决哈希冲突问题。</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><code>ArrayList</code> 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，可以使用 <code>ensureCapacity</code> 操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><p><code>ArrayList</code> 继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个接口的 List 集合是支持<strong>快速随机访问</strong>的，即可以通过元素的序号快速获取元素对象。</li><li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。(<strong>浅拷贝</strong>)</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输。</li></ul><h5 id="ArrayList-构造函数"><a href="#ArrayList-构造函数" class="headerlink" title="ArrayList 构造函数"></a>ArrayList 构造函数</h5><ul><li><strong>空参构造器：</strong>初始化一个空数组</li><li><strong>指定容量：</strong>如果容量大于 0，则初始化一个指定容量的对象数组，如果为 0 则初始化一个空数组，如果小于 0 则抛出异常</li><li><strong>指定 Collection</strong>：将指定 Collection 中的元素按照迭代器的顺序转为对象数组，并赋给原数组</li></ul><h5 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h5><p><a href="https://www.cnblogs.com/ruoli-0/p/13714389.html">浅谈 ArrayList 及其扩容机制 (cnblogs.com)</a></p><p><strong>第一种情况，当 ArrayList 的容量为 0 时，此时添加元素的话，需要扩容，三种构造方法创建的 ArrayList 在扩容时略有不同：</strong></p><p>​1.<strong>无参构造</strong>，创建 ArrayList 后容量为 0，添加第一个元素后，容量变为 10，此后若需要扩容，则正常扩容。</p><p>​2.<strong>传容量构造</strong>，当参数为 0 时，创建 ArrayList 后容量为 0，添加第一个元素后，容量为 1，此时 ArrayList 是满的，下次添加元素时需正常扩容。</p><p>​3.<strong>传 Collection 构造</strong>，当 Collection 为空时，创建 ArrayList 后容量为 0，添加第一个元素后，容量为 1，此时 ArrayList 是满的，下次添加元素时需正常扩容。</p><p><strong>第二种情况，当 ArrayList 的容量大于 0，且 ArrayList 已满，此时添加元素的话，进行正常扩容，每次扩容到原来的 1.5 倍。</strong></p><h5 id="ArrayList-的序列化"><a href="#ArrayList-的序列化" class="headerlink" title="ArrayList 的序列化"></a>ArrayList 的序列化</h5><p>序列化一个对象时，被 <strong>transient</strong> 关键字修饰的变量(的值)不会被序列化。</p><p><strong>ArrayList 的序列化机制：</strong></p><ol><li><p>ArrayList 实现了 java.io.Serializable 接口。</p></li><li><p>ArrayList 中存放集合元素的 Object 数组被关键字 transient 修饰。代码：transient Object[] elementData;</p></li><li><p>ArrayList 序列化集合元素的机制：</p></li></ol><ul><li>ArrayList 在序列化时会调用 <code>writeObject(ObjectOutputStream s)</code> 方法，将 size 和 element 写入 <code>ObjectOutputStream</code> 中；</li><li>ArrayList 在反序列化时调用 <code>readObject(ObjectInputStream s)</code> 方法，从 <code>ObjectInputStream</code> 中获取到 size 和 element，再恢复到存储集合元素的 Object 数组中。</li></ul><p><strong>与直接序列化 Object 数组相比，这样的机制有什么优点呢？</strong></p><p>Object 数组通常会预留一些容量，有些空间 (elementData[size] ~ elementData[elementData.length-1]) 并没有存储元素(存的是 null)；</p><p>ArrayList 的序列化机制<strong>只序列化实际存储的集合元素，而不是实例化整个 Object 数组，可以节省空间和时间。</strong></p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p><h5 id="LinkedList-和-ArrayList-的区别"><a href="#LinkedList-和-ArrayList-的区别" class="headerlink" title="LinkedList 和 ArrayList 的区别"></a>LinkedList 和 ArrayList 的区别</h5><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong>（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以插入和删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(i))</code>因为需要先移动到指定位置再插入。</strong></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持，而 <strong><code>ArrayList</code> 支持</strong>。快速随机访问就是通过元素的序号快速获取元素对象。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在 Object 数组会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[]</code>存储</p><p>随着 Java 并发编程的发展，<code>Vector</code> 已经被淘汰，推荐使用并发集合类如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等或者手动实现线程安全。</p><h5 id="Vector-和-ArrayList-的区别"><a href="#Vector-和-ArrayList-的区别" class="headerlink" title="Vector 和 ArrayList 的区别"></a>Vector 和 ArrayList 的区别</h5><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，线程不安全 。</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><strong>底层数据结构</strong>：哈希表（基于 <code>HashMap</code> 实现）</p><p><strong>元素：</strong>无序的，不重复的，无索引的</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p><strong>底层数据结构</strong>：链表和哈希表。元素的插入和取出顺序满足 FIFO。LinkedHashSet 继承于 HashSet，其所有的方法都与 HashSet 相同</p><p><strong>元素：</strong>无序的，不重复，无索引的</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p><strong>底层数据结构</strong>：二叉树（红黑树）, TreeSet 中的数据是自动排好序的，不允许放入 null 值。</p><p><strong>元素：</strong>有序的，不重复，无索引的</p><h4 id="无序性和不可重复性"><a href="#无序性和不可重复性" class="headerlink" title="无序性和不可重复性"></a>无序性和不可重复性</h4><ul><li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li><li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li></ul><h4 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于需要保证元素的插入和取出顺序的场景，<code>TreeSet</code> 用于需要对元素排序的场景。</li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，<strong>因为容量问题导致操作失败后有两种处理方式</strong> : 一种会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><p><code>Deque</code> 的实现类有 <code>LinkedList</code> 和<code>ArrayDeque</code> </p><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而 <code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code>（阻塞队列）是一个接口，继承自 <code>Queue</code>。当队列没有元素时 <code>BlockingQueue</code> 会一直阻塞，直到有元素；如果队列已满，会等到队列可以放入元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><p>Java 中常用的阻塞队列实现类有以下几种：</p><ol><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，支持公平锁和非公平锁两种访问机制。</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的阻塞队列。在创建时可以指定容量大小，如果不指定则默认为 <code>Integer.MAX_VALUE</code>。也支持公平锁和非公平锁两种访问机制。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现 <code>Comparable</code> 接口或者在构造函数中传入 <code>Comparator</code> 对象，且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code> 通常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，延迟队列中的元素只有到了指定的延迟时间后才能够从队列中出队。</li></ol><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，优先级高的元素先出队。</p><ul><li><code>PriorityQueue</code> 基于二叉堆实现，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了 O(logn) 时间复杂度内的插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，也可以接收一个 <code>Comparator</code> 作为构造参数，从而自定义元素优先级。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap 主要用来存放键值对，是<strong>非线程安全的</strong>。<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。</p><h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><ul><li><p>JDK1.8 之前 HashMap 由 <strong>数组 + 链表</strong> 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 </p></li><li><p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当<strong>链表长度大于阈值（默认为 8）时</strong>，如果当前数组的长度小于 64，会选择进行数组扩容，否则就会将链表转化为<strong>红黑树</strong>，以减少搜索时间。</p></li></ul><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a><strong>基本属性</strong></h5><ul><li>初始容量 16，最大容量 2 的 30 次方</li><li>加载因子默认为 0.75。加载因子控制数组存放数据的疏密程度，loadFactor 越大，数组中存放的数据就越多越密；loadFactor 越小，数组中存放的数据就越少越稀疏。<strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</li><li>链表转红黑树链表长度阈值为 8，数组长度阈值为 64；红黑树转链表阈值为 6</li><li>扩容阈值：<strong>数组大小 * 加载因子</strong></li></ul><h5 id="put-原理"><a href="#put-原理" class="headerlink" title="put()原理"></a>put()原理</h5><ul><li><p>如果 table 未初始化或者长度为 0，先进行 resize() 扩容</p></li><li><p>先根据 key 的值计算 hash 值，再根据 hash 值计算当前元素要插入的数组下标</p><ul><li>如果定位到的数组位置<strong>没有元素</strong>就直接插入，<strong>插入完毕判断当前数组的实际大小是否大于阈值，决定是否需要扩容</strong></li><li>如果定位到的数组位置<strong>有元素</strong>，先判断数据的存储结构：<ul><li>如果为树结构，就调用树的 put 方法进行<strong>插入或覆盖</strong></li><li>如果是链表结构，就从头结点开始遍历链表，对当前元素进行<strong>插入或覆盖</strong>；插入完毕判断链表的长度是否大于等于 8，如果是就将调用 <code>treeifyBin </code> 方法将链表转化为红黑树</li></ul></li><li>如果定位到的数组下标处有元素，在插入或覆盖后不需要进行数组扩容判断</li></ul></li><li><p>在 1.7 之前插入元素采用的是头插法</p></li></ul><h5 id="resize-扩容机制"><a href="#resize-扩容机制" class="headerlink" title="resize() 扩容机制"></a>resize() 扩容机制</h5><p>HashMap 的容量超过负载因子规定的容量之后就会扩容，将大小扩大为原数组的两倍，并将原对象放入新数组中。</p><ul><li>如果使用<strong>空参构造器</strong>，实例化的 HashMap 内部数组为 null，当第一次调用 put 方法时进行初始化扩容，初始容量为16。</li><li>如果使用<strong>有参构造器</strong>指定了初始容量，会找到不小于指定容量的 2 的幂数，并将该数赋给阈值，当第一次调用 put 方法时再将阈值赋值给容量。</li><li>再后续的 put 操作中，如果<strong>数组实际大小大于阈值</strong>就需要进行扩容，创建一个容量为<strong>原容量 2 倍</strong>的新数组，并将原数组的数据重新分配到新数组上。</li><li>由于数组的容量发生改变，导致元素的 hash 值发生变化，从而达到将长链表转为短链表的目的。数据的重新分配过程类似于反转链表。</li></ul><p><strong>“拉链法”</strong> ：将链表和数组相结合。创建一个链表数组，数组中每一格就是一个链表。如果遇到哈希冲突，将冲突的值加到链表中即可。</p><p><img src="/.%5Cres%5Cjdk1.7_hashmap.png"></p><p><strong>JDK1.8 之后</strong></p><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/.%5Cres%5Cjdk1.8_hashmap.png"></p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树是为了解决二叉查找树的缺陷，二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h5 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h5><ul><li><strong>加快哈希计算：</strong>根据 key 得到的 hash 值是一个整数，为了找到 key 在当前哈希表中的位置，需要计算hash % n（n为数组长度）。但是 <strong>% 计算比 &amp; 运算慢很多</strong>，当 n 为 2 的幂次方时，hash &amp; (n - 1) &#x3D; hash % n，加快了哈希计算</li><li><strong>可以减少哈希冲突：</strong>n为偶数时，n - 1为奇数，hash &amp; (n - 1)运算后的结果可能是奇数也可能是偶数，保证了散列的均匀性；当 n 为奇数时，n - 1为偶数，hash &amp; (n - 1)运算后的结果只能是偶数，那么任何 hash 值都会被散列到数组的偶数下标位置，浪费了一半的空间，增加了哈希冲突的概率。</li></ul><h5 id="扩容后的数据迁移"><a href="#扩容后的数据迁移" class="headerlink" title="扩容后的数据迁移"></a>扩容后的数据迁移</h5><p><strong>1.7</strong></p><ul><li>遍历旧数组取得每个 entry 上的链表，并将旧数组的引用设为 null</li><li>重新计算链表上的元素在新数组中的位置并插入</li><li>采用<strong>头插法</strong>将元素插入到新数组中</li></ul><p><strong>1.8</strong></p><p>扩容后不需要重新计算元素的 hash 值，而是将<strong>原先的 hash 值与旧数组的长度（oldCap）进行”与”操作</strong>。</p><ul><li>如果结果为 0 那么当前元素的桶位置不变</li><li>如果结果为 1 那么桶位置就是原位置 + 原数组长度 oldCap</li><li>如果发生 hash 冲突采用<strong>尾插法</strong></li></ul><h5 id="hashcode-、hash-与下标计算"><a href="#hashcode-、hash-与下标计算" class="headerlink" title="hashcode()、hash()与下标计算"></a>hashcode()、hash()与下标计算</h5><ol><li><p>计算key的hashcode()</p></li><li><p>使用hashcode计算当前对象的hash值</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为什么需要让高 16 位参与异或运算：当数组的长度很短时，只有低位数的 hashcode 值能参与运算，让高 16 位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率。并且使得高16位和低16位的信息都被保留了。</p><ol start="3"><li>通过<code>(n - 1) &amp; hash</code>计算下标：在数组长度为 <strong>2 的次幂</strong>的情况下，(n <strong>- 1</strong>) &amp; hash的值与 hash % n 的值相同，但是 &amp; 运算的数据比取余快得多，<strong>n 是数组长度</strong></li></ol><h5 id="解决-hash-冲突"><a href="#解决-hash-冲突" class="headerlink" title="解决 hash 冲突"></a>解决 hash 冲突</h5><ul><li><strong>拉链法：</strong>哈希值相同的元素构成一个单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除在链表中进行。</li><li><strong>开放地址法：</strong>也称为再散列法，在插入元素时如果发生了哈希冲突，就以当前地址为基址，再次进行哈希计算，直到找到一个不冲突的哈希地址。</li><li><strong>再哈希法：</strong>提供多个不同的 hash 函数，当第一个哈希函数发生冲突时，再计算第二个，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li><li><strong>建立公共溢出区：</strong>将哈希表分为公共区和溢出区，溢出发生时，将溢出数据统一放到溢出区。</li></ul><h5 id="为什么在解决-hash-冲突的时候，不直接用红黑树？"><a href="#为什么在解决-hash-冲突的时候，不直接用红黑树？" class="headerlink" title="为什么在解决 hash 冲突的时候，不直接用红黑树？"></a>为什么在解决 hash 冲突的时候，不直接用红黑树？</h5><p>先用链表，再转红黑树?<br>当元素小于 8 个时，链表结构能保证查询性能。当元素大于 8 个时， 红黑树查询的时间复杂度是 O(logn)，而链表是 O(n)，就需要用红黑树来加快查询速度，不过新增节点的效率会变低，因为红黑树需要左旋，右旋，变色这些操作来保持平衡。<strong>如果一开始就用红黑树，元素太少，新增效率又低</strong>，很<strong>浪费性能</strong>。</p><h5 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h5><p>并发下的 Rehash 会造成元素之间形成循环链表导致死循环。因此并发环境下推荐使用 ConcurrentHashMap </p><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ul><li><strong>线程安全：</strong>HashMap 线程不安全，<strong>HashTable 线程安全</strong>。如果要保证线程安全的话建议使用 CurrentHashMap，HashTable 基本被淘汰了。</li><li><strong>效率：</strong>HashMap 不加锁，效率比 HashTable 要高。</li><li><strong>对Null key 和Null value的支持：</strong>HashMap支持存储null的key和value，但是null作为键只能有一个，null作为值可以有多个；HashTable不允许有null键和null值，会抛出<code>NullPointerException</code></li><li><strong>底层数据结构：</strong>HashMap在1.8之后为数组+链表+红黑树，而HashTable为数组+链表</li><li><strong>初始容量和扩容机制：</strong>HashMap的初始容量为16，每次扩容为原来的2倍；HashTable的初始容量为11，每次扩容为原来的2n+1；</li><li>HashTable 继承自 Dictionary 类，HashMap继承自 AbstractMap类。</li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 和 HashMap 都继承自 AbstractMap ，TreeMap 还实现了 NavigableMap 接口和 SortedMap 接口。</p><p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素搜索的能力。</p><p><strong>实现 SortedMap 接口让 TreeMap 有了对集合中的元素根据键排序的能力</strong>。默认按 key 的升序排序，也可以指定排序的比较器。</p><p>综上，相比于 HashMap 来说， TreeMap 多了对集合中的<strong>元素根据键排序的能力</strong>以及<strong>对集合内元素搜索的能力</strong>。</p><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>JDK 提供的并发容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong>ConcurrentHashMap</strong> : 线程安全的 <code>HashMap</code></li><li><strong>CopyOnWriteArrayList</strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li><li><strong>ConcurrentLinkedQueue</strong> : 可以看做一个线程安全的 <code>LinkedList</code>，底层使用链表实现，是非阻塞队列。<strong>使用 CAS 非阻塞算法实现线程安全</strong>。</li><li><strong>BlockingQueue</strong> : 阻塞队列，<strong>适合用于作为数据共享的通道</strong>。</li><li><strong>ConcurrentSkipListMap</strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p><strong>JDK1.7</strong>：</p><ul><li><code>ConcurrnetHashMap</code> 将数据分为一段一段存储，每一段就是一个 <code>Segment</code>，每一个 <code>Segment</code> 都有一把锁 ，<code>Segment</code> 继承了 <code>ReentrantLock</code>，是一种可重入锁；一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，<code>HashEntry </code> 是链表结构的元素，对 <code>HashEntry</code> 数组的元素进行修改时，必须先获得对应 <code>Segment</code> 的锁。</li><li><code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认为16 ，可以认为 <code>ConcurrentHashMap</code> 默认最多支持 16 个线程并发。</li></ul><p><strong>JDK1.8：</strong> </p><p> JDK1.8 中的 <code>ConcurrnetHashMap</code> 的结构是 <strong>Node 数组 + 链表&#x2F;红黑树</strong>，当链表达到一定长度时就会转化为红黑树；</p><p>在锁的实现上，抛弃了原有的 Segment 分段锁，采用 CAS + synchronized 将锁的级别控制在了更低粒度的哈希桶元素级别，即<strong>只锁住链表头结点（红黑树的根节点）</strong>，不会影响其他的哈希桶元素的读写，大大提高了并发度。</p><h5 id="基本属性-1"><a href="#基本属性-1" class="headerlink" title="基本属性"></a>基本属性</h5><ul><li><p><strong>Node&lt;K,V&gt;[] table</strong>：底层的node数组，默认初始容量16，默认负载因子0.75，最大的容量2的30次方</p></li><li><p><strong>Node&lt;K,V&gt;[] nextTable</strong>： 用于哈希表扩容，扩容完成后会被重置为 null，也是Node类型。</p></li><li><p><strong>sizeCtl</strong>：</p><ul><li>默认为0，用来控制table的初始化和扩容操作</li><li><strong>-1</strong>：代表table正在初始化</li><li><strong>-N</strong>：表示有N-1个线程正在进行扩容操作</li><li><strong>大于0且table未初始化</strong>：表示table的初始化容量大小</li><li><strong>大于0且以初始化</strong>：表示下次扩容的阈值</li></ul></li><li><p><strong>baseCount</strong>：用于存储整个哈希表中结点的个数总和</p></li><li><p><strong>核心常量：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//ConcurrentHashMap的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;<span class="comment">//默认容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;<span class="comment">//默认的最大并发等级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;<span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">//链表升级成红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">//红黑树退化成链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;<span class="comment">//链表升级成红黑树需要满足的最小容量，若不满足，则会先扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;<span class="comment">//最小转移步长</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li>如果是空参构造，参数采用默认值。</li><li>如果是有参构造，初始容量设为不小于指定容量的2的幂数，并赋给sizeCtl。</li><li>无论有参无参，ConcurrentHashMap 实例化时其内部的 Node 数组都没有初始化，只有在第一次put时才会初始化。</li></ul><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><ul><li><strong>1.7</strong><ul><li>首先会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，改为阻塞获取锁。</li><li>获取到锁后计算数据要放入的位置，获取这个位置上的 HashEntry。</li><li>此时会存在两种情况，HashEntry 存在或者不存在<ul><li>如果 HashEntry 不存在，判断当前容量是否大于阈值，大于就先进行扩容，然后使用头插法插入。</li><li>如果 HashEntry 存在，就遍历链表，如果链表中有相同的元素则覆盖，否则使用头插法插入。</li></ul></li></ul></li><li><strong>1.8</strong><ul><li>计算当前 key 的 hashcode，判断 table 是否已经初始化，如果没有就调用 initTable() 进行初始化。</li><li>如果当前 key 对应的 Node 为空，则利用 CAS 写入数据，失败则自旋保证成功，成功了就 break 跳出。</li><li>如果当前 key 对应的 Node 的 <code>hashcode == MOVED == -1</code> , 则需要进行扩容。</li><li>以上都不满足说明当前 key 对应的 Node 存在链表&#x2F;红黑树，则利用 synchronized 锁往链表&#x2F;红黑树再写入数据。</li><li>如果当前为链表，当链表长度大于 <code>TREEIFY_THRESHOLD </code>且数组长度≥64时，就调用 treeifyBin 方法将链表转换为红黑树。</li></ul></li></ul><h5 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h5><ol><li><p>当 key 为 String，value 为 ArrayList 的情况下，多线程并发向 ArrayList 中加入数据，可能出现数据丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1进行add时发现ArrayList为null，则进行初始化</span></span><br><span class="line"><span class="comment">//线程1还未初始化完毕，切换到线程2执行，此时ArrayList还是null，线程2同样进行初始化</span></span><br><span class="line"><span class="comment">//最终初始化了两个ArrayList，并分别执行add操作，导致某一个线程的数据丢失</span></span><br><span class="line">map.put(key,getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(word));</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong>采用原子方法如 <code>computeIfAbsent</code>，以原子的方式进行初始化操作。</p></li></ol><h5 id="ConcurrentHashMap-和-Hashtable"><a href="#ConcurrentHashMap-和-Hashtable" class="headerlink" title="ConcurrentHashMap 和 Hashtable"></a>ConcurrentHashMap 和 Hashtable</h5><ul><li><code>HashTable</code>：<code>Hashtable</code> 采用 <strong>数组 + 链表</strong> 的形式，使用 <code>synchronized</code> 对整个哈希表加锁，多线程访问时，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待锁被释放；</li></ul><p>ConcurrentHashMap 的效率要高于 <strong>Hashtable</strong>，因为 Hashtable 给整个哈希表加了一把大锁来实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用<strong>分段锁</strong>实现线程安全，在 JDK1.8 中采用 <strong>CAS + Synchronized</strong> 实现线程安全。</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul><li><strong>介绍：</strong>CopyOnWriteArrayList 在读的时候不加锁，在写的时候加锁，实现了读读、读写的兼容，只有写写是互斥的。</li><li><strong>读操作：</strong>读取时没有任何同步控制和锁操作，因为内部 <code>array</code> 数组不会发生修改，可以保证数据安全。</li><li><strong>写操作：</strong><ul><li><strong>原理</strong>：所有的写操作都是<strong>通过创建底层数组的副本来实现</strong>的，即修改 list 时<strong>不修改原数组</strong>，而是<strong>复制原数组，将修改的内容写入副本中 ，然后再用副本替换原数组</strong>，这样就可以保证写操作不会影响读操作。</li><li><strong>底层实现：</strong>底层通过 ReentrantLock 对写方法加锁，避免多线程写的时候 copy 出多个副本，造成写操作丢失。</li></ul></li></ul><h4 id="BlockingQueue-1"><a href="#BlockingQueue-1" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><ul><li><p><strong>介绍：</strong>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”模型中，因为 <code>BlockingQueue</code> 提供了可阻塞的插入和删除方法。当容器已满，生产者线程会被阻塞，直到队列未满时继续生产；当容器为空时，消费者线程会被阻塞，直至队列非空时继续消费。BlockingQueue 是一个接口，继承自 Queue，主要实现类如下：</p></li><li><p><strong>ArrayBlockingQueue</strong></p><ol><li>ArrayBlockingQueue 是使用数组实现的有界阻塞队列。</li><li>ArrayBlockingQueue 一旦创建，容量不能改变。</li><li>并发控制采用可重入锁 ReentrantLock ，插入和读取操作都需要获取到锁。</li></ol></li><li><p><strong>LinkedBlockingQueue</strong></p><ol><li>LinkedBlockingQueue 是使用链表实现的阻塞队列，满足 FIFO 特性。</li><li>可以是无界队列也可以是有界队列，吞吐量比 ArrayBlockingQueue 更高。</li><li>可以在构造函数中传入 <code>capacity</code> 指定队列最大容量，<strong>如果未指定，容量等于 <code>Integer.MAX_VALUE</code></strong></li></ol></li><li><p><strong>PriorityBlockingQueue</strong></p><ol><li>PriorityBlockingQueue 是支持优先级排序的无界阻塞队列，是 PriorityQueue 的线程安全版本。<strong>不可以插入 null 值，且插入队列的对象必须实现 <code>Comparable</code> 接口或者在构造函数中传入 <code>Comparator</code> 对象</strong>。默认情况下采用自然排序，也可以自定义排序规则。</li><li><code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素时<strong>如果空间不够会自动扩容</strong>。</li><li>并发控制采用的是可重入锁 <code>ReentrantLock</code>。</li></ol></li><li><p><strong>DelayQueue</strong><br>DelayQueue 是支持延时获取元素的无界阻塞队列，基于 PriorityQueue 实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定延迟时间，延迟队列中的元素只有到了指定的延迟时间后才能从队列中出队。</p><p>适用场景：缓存系统的设计：用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦从 DelayQueue 中获取到元素，就表示缓存有效期到了。<br>定时任务调度：用 DelayQueue 保存当天要执行的任务和执行时间，使用一个线程循环查询 DelayQueue，一旦从 DelayQueue 中获取到任务就开始执行。<br>原文链接：<a href="https://blog.csdn.net/weixin_39723544/article/details/87188696">https://blog.csdn.net/weixin_39723544/article/details/87188696</a></p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="并发编程三个特性"><a href="#并发编程三个特性" class="headerlink" title="并发编程三个特性"></a>并发编程三个特性</h4><p><strong>原子性</strong></p><p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</p><p>可以借助 <code>synchronized</code>、各种 <code>Lock</code> 以及原子类实现原子性。</p><p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任意时刻只有一个线程访问该代码块，因此可以保障原子性。原子类是利用 CAS 操作（可能也会用到 <code>volatile</code> 或者 <code>final</code> 关键字）来保证原子操作。</p><p><strong>可见性</strong></p><p>如果一个线程修改了共享变量，那么其它线程可以立即看到最新值。</p><p>可以借助 <code>synchronized</code>、各种 <code>Lock</code> 以及 <code>volatile</code> 实现可见性。</p><p>如果将变量声明为 <code>volatile</code> ，这就指示 JVM 这个变量是共享且不稳定的，每次使用前都要从主存中读取。</p><p><strong>有序性</strong></p><p>由于指令重排序，代码的执行顺序未必就是代码的编写顺序。</p><blockquote><p><strong>指令重排序可以保证串行语义一致，但是无法保证多线程间的语义一致</strong> ，因此在多线程下，指令重排序可能会导致一些问题。</p></blockquote><p><code>volatile</code> 关键字可以禁止指令进行重排序优化。</p><h4 id="Java中的线程状态"><a href="#Java中的线程状态" class="headerlink" title="Java中的线程状态"></a>Java中的线程状态</h4><img src="/./res\线程.png" style="zoom: 67%;"><ol><li>**初始(NEW)**：创建一个新的线程对象，还没有调用 start() 方法。</li><li><strong>运行(RUNNABLE)<strong>：Java 线程中将</strong>就绪（ready）</strong>和<strong>运行中（running）</strong>两种状态统称为“运行”。</li><li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li><li>**等待(WAITING)**：进入该状态的线程需要依靠其他线程的通知才能返回运行状态。</li><li>**超时等待(TIMED_WAITING)**：该状态不同于 WAITING，它可以在指定的时间后自行返回。</li><li>**终止(TERMINATED)**：表示该线程已执行完毕。</li></ol><blockquote><p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态 。</p><p><strong>为什么 JVM 没有区分这两种状态呢？</strong> </p><p>现在的时分多任务操作系统架构通常是用“时间分片”的方式进行抢占式轮转调度。时间分片通常很小，一个线程一次最多只能在 CPU 上运行 10 - 20 ms 的时间（running 状态），然后就会被放入调度队列的末尾等待再次调度（ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p></blockquote><ul><li>线程创建之后处于 <strong>NEW（新建）</strong> 状态。</li><li>调用 <code>start()</code> 方法后线程处于 <strong>READY（可运行）</strong> 状态。READY状态的线程获得 CPU 时间片后处于 <strong>RUNNING（运行）</strong> 状态。</li><li>线程调用 <code>wait()</code>方法后会进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能返回运行状态。</li><li>调用 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法后线程处于 <strong>TIMED_WAITING 状态</strong>。进入TIMED_WAITING 状态的线程经过指定的时间后会返回 RUNNABLE 状态。</li><li>当线程进入 <code>synchronized</code> 方法块或者调用 <code>wait</code> 方法后被 <code>notify</code>唤醒然后重新进入 <code>synchronized</code> 方法块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li><li>线程执行完 <code>run()</code>方法后会进入 <strong>TERMINATED（终止）</strong> 状态。</li></ul><h4 id="Java中的线程上下文切换"><a href="#Java中的线程上下文切换" class="headerlink" title="Java中的线程上下文切换"></a>Java中的线程上下文切换</h4><p>线程在执行过程中有自己的<strong>运行条件和状态</strong>（<strong>上下文</strong>），比如程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，调用了 <code>sleep()</code>, <code>wait()</code> 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU导致其他线程或者进程饿死。</li><li>调用阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行。</li></ul><p>前三种都会发生线程切换，线程切换意味着需要<strong>保存当前线程的上下文，等线程下次占用 CPU 时恢复现场，同时加载下一个将要占用 CPU 的线程上下文</strong>。这就是 <strong>上下文切换</strong>。</p><p>上下文切换是现代操作系统的基本功能，因为上下文切换需要保存信息恢复信息，所以会占用 CPU、内存等系统资源，如果频繁切换会造成整体效率低下。</p><h4 id="Java中的死锁"><a href="#Java中的死锁" class="headerlink" title="Java中的死锁"></a>Java中的死锁</h4><h5 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure><p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><h5 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h5><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ol><li>互斥条件：该资源任意时刻只能由一个线程占用。</li><li>请求与保持条件：线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不可剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：线程间形成一种头尾相接的循环等待资源关系。</li></ol><h5 id="死锁预防和避免"><a href="#死锁预防和避免" class="headerlink" title="死锁预防和避免"></a><strong>死锁预防和避免</strong></h5><p>只要破坏产生死锁的四个条件中的其中一个就可以了</p><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不可剥夺条件</strong> ：线程进一步申请其他资源时，如果申请不到，可以主动释放占有的资源。</li><li><strong>破坏循环等待条件</strong> ：按某一顺序申请资源，释放资源则反序释放。</li><li><strong>锁排序法</strong>：指定锁的获取顺序，比如规定只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁。这是解决死锁很好的一种方法。</li><li>使用显式锁中的 ReentrantLock.try(long TimeUnit) 来申请锁，相当于存入超时时间</li></ol><p>互斥条件没法破坏，因为使用锁本来就是想让资源互斥访问。</p><h4 id="线程创建的三种方式"><a href="#线程创建的三种方式" class="headerlink" title="线程创建的三种方式"></a>线程创建的三种方式</h4><h5 id="实现-Runnable-或-Callable-接口"><a href="#实现-Runnable-或-Callable-接口" class="headerlink" title="实现 Runnable 或 Callable 接口"></a>实现 Runnable 或 Callable 接口</h5><p>可以创建一个实现了 Runnable 或 Callable 接口的实现类或者匿名类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h5 id="继承-Thread-类并重写-Run-方法"><a href="#继承-Thread-类并重写-Run-方法" class="headerlink" title="继承 Thread 类并重写 Run 方法"></a>继承 Thread 类并重写 Run 方法</h5><p>可以创建一个 Thread 的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;threadName&quot;</span>)&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Thread Running&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h5 id="通过线程池创建"><a href="#通过线程池创建" class="headerlink" title="通过线程池创建"></a>通过线程池创建</h5><pre><code>ExecutorService pool = Executors.newFixedThreadPool(1);pool.execute(new Runnable() &#123;    @Override    public void run() &#123;        System.out.println(&quot;多线程执行，直接实现Runnable&quot;);    &#125;&#125;);</code></pre><p>注意：实际开发中不会使用 Executors 创建线程池，而是使用 ThreadPoolExecutor 的构造方法</p><h5 id="创建方式的对比"><a href="#创建方式的对比" class="headerlink" title="创建方式的对比"></a>创建方式的对比</h5><ul><li><strong>采用实现 Runnable. Callable 接口的方式创建多线程</strong></li></ul><blockquote><p><strong>优势</strong>是：</p><p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p><p>在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p><p><strong>劣势</strong>是：</p><p>编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</p></blockquote><ul><li><strong>使用继承 Thread 类的方式创建多线程</strong></li></ul><blockquote><p><strong>优势</strong>是：</p><p>编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p><p><strong>劣势</strong>是：</p><p>线程类已经继承了Thread类，所以不能再继承其他父类。</p></blockquote><ul><li><strong>通过线程池创建</strong></li></ul><blockquote><p><strong>优势</strong>是：</p><p>可以通过线程池管理线程。</p><p><strong>劣势</strong>是：</p><p>只有在需要管理多个线程时才比较好用，平时这种太复杂。</p></blockquote><h4 id="线程死亡的三种方式"><a href="#线程死亡的三种方式" class="headerlink" title="线程死亡的三种方式"></a>线程死亡的三种方式</h4><ul><li>正常结束<br>run() 方法或 call() 方法执行完成后，线程正常结束；</li><li>异常结束<br>线程抛出一个未捕获的 Exception 或 Error ，导致线程异常结束；</li><li>调用 stop() 方法<br>直接调用线程的 stop() 方法来结束线程，一般不推荐这种方式，因为容易导致死锁；</li></ul><h3 id="JMM（Java内存模型）"><a href="#JMM（Java内存模型）" class="headerlink" title="JMM（Java内存模型）"></a>JMM（Java内存模型）</h3><p>JMM 就是 Java内存模型 (java memory model)，<strong>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范</strong>，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以 <strong>Java 内存模型 (JMM) 屏蔽了各种硬件和操作系统的内存访问差异，让 java 程序在各种平台都能达到一致的并发效果。</strong> </p><p> Java 内存模型规定<strong>所有线程创建的变量都存放在主内存中</strong>，不管是成员变量还是方法中的局部变量。每个线程都有自己的工作内存，<strong>工作内存中保存了该线程用到的变量和主内存的拷贝副本，线程对变量的操作都在工作内存中进行</strong>，<strong>不能直接读写主内存中的变量</strong>。<strong>不同线程间无法访问到对方工作内存中的变量。线程间变量值的传递均需要通过主内存来完成。</strong> </p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240318222109920.png" alt="image-20240318222109920"></p><ul><li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的局部变量。</li><li><strong>本地内存</strong>：本地内存是 JMM 抽象出来的一个概念，每个线程都有一个私有的本地内存来存储主内存中的共享变量副本，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。</li></ul><blockquote><ul><li>主内存、工作内存和 JVM 内存布局中的堆、栈、方法区不是同一个层次的划分，基本没有什么关系。</li><li>如果要对应起来：可以说 <strong>JVM 堆中的部分区域 &lt;&#x3D;&#x3D;&gt; 主内存</strong>  <strong>JVM 栈中的部分区域 &lt;&#x3D;&#x3D;&gt; 工作内存</strong></li></ul></blockquote><h4 id="八种同步操作"><a href="#八种同步操作" class="headerlink" title="八种同步操作"></a>八种同步操作</h4><ul><li><p><strong>lock（锁定）</strong>: 作用于主内存中的变量，将其标记为线程独享的状态。</p></li><li><p><strong>unlock（解锁）</strong>: 作用于主内存中的变量，解除变量的锁定状态。</p></li><li><p><strong>read（读取）</strong>：作用于主内存中的变量，从主内存中读取一个变量的值到线程的工作内存中。</p></li><li><p>**load(载入)**：把 read 操作从主内存中得到的变量值放入工作内存中的变量副本中。</p></li><li><p>**use(使用)**：把工作内存中的一个变量值传给执行引擎，虚拟机每遇到一个使用到的变量都会执行该指令。</p></li><li><p><strong>assign（赋值）</strong>：作用于工作内存中的变量，把执行引擎传来的值赋给工作内存中的变量，虚拟机每遇到一个给变量赋值的字节码指令都会执行这个操作。</p></li><li><p><strong>store（存储）</strong>：作用于工作内存中的变量，把工作内存中一个变量的值传送到主内存中。</p></li><li><p><strong>write（写入）</strong>：作用于主内存中的变量，把 store 操作从工作内存中得到的变量值放入主内存的变量中。</p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240318223501182.png" alt="image-20240318223501182"></p></li></ul><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p><strong>思想</strong></p><ul><li>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果，编译器和处理器怎么进行重排序优化都行。</li><li>JMM 会禁止编译器和处理器进行会改变程序执行结果的重排序。</li></ul><p><strong>定义</strong></p><ul><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作间存在 happens-before 关系，并不意味着必须按照 happens-before 指定的顺序执行。如果重排序之后的执行结果与按照 happens-before 关系执行的结果一致，那么 JMM 也允许这样的重排序。</li></ul><p><strong>规则</strong></p><ul><li><strong>程序顺序规则</strong>：一个线程内，书写在前面的操作 happens-before 于书写在后面的操作；</li><li><strong>解锁规则</strong>：解锁 happens-before 加锁；</li><li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于对这个 volatile 变量的读操作。即对 volatile 变量的写操作结果对于发生于其后的任何操作都是可见的。</li><li><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code>方法 happens-before 于线程的每一个动作。</li></ul><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h4><p>该方法是本地静态方法， 用于返回当前线程对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h4><p>用于执行线程的运行时代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当target不为空时，执行target的run方法。若target为空，则需要重写run方法，方法内是业务逻辑</p><h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><p>用于启动线程并使线程处于就绪状态；当线程获得CPU时间片后 Java 虚拟机就会调用该线程的 run 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure><ul><li>interrupt():改变中断状态，将中断状态标记为true，此时不会真的中断线程，会等待当前线程执行完毕。</li><li>isInterrupted():检测本线程是否已经中断 。如果已经中断则返回true，否则返回false。 如果调用时线程不处于活动状态，则返回false。</li><li>interrupted():检测本线程是否已经中断 。如果当前线程已经中断则返回true，并修改中断状态为false，再调用 isInterrupted() 会返回false。如果当前线程没有中断则返回false，不会修改中断状态。</li></ul><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>让线程休眠。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><p>两个参数的sleep只是将nanos转为millis(四舍五入转换)，然后调用sleep(millis)方法。<br>sleep(millis)是本地静态方法，让当前线程休眠指定时间。<br><strong>sleep不释放锁</strong>。</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>调用join()方法的线程会被阻塞，等待join()方法完成以后，才能继续运行</p><p>A调用B.join()  -&gt; A暂停等待B执行完再继续</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入参数为0时，代表一直等待到结束，<strong>由于join()调用了wait()方法，因此会释放掉B的锁，但不会释放掉B持有对象的锁</strong></p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code> 主要解决多个线程之间访问资源的同步性，保证被它修饰的方法或者代码块在任意时刻只能有一个线程访问。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ul><p><strong>修饰实例方法</strong> （锁当前实例对象）</p><p>给当前实例对象加锁，进入同步代码前要获得 <strong>当前实例对象的锁</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修饰静态方法</strong> （锁当前类）</p><p>给当前类加锁，会作用于类的所有实例对象 ，进入同步代码前要获得 <strong>当前类 的锁</strong>。</p><p>静态成员不属于一个实例对象，归整个类所有，被类的所有实例共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，线程 B 调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而非静态 <code>synchronized</code> 方法占用的锁是当前实例对象的锁。</p><p><strong>修饰代码块</strong> （锁指定对象&#x2F;类）</p><ul><li><code>synchronized(object)</code> 表示进入同步代码块前要获得 <strong>给定对象的锁</strong>。</li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字修饰静态方法和 <code>synchronized(class)</code> 代码块都是给 Class 类上锁；</li><li><code>synchronized</code> 关键字修饰实例方法是给实例对象上锁；</li><li>尽量不要使用 <code>synchronized(String a)</code>。 因为 JVM 中字符串常量池具有缓存功能。</li><li>构造方法不能用 <code>synchronized</code> 关键字修饰，构造方法本身就是线程安全的，不存在同步的构造方法。</li></ul><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h5><p><strong>每个对象内部都有一个 monitor 对象与之关联，monitor 对象称为管程或监视器锁，线程获取锁的过程就是在获取 monitor 的所有权，解锁的过程就是释放 monitor 的所有权。</strong>monitor 里面有一个计数器，从0开始。</p><p>在 HotSpot 虚拟机中，Monitor 是基于 C++ 的 ObjectMonitor 实现的。</p><blockquote><p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只能在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p></blockquote><h5 id="修饰同步代码块的情况"><a href="#修饰同步代码块的情况" class="headerlink" title="修饰同步代码块的情况"></a>修饰同步代码块的情况</h5><p><strong><code>synchronized</code> 同步代码块的实现使用了 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，<code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令指向同步代码块的结束位置。</strong></p><ul><li>在线程执行**<code>monitorenter</code><strong>时，会尝试去获得对象的锁，也就是获取 <strong>对象的监视器锁 <code>monitor</code></strong> 的持有权，</strong>如果 monitor 计数器为 0，表明锁可以被获取，获取后将 monitor 计数器加1**；只有锁的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。</li><li>执行 <strong><code>monitorexit</code></strong> 指令后，<strong>将 monitor 计数器设为 0，表明锁被释放，其他线程可以尝试获取锁</strong>。如果获取对象的锁失败，那当前<strong>线程就要阻塞等待</strong>，直到锁被另一个线程释放为止。</li></ul><h5 id="修饰方法的的情况"><a href="#修饰方法的的情况" class="headerlink" title="修饰方法的的情况"></a>修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的是 <strong><code>ACC_SYNCHRONIZED</code></strong> 标识，<strong>该标识指明了该方法是同步方法</strong>。JVM 通过 <code>ACC_SYNCHRONIZED</code> 标识来判断方法是否是同步方法，然后执行相应的同步调用。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><h4 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a>锁升级机制</h4><p><strong>MarkWord 结构</strong></p><img src="/./res\1162587-20200918154125385-1537793659.png" alt="img" style="zoom: 33%;"><p><strong>锁可以升级，但不能降级</strong>。即：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的。</p><p>通过 synchronized 实现的同步锁是<strong>重量级锁</strong>，重量级锁会造成线程排队（串行执行），且会使 CPU 在用户态和核心态之间频繁切换，所以代价高、效率低。为了提高效率，JVM 不会一开始就使用重量级锁，而是根据需要进行锁的升级：</p><ol><li>锁对象刚创建时，<strong>没有任何线程来竞争</strong>，锁对象的 Mark Word 的偏向锁标志位是 0，锁状态标志位是 01，该对象处于<strong>无锁状态</strong>（无线程竞争）。</li><li>当<strong>有一个线程来竞争锁时，先用偏向锁</strong>，表示锁对象偏爱这个线程，这个线程要执行锁关联的任何代码，不需要再做任何检查和切换，在这种竞争不激烈的情况下，效率非常高。Mark Word 会记录自己偏爱的线程的 ID。</li><li>当有<strong>两个线程开始竞争这个锁对象</strong>，锁会升级为<strong>轻量级锁</strong>，两个线程公平竞争，哪个线程先占有锁对象并执行代码，锁对象的 Mark Word 就会指向那个线程栈帧中的锁记录。<strong>当前线程持有锁时，其他线程进入就会 cas 自旋，直到获取锁</strong>，轻量级锁适合多线程交替执行，效率高。</li><li>如果<strong>竞争这个锁对象的线程更多，导致了更多的切换和等待</strong>，JVM 就会把锁升级为重量级锁，即同步锁，锁对象的 Mark Word 会<strong>指向关联的监视器对象</strong>，监视器对象会用集合的形式来登记和管理排队的线程。</li></ol><img src="/./res\20210222222345508-1660460670054.jpg" alt="img" style="zoom:67%;"><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>大部分情况下都是同一个线程进入同一个同步代码块的，这也是偏向锁出现的原因。</p><blockquote><ul><li><strong>偏向锁的加锁</strong>：<ul><li>如果偏向锁是未偏向状态，使用 CAS 将 MarkWord 中的线程ID设置为当前线程 ID。如果成功，则获取偏向锁成功；如果失败，则进行锁升级。</li><li>如果偏向锁是已偏向状态，且MarkWord 中的线程 ID 是当前线程 ID，则获取偏向锁成功；如果MarkWord 中的线程 ID 不是当前线程 ID，则进行锁升级。</li></ul></li><li><strong>偏向锁的撤销：</strong>偏向锁升级时需要先进行偏向锁的撤销。<ul><li>如果对象是不可偏向状态，则不需要撤销。</li><li>如果对象是可偏向状态：<ul><li>如果MarkWord指向的线程死亡且该对象允许重偏向，则退回到可偏向但未偏向的状态；如果对象不允许重偏向，则变为无锁状态。</li><li>MarkWord 中的线程存活：<ul><li><strong>如果 MarkWord 指向的线程仍然拥有锁，则升级为轻量级锁，将 MarkWord 复制到线程栈中</strong>。</li><li>如果 MarkWord 指向的线程不再拥有锁且允许重偏向，则退回到可偏向但未偏向的状态；如果不允许重偏向则变为无锁状态。</li></ul></li></ul></li></ul></li></ul></blockquote><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p><strong>有两种情况会膨胀成重量级锁</strong>。</p><ul><li>当一个线程的 <strong>CAS 自旋</strong>次数<strong>超过阈值（默认是10）仍未能获取锁</strong>，为了防止 cpu 空转，会将自旋锁升级为重量级锁。</li><li><strong>其他线程正在 CAS 获取锁，第三个线程竞争获取锁，锁也会膨胀成重量级锁。</strong></li></ul><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>​在 <strong>JDK1.6 之前 synchronized 属于重量级锁</strong>，效率低下。synchronized通过监视器锁monitor来实现，而监视器锁monitor依赖于底层操作系统的 <code>Mutex Lock</code> 来实现。Java 的线程会映射到操作系统的原生线程上，如果要挂起或者唤醒线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换需要从用户态转换到内核态，这个状态之间的转换需要相对较长的时间，时间成本相对较高，也是synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁被称作“重量级锁”。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>如果将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM 这个变量是共享且不稳定的，每次使用都会从主存中读取。</p><ul><li><p>保证可见性</p></li><li><p>不保证原子性（例如 i++ 这样的指令实际上不是独立的指令）</p><blockquote><p>原因是i++在转化为字节码指令的时候是4条指令。</p><ul><li>getfield 获取原始值</li><li>iconst_1 将值入栈</li><li>iadd 进行加 1 操作</li><li>putfield 把 iadd 后的操作写回主内存</li></ul></blockquote></li><li><p>禁止指令重排（保证有序性）</p></li></ul><h4 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h4><p>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于内存屏障实现的。</p><ul><li>对非 volatile 变量进行读写时，每个线程都会从内存中拷贝变量到 CPU 缓存中。如果计算机有多个CPU，那么线程可能在不同的 CPU 上被处理，这意味着变量可能会被拷贝到不同的 CPU cache 中。</li><li>对 volatile 变量进行读写时，JVM 保证每次使用都从主存中读取，不会有可见性问题。<ul><li>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</li><li>对 volatile 变量进行读操作时，会在读操作后加一条 load 屏障指令，从主内存中读取共享变量；</li></ul></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只能在有限的情况下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>对变量的写操作不依赖于当前值。</li><li>变量没有被包含在具有其他变量的不变式中。</li></ul><p>其实就是在需要保证原子性的场景，不要使用 volatile。</p><h4 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是互补的存在，不是对立的存在。</p><ul><li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code> 性能比 <code>synchronized</code> 关键字要好 。但是 <code>volatile</code> 关键字只能修饰变量而 <code>synchronized</code> 关键字可以修饰方法和代码块 。</li><li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code> 关键字主要用于解决变量在多个线程间的可见性，而 <code>synchronized</code> 关键字主要用于解决多个线程间访问资源的同步性。</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p><strong>ThreadLocal类就像存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p>如果创建了一个<code>ThreadLocal</code>变量，那么访问<code>ThreadLocal</code>变量的线程都会有它的本地副本。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取和修改本地副本的，避免了线程安全问题。</p><h4 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h4><p>在 <code>Thread</code>类源代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread</code> 类中有一个 <code>threadLocals</code> 变量和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量，可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。</p><p>默认情况下这两个变量都是 null，只有线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，这两个方法实际上调用的是<code>ThreadLocalMap</code>类的 <code>get()</code>、<code>set()</code>方法。</p><p>在<code>ThreadLocal</code>类源代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这些内容，可以得出结论：<strong>最终变量放在当前线程的 <code>ThreadLocalMap</code> 中，而不是<code>ThreadLocal</code>中， 可以认为<code>ThreadLocal</code>是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类通过<code>Thread.currentThread()</code>得到当前线程对象后，再通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个 <code>Thread</code> 中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为 key ，Object 对象为 value 的键值对。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在一个线程中声明了两个 <code>ThreadLocal</code> 对象，数据都是存放在在<code>Thread</code>内部的<code>ThreadLocalMap</code> 中，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set()</code>方法设置的值。</p><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p><code>ThreadLocalMap</code> 的 key 是 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。如果 <code>ThreadLocal</code> 没有被外部强引用，在垃圾回收时，key 就会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。如果不采取措施的话，value 永远无法被 GC 回收，就会产生内存泄露。</p><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法时会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后最好手动调用 <code>remove()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>弱引用介绍：</strong></p><blockquote><p>一个只具有弱引用的对象就像<strong>可有可无的生活用品</strong>，生命周期更短暂。垃圾回收器线程扫描它所管辖的内存区域时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器线程的优先级很低， 因此不一定会很快发现那些只具有弱引用的对象。</p></blockquote><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会被销毁，而是等待下一个任务。</p><p>池化技术可以减少每次获取资源的消耗，提高资源利用率。</p><p><strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，不需要创建线程就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="处理任务流程"><a href="#处理任务流程" class="headerlink" title="处理任务流程"></a>处理任务流程</h4><p><img src="/.%5Cres%5C%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p><ol><li>如果当前运行的线程数小于核心线程数，就会新建一个线程来执行任务。</li><li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，就把该任务放入到任务队列里等待执行。</li><li>如果任务队列已满，且当前运行的线程数小于最大线程数，就新建一个线程来执行任务。</li><li>如果当前运行的线程数等于最大线程数，新建线程将会使当前运行的线程超出最大线程数，就会拒绝当前任务，饱和策略会调用 <code>RejectedExecutionHandler.rejectedExecution()</code> 方法。</li></ol><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p><strong>通过 <code>ThreadPoolExecutor</code> 构造函数创建（主要推荐方式）</strong></p><p><img src="/.%5Cres%5Cthreadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-d54a5992.png" alt="通过构造方法实现"></p><p><strong>通过 <code>Executor</code> 框架的 Executors 来创建</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>**<code>ScheduledThreadPool</code>**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>, 可能堆积大量的请求，从而导致 OOM。</li></ul><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code>:</strong> 最大可以同时运行的核心线程数量。</li><li><strong><code>maximumPoolSize</code>:</strong> 最大可以同时运行的线程数量。</li><li><strong><code>workQueue</code>:</strong> 新任务到来时会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li>**<code>keepAliveTime</code>**：线程池中的线程数量大于 <code>corePoolSize</code> 时，如果没有新任务提交，核心线程外的线程会等待 <code>keepAliveTime</code> 后被回收销毁；</li><li><strong><code>unit</code></strong>: <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>allowCoreThreadTimeOut</code></strong>: 设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁</li><li><strong><code>threadFactory</code></strong>: executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong>: 饱和策略。</li></ul><img src="/./res\线程池各个参数之间的关系-d65f3309.png" alt="线程池各个参数的关系" style="zoom: 33%;"><h4 id="动态参数配置"><a href="#动态参数配置" class="headerlink" title="动态参数配置"></a>动态参数配置</h4><img src="/./res\threadpoolexecutor-methods.png" alt="img" style="zoom:50%;"><p>程序运行期间，如果调用 <code>setCorePoolSize()</code> 方法，线程池会先判断当前工作线程数是否大于 <code>corePoolSize</code>，如果大于的话就会回收工作线程。</p><h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>如果当前运行的线程数等于最大线程数且队列也满了，此时有新任务到来就会触发饱和策略。<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong>会在调用 <code>execute</code> 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。这个策略会降低新任务的提交速度，影响程序的整体性能。如果应用程序可以接收此延迟且要求所有任务都要执行的话，可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 直接丢弃新任务。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 丢弃最早的未处理的任务。</li></ul><h4 id="常用的阻塞队列"><a href="#常用的阻塞队列" class="headerlink" title="常用的阻塞队列"></a>常用的阻塞队列</h4><p>新任务到来时会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>： 使用 <code>LinkedBlockingQueue</code>（无界队列），容量为 <code>Integer.MAX_VALUE</code>。由于队列永远不会被放满，所以 <code>FixedThreadPool</code> 最多只能创建核心线程数的线程。</li><li><code>CachedThreadPool</code> ：使用 <code>SynchronousQueue</code>（同步队列）。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证提交的新任务，如果有空闲线程，则使用空闲线程来处理；否则就新建一个线程来处理。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程导致 OOM。</li><li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>：使用 <code>DelayedWorkQueue</code>（延迟阻塞队列） 。<code>DelayedWorkQueue</code> 内部的任务不是按照放入的时间来排序，而是按照延迟的时间长短进行排序，内部采用“堆”的数据结构，保证每次出队的任务都是当前队列中延迟时间最短的。<code>DelayedWorkQueue</code> 满了之后会自动扩容原容量的 1&#x2F;2，最大可达 <code>Integer.MAX_VALUE</code>，即永远不会阻塞，所以最多只能创建核心线程数的线程。</li></ul><h4 id="线程池命名"><a href="#线程池命名" class="headerlink" title="线程池命名"></a>线程池命名</h4><p><strong>使用 guava 的 <code>ThreadFactoryBuilder</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure><p><strong>自己实现 ThreadFactor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个带名字的线程池生产工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池大小设定策略"><a href="#线程池大小设定策略" class="headerlink" title="线程池大小设定策略"></a>线程池大小设定策略</h4><p>线程池大小设置过大或者过小都会有问题，合适的才是最好。</p><ul><li>如果线程池太小，同一时间有大量任务需要处理，会导致大量的任务在任务队列中排队等待，CPU 没有得到充分利用。大量任务堆积在任务队列也可能会导致 OOM。</li><li>如果线程池太大，大量线程可能同时竞争 CPU 资源，导致大量的上下文切换，从而增加线程执行时间，影响整体效率。</li></ul><p>一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> CPU 密集型任务主要消耗 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多一个线程是为了防止线程偶发的缺页中断或其它原因导致任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，这时多出来的一个线程就可以充分利用 CPU。</li><li><strong>I&#x2F;O 密集型任务(2N)：</strong> 执行I&#x2F;O 密集型任务时，线程大部分时间在处理 I&#x2F;O 交互，在处理 I&#x2F;O 的时间段内不会占用 CPU ，这时就可以将 CPU 交给其它线程使用。因此可以多配置一些线程。</li></ul><p>如何判断类型：</p><p>CPU 密集型任务：利用 CPU 计算能力的任务，比如在内存中对大量数据进行排序。</p><p>IO 密集型任务：涉及到网络读取，文件读取的任务，这类任务的特点是 CPU 计算耗费的时间远小于等待 IO 操作完成的时间，大部分时间都花在了等待 IO 操作完成上。</p><h3 id="Lock-API"><a href="#Lock-API" class="headerlink" title="Lock API"></a>Lock API</h3><p>Lock接口抽象方法 </p><ul><li>void lock()：获取锁，如果锁不可用，当前线程将阻塞等待直至获取锁。</li><li>boolean tryLock()：如果锁可用返回true，如果锁不可用返回false；</li><li>boolean tryLock(long time, TimeUnit unit) throws InterruptedException：如果锁可用，则此方法立即返回true。 如果该锁不可用，则当前线程将出于线程调度目的而被禁用并处于休眠状态，直到发生以下三种情况之一为止：①当前线程获取到该锁；②当前线程被其他线程中断，并且支持中断获取锁；③经过指定的等待时间如果获得了锁，则返回true，没获取到锁返回false。</li><li>void unlock()：释放锁。释放锁的操作放在finally块中进行，以确保锁被释放，防止死锁。</li></ul><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是可重入的独占锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code> 有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code> 的底层是由 AQS 来实现的。</p><h5 id="与-synchronized-的区别"><a href="#与-synchronized-的区别" class="headerlink" title="与 synchronized 的区别"></a><strong>与 synchronized 的区别</strong></h5><p><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p><code>synchronized</code> 是依赖于 JVM 实现的，虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p><p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比 <code>synchronized</code>，<code>ReentrantLock</code> 增加了一些高级功能。主要来说主要有三点：</p><ul><li><strong>等待可中断</strong> : 通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待锁的线程可以放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code> 可以指定是公平锁还是非公平锁。而 <code>synchronized</code> 只能是非公平锁。公平锁就是先等待的线程先获得锁。可以通过构造器来显式的指定使用公平锁。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code> 关键字与 <code>wait()</code> 和 <code>notify()</code> &#x2F; <code>notifyAll()</code> 方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code> 类也可以实现，但是需要借助 <code>Condition</code> 接口与 <code>newCondition()</code> 方法。</li></ul><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><code>ReentrantReadWriteLock</code> 是可重入的读写锁，实现了 <code>ReadWriteLock</code> 接口 ，既可以保证多个线程同时读的效率，也可以保证写入时的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li><li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥。</li></ul><p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，可以同时被多个线程持有。写锁是独占锁，只能被一个线程持有。</p><p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p><p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够显著提升系统性能。</p><ul><li>在线程持有读锁的情况下不能获得写锁。因为在获取写锁时，如果发现读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有。</li><li>在线程持有写锁的情况下可以获得读锁。获取读锁时如果发现写锁被占用，只有写锁被其它线程占用的情况才会获取失败。</li></ul><p><strong>读锁为什么不能升级为写锁？</strong></p><p>写锁可以降级成读锁，但是读锁不能升级成写锁。因为写锁是独占锁，读锁升级为写锁会引起线程的争夺，会影响性能。</p><p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则都需要对方释放自己的读锁，而双方都不释放，就会产生死锁。</p><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p><p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 没有实现 <code>Lock</code> 或 <code>ReadWriteLock</code> 接口，而是基于 <strong>CLH锁</strong> 实现的（AQS 也是基于这玩意）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StampedLock</code> 提供了三种读写控制模式：读锁、写锁和乐观读。</p><ul><li><strong>写锁</strong>：独占锁，只能被一个线程获取。当一个线程获取写锁后，其他请求读锁和写锁的线程都会阻塞等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过 <code>StampedLock</code> 的写锁是不可重入的。</li><li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，其他线程请求读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过 <code>StampedLock</code> 的读锁是不可重入的。</li><li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁，同时允许一个写线程获取写锁。</li></ul><p>另外，<code>StampedLock</code> 还支持三种锁在一定条件下相互转换 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToWriteLock</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToReadLock</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToOptimisticRead</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>StampedLock</code> 在获取锁时会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放，如果返回的数据戳为 0 ，表示获取锁失败。当前线程持有锁后再次获取锁会返回一个新的数据戳，这也是 <code>StampedLock</code> 不可重入的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="literal">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="literal">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StampedLock 的性能为什么更好？</strong></p><p>相比于传统读写锁，多出来的乐观读是 <code>StampedLock</code> 比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，不会导致所有写线程阻塞。当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p><p><strong>StampedLock 适合什么场景？</strong></p><p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p><p>不过 <code>StampedLock</code> 不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好，如果需要用到 <code>ReentrantLock</code> 的高级功能，就不建议使用 <code>StampedLock</code> 了。</p><h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>原子类就是具有原子&#x2F;原子操作特征的类，一个操作是不可中断的。即使有多个线程一起执行，一个操作一旦开始，就不会被其他线程干扰。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下</p><p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整型数组原子类</li><li><code>AtomicLongArray</code>：长整型数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，不能解决 ABA 问题。。</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可以原子的更新数据和数据的版本号，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li></ul><h4 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h4><p>使用原子的方式更新基本类型</p><ul><li><code>AtomicInteger</code>：整型原子类</li><li><code>AtomicLong</code>：长整型原子类</li><li><code>AtomicBoolean</code>：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicInteger</code> 为例子来介绍。</p><h5 id="基本类型原子类的使用"><a href="#基本类型原子类的使用" class="headerlink" title="基本类型原子类的使用"></a>基本类型原子类的使用</h5><p><strong>AtomicInteger 类常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><p><strong><code>AtomicInteger</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i); <span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">        temvalue = i.getAndIncrement();</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i); <span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">        temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i); <span class="comment">//temvalue:4;  i:9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基本类型原子类的优势"><a href="#基本类型原子类的优势" class="headerlink" title="基本类型原子类的优势"></a>基本类型原子类的优势</h5><p>可以对比一下多线程下使用和不使用原子类实现线程安全</p><p><strong>多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程环境使用原子类保证线程安全（基本数据类型）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AtomicInteger线程安全原理"><a href="#AtomicInteger线程安全原理" class="headerlink" title="AtomicInteger线程安全原理"></a>AtomicInteger线程安全原理</h5><p><code>AtomicInteger</code> 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><p><code>AtomicInteger</code> 类使用 CAS + volatile 和 native 方法来保证原子操作，避免了 synchronized 的高开销，大大提高执行效率。</p><p>CAS原理：CAS算法有三个操作数，内存地址值、预期原始值、修改后的新值。如果内存地址对应的值和预期原始值相等， 就将修改后的新值保存到内存中。如果内存地址对应的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p><p>UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，可以拿到内存中的值的内存地址。value 是一个 volatile 变量，JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h4 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h4><p>使用原子的方式更新数组里的某个元素</p><ul><li><code>AtomicIntegerArray</code>：整形数组原子类</li><li><code>AtomicLongArray</code>：长整形数组原子类</li><li><code>AtomicReferenceArray</code>：引用类型数组原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerArray</code> 为例子来介绍。</p><h5 id="数组类型原子类的使用"><a href="#数组类型原子类的使用" class="headerlink" title="数组类型原子类的使用"></a>数组类型原子类的使用</h5><p><strong><code>AtomicIntegerArray</code> 类常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><p><strong><code>AtomicIntegerArray</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            System.out.println(i.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">        temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">        temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h4><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p><ul><li><code>AtomicReference</code>：引用类型原子类</li><li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可以原子的更新数据和数据的版本号，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicReference</code> 为例子来介绍。</p><h5 id="引用类型原子类的使用"><a href="#引用类型原子类的使用" class="headerlink" title="引用类型原子类的使用"></a>引用类型原子类的使用</h5><p><strong><code>AtomicReference</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicReference &lt; Person &gt; ar = <span class="keyword">new</span> <span class="title class_">AtomicReference</span> &lt; Person &gt; ();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        ar.set(person);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">updatePerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        ar.compareAndSet(person, updatePerson);</span><br><span class="line">        System.out.println(ar.get().getName());</span><br><span class="line">        System.out.println(ar.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先创建了一个 <code>Person</code> 对象，然后把 <code>Person</code> 对象设置进 <code>AtomicReference</code> 对象中，然后调用 <code>compareAndSet</code> 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 <code>person</code> 的话，则将其设置为 <code>updatePerson</code>。实现原理与 <code>AtomicInteger</code> 类中的 <code>compareAndSet</code> 方法相同。运行上面的代码后的输出结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Daisy</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p><strong><code>AtomicStampedReference</code> 类使用</strong> : 加入了stamp作为版本号控制，其余的部分相同，可以解决ABA</p><p><strong><code>AtomicMarkableReference</code> 类使用</strong> : 加入了mark作为标记控制，其余的部分相同，不能解决ABA</p><h4 id="对象属性修改类型原子类"><a href="#对象属性修改类型原子类" class="headerlink" title="对象属性修改类型原子类"></a>对象属性修改类型原子类</h4><p>如果需要原子更新类里的某个字段时，需要用到对象属性修改类型原子类。</p><ul><li><code>AtomicIntegerFieldUpdater</code>: 原子更新整型字段的更新器</li><li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li><li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段的更新器</li></ul><p>要想原子地更新对象的属性需要两步。第一步，因为对象属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰。</p><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p><h5 id="对象属性修改类型原子类的使用"><a href="#对象属性修改类型原子类的使用" class="headerlink" title="对象属性修改类型原子类的使用"></a>对象属性修改类型原子类的使用</h5><p><strong><code>AtomicIntegerFieldUpdater</code> 类使用示例</strong> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;<span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 类是一种<strong>异步任务监视器</strong>，可以让提交者监视任务的执行、取消任务的执行、获取任务执行结果。</p><h4 id="Future作用"><a href="#Future作用" class="headerlink" title="Future作用"></a>Future作用</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，提高执行效率。</p><p>执行某一耗时任务时，将这个耗时任务交给子线程去异步执行，然后可以执行别的任务，不用原地等待耗时任务执行完成。等别的任务执行完成后，再通过 <code>Future</code> 类获取耗时任务的执行结果。这样的话程序执行效率就明显提高了。</p><p>这其实就是多线程中经典的 <strong>Future 模式</strong>，可以看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><h4 id="Future使用"><a href="#Future使用" class="headerlink" title="Future使用"></a>Future使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行</span></span><br><span class="line">    <span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>cancel(boolean mayInterruptIfRunning)</code>：取消任务的执行</p><blockquote><p>执行这个方法时候，会有三种情况，</p><ul><li>第一种情况，如果<strong>任务还没开始执行</strong>，调用cancel方法后任务会被正常取消，然后返回true。</li><li>第二种情况，如果任务<strong>已经执行完毕或已经执行过一次cancel方法</strong>，如果再调用cancel方法，会取消失败，返回false。</li><li>第三种情况，如果<strong>任务正在执行</strong>，会根据传入的<code>mayInterruptIfRunning</code>参数分情况调用。如果值为true，执行任务的线程会收到中断信号，然后执行中断任务的逻辑并返回true。如果值为false，任务不会被取消，而是继续执行并返回false，表示不执行取消任务操作。</li></ul></blockquote></li><li><p><code>isCancelled()</code>：获取是否取消了任务</p><blockquote><p>用于判断任务是否被取消了</p></blockquote></li><li><p><code>isDone()</code>：任务是否执行完成</p><blockquote><p>如果返回true，表示任务执行完毕。返回false，表示任务还没执行完毕。有一种特殊情况，就是如果执行任务的过程发生了Exception，这种情况是会被当成执行完成的，因为抛出Exception的任务，在”Future“也是不会执行的，所以都当成执行完成返回true</p></blockquote></li><li><p><code>get()</code> 和 <code>get(long timeout, TimeUnit unit)</code>：获取任务执行的返回值</p><blockquote><p>get方法最主要的作用就是获取任务返回的结果，get方法可能会发生以下 3 种情况：</p><ul><li>第一种情况：如果<strong>任务执行完毕</strong>，直接返回任务执行结果。</li><li>第二种情况：如果<strong>任务还没执行完成</strong>，这种情况可能是任务本身业务比较复杂，需要花较长时间，也可能是放在线程池里，然后线程池中堆积了不少任务，需要等待线程来执行。这时调用get方法会把当前线程阻塞，直到任务执行完毕再返回结果。</li><li>第三种情况：如果<strong>任务执行过程抛出了异常</strong>，这时调用get方法会返回<code>ExecutionException</code>，不管实际的异常类型是什么。</li></ul></blockquote></li></ul><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><p><strong>偏向锁</strong></p><p>如果一把锁不存在竞争，那么就没必要上锁，只需要打个标记就行，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁，此时锁是可偏向的，当第一个线程尝试获取锁时，会将这个线程记录下来。之后如果尝试获取锁的线程是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</p><p><strong>轻量级锁</strong></p><p>JVM 开发者发现在很多情况下，synchronized 中的代码是不存在竞争的，不同线程交替执行synchronized 中的代码。这种情况下，没必要用完全互斥的重量级锁， CAS 就可以解决。当锁原来是偏向锁时，被另一个线程访问，说明存在竞争，偏向锁就会升级为轻量级锁，线程会通过自旋的方式尝试获取锁，而不会陷入阻塞。</p><p><strong>重量级锁</strong></p><p>重量级锁是互斥锁，利用操作系统的同步机制实现（锁交给OS管理），所以开销比较大。当多个线程存在竞争，轻量级锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</p><p>锁升级的路径：无锁→偏向锁→轻量级锁→重量级锁。</p><p>偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。</p><h4 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁&#x2F;不可重入锁"></a>可重入锁&#x2F;不可重入锁</h4><p>可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是线程当前持有了这把锁，如果想再次获取这把锁，必须要先释放锁后才能再次尝试获取。</p><p>对于可重入锁而言，最典型的就是 ReentrantLock 了，它也是 Lock 接口最主要的一个实现类。</p><h4 id="共享锁-独占锁"><a href="#共享锁-独占锁" class="headerlink" title="共享锁&#x2F;独占锁"></a>共享锁&#x2F;独占锁</h4><p>共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p><h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><p>公平锁公平的含义在于如果线程拿不到锁，就会进入等待，开始排队，在等待队列里<strong>等待时间长的线程会优先拿到这把锁</strong>，有先来先得的意思。而非公平锁可能会忽略掉已经在排队的线程，发生插队现象。</p><h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁&#x2F;乐观锁"></a>悲观锁&#x2F;乐观锁</h4><p>悲观锁要求在获取资源前，必须<strong>先拿到锁</strong>，以便达到“独占”的状态。当前线程在操作资源时，由于其他线程拿不到锁，所以其他线程不能来影响我。</p><p>乐观锁并<strong>不要求获取资源前拿到锁</strong>，也不会锁住资源；而是<strong>利用 CAS 理念</strong>，在不独占资源的情况下，对资源进行修改。</p><h4 id="自旋锁-非自旋锁"><a href="#自旋锁-非自旋锁" class="headerlink" title="自旋锁&#x2F;非自旋锁"></a>自旋锁&#x2F;非自旋锁</h4><p>自旋锁的理念是<strong>如果线程拿不到锁</strong>，不会陷入阻塞或释放 CPU 资源，而是<strong>利用循环，不停地尝试获取锁</strong>，这个循环过程被形象地比喻为“自旋”。</p><p><strong>非自旋锁</strong>的理念是如果拿不到锁，<strong>就直接放弃</strong>，或者执行其他的处理逻辑，如排队、陷入阻塞等。</p><p><strong>自旋锁好处：</strong>如果持有锁的线程在短时间内释放锁，等待锁的线程就不需进入阻塞状态，只需要等一等（<strong>自旋</strong>），等持有锁的线程释放锁后即可获取，这样就<strong>无需线程上下文切换&#x2F;无需用户态与内核态切换</strong>。</p><h4 id="可中断锁-不可中断锁"><a href="#可中断锁-不可中断锁" class="headerlink" title="可中断锁&#x2F;不可中断锁"></a>可中断锁&#x2F;不可中断锁</h4><p>在Java中，<strong>synchronized 关键字修饰的锁是不可中断锁</strong>，一旦线程申请了锁，就只能等到拿到锁之后才能进行其他的逻辑处理。</p><p>而 <strong>ReentrantLock 是典型的可中断锁</strong>，使用 lockInterruptibly() 方法，如果在获取锁的过程中突然不想获取了，就可以中断获取锁然后去做其他的事情，不需要等到获取到锁后才离开。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><a href="https://blog.csdn.net/qq_32998153/article/details/79529704?ops_request_misc=%7B%22request_id%22:%22165776539116782184664188%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165776539116782184664188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79529704-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=CAS&spm=1018.2226.3001.4187">什么是CAS机制？</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDg2OTAxNg==&mid=2652048732&idx=1&sn=9519a130bf9776555306af126c565a20&chksm=8105faabb67273bdf908202d46690961080a1a23071416cb14845afee04fb79827748489ef04&scene=178&cur_album_id=1826996971702665222">由浅入深C A S，小白也能与BAT面试官对线 (qq.com)</a></p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>CAS（Compare and Swap）比较并替换，是一种<strong>无锁算法</strong>，即<strong>在不加锁的情况下实现多线程间的变量同步</strong>，也就是在没有线程阻塞的情况下实现变量同步，所以也叫<strong>非阻塞算法</strong>。</p><p><strong>CAS 机制中使用了 3 个基本操作数：</strong></p><ul><li><strong>内存地址 V，</strong></li><li><strong>旧的预期值 A，</strong></li><li><strong>要修改的新值 B。</strong></li></ul><p><strong>更新变量时，只有变量旧的预期值 A 和内存地址 V 中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</strong></p><p><strong>从思想上来说，synchronized 属于悲观锁，悲观的认为程序中并发情况严重，所以严防死守。CAS 属于乐观锁，乐观地认为程序中并发情况不那么严重，所以让线程不断重试更新。</strong></p><p><strong>在 java 中 Atomic 系列类、Lock 系列类的底层实现，甚至在 JAVA1.6 以上版本，synchronized 转变为重量级锁之前，都会采用 CAS 机制。</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol><li>在内存地址V当中，存储着值为10的变量。</li></ol><img src="/./res\20180312172707148" alt="img" style="zoom: 67%;"><ol start="2"><li>此时线程1想把变量的值增加1.对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11.</li></ol><img src="/./res\20180312172814864" alt="img" style="zoom: 67%;"><ol start="3"><li>在线程1要提交更新之前，线程2抢先一步，把内存地址V中的变量值率先更新成了11。</li></ol><img src="/./res\20180312172943800" alt="img" style="zoom: 67%;"><ol start="4"><li>线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败。</li></ol><img src="/./res\20180312173045349" alt="img" style="zoom:67%;"><ol start="5"><li>线程1 重新获取内存地址V的当前值，并重新计算想要修改的值。此时对线程1来说，A&#x3D;11，B&#x3D;12。这个重新尝试的过程被称为自旋。</li></ol><img src="/./res\20180312173220371" alt="img" style="zoom:67%;"><ol start="6"><li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行比较，发现A和地址V的实际值是相等的。</li></ol><img src="/./res\20180312173331761" alt="img" style="zoom:67%;"><ol start="7"><li>线程1进行交换，把地址V的值替换为B，也就是12.</li></ol><img src="/./res\20180312173421205" alt="img" style="zoom:67%;"><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>Java语言不像C，C++语言一样可以直接访问底层操作系统，但是JVM为我们开了一个后门，这个后门就是unsafe，unsafe为我们提供了硬件级别的原子操作。</p><p>正是 <strong>unsafe 的compareAndSwapXxx方法保证了比较和替换的原子性操作！</strong>Unsafe.cpp 文件调用了 lock cmpxchg 指令，lock实现了原子性（<strong>汇编指令cmpxchg 本身不具备原子性</strong>），lock的锁有两种可能：<strong>锁总线，锁缓存行</strong></p><p><strong>总线锁定：</strong></p><p>总线（BUS）用于计算机组件间的数据传输，CPU与其他组件间传输数据，就是靠总线完成的，比如CPU对内存的读写。</p><p>总线锁定指CPU使用了总线锁，总线锁就是CPU提供的LOCK#信号，当CPU在总线上输出LOCK#信号时，其他CPU的总线请求将被阻塞。</p><p><strong>缓存锁定：</strong></p><p>总线锁定方式虽然保证了原子性，但是在锁定期间会导致大量阻塞，现代CPU为了提升性能，基于缩小锁定范围的思想设计了缓存行锁定（缓存行是CPU高速缓存存储的最小单位）。</p><p><strong>缓存锁定是指CPU对缓存行进行锁定</strong>，当缓存行中的共享变量回写到内存时，其他CPU会通过总线嗅探机制感知该共享变量是否发生变化，如果发生变化，让自己对应的共享变量缓存行失效，然后重新从内存中读取最新数据。缓存锁定基于缓存一致性机制实现，缓存一致性机制会阻止两个以上CPU同时修改同一个共享变量（现代CPU基本都支持和使用缓存锁定机制）。</p><p><strong>缓存行：</strong></p><p>由于CPU与主存速度差异较大，所以在CPU与主存之间有<strong>3级高速缓存</strong>（L1、L2、L3），L1、L2在CPU核里面，L3在多CPU核共用的CPU里面，每次从主存中读取的数据，都要在L1、L2、L3里面放置一份。同时由于空间局部性原理，每次会从主存中获取所需变量附近64字节的数据，称为一行数据（缓存行）。</p><p><strong>CPU需要实现缓存一致性协议来保证缓存行同步，</strong>为了解决不同内存变量间缓存行同步的问题，可以在不同内存变量间插入7个long类型的无意义变量，这样可以确保不同的内存变量不在同一个缓存行里面。</p><p><img src="/.%5Cres%5Cwps1-1660474685484.jpg" alt="img"></p><h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul><li><p><strong>CPU 开销过大</strong></p><p>CAS 建立在自旋锁的基础上，在高并发量情况下，如果许多线程反复尝试更新一个变量，却又一直失败，循环往复，自旋时间太长，会给 CPU 带来很大的压力。</p></li><li><p><strong>不能保证代码块的原子性</strong></p><p>CAS 只能保证一个变量的原子性操作，不能保证整个代码块的原子性。如果需要 3 个变量同时进行原子性更新，就只能使用 synchronized 了。</p></li><li><p><strong>ABA 问题</strong></p><p>这是 CAS 机制最大的问题所在。</p></li></ul><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>问题所在</strong></p><p>假设有两个线程，线程 <code>1</code> 读取到内存值 <code>A</code>，线程 <code>1</code> 时间片用完，切换到线程 <code>2</code>，线程 <code>2</code> 也读取到了内存值 <code>A</code>，并把它修改为 <code>B</code> 值，然后再把 <code>B</code> 值还原到 <code>A</code> 值，简单说，修改次序是<code>A-&gt;B-&gt;A</code>，接着线程 <code>1</code> 恢复运行，它发现内存值还是<code>A</code>，然后执行 <code>CAS</code> 操作，这就是著名的 <code>ABA</code> 问题。</p><p><strong>解决办法</strong></p><p>解决 <code>ABA</code> 问题也非常简单，只要追加版本号即可，每次改变版本号加<code>1</code>，即 <code>A—&gt;B—&gt;A</code>，变成 <code>1A—&gt;2B—&gt;3A</code>，在 <code>Java</code> 中提供了<code>AtomicStampedReference</code> 实现这个方案。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h4><p>AQS 全称 <code>AbstractQueuedSynchronizer</code>，这个类在 <code>java.util.concurrent.locks</code> 包下面。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单高效地构造出同步器，如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>、<code>FutureTask</code> 等。也能利用 AQS 构造出符合自己需求的同步器。</p><h4 id="AQS原理分析"><a href="#AQS原理分析" class="headerlink" title="AQS原理分析"></a>AQS原理分析</h4><h5 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h5><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设为有效工作线程，并将共享资源设为锁定状态。如果被请求的共享资源被占用，就需要一套线程阻塞等待及被唤醒后锁分配的机制，AQS 用 CLH 锁队列实现这个机制，即将暂时获取不到锁的线程加入到队列中。</strong></p><h5 id="CLH锁队列"><a href="#CLH锁队列" class="headerlink" title="CLH锁队列"></a>CLH锁队列</h5><ul><li><strong>CLH锁队列</strong>是一个虚拟的双向队列，不存在队列实例，仅存在结点之间的关联关系。AQS 将请求共享资源的线程封装成 CLH 锁队列的一个结点来实现锁的分配。</li><li>AQS 通过内置的 FIFO 队列完成线程的排队工作。AQS 使用 int 成员变量 state 来表示同步状态，使用 <strong>CAS</strong> 对 state 进行原子操作实现值的修改。</li><li>state &gt; 0 时，表示已经获取了锁，state &#x3D; 0 时表示释放了锁，提供了getState()、setState(int newState)、<strong>compareAndSetState</strong>(int expect, int update)三个方法对同步状态state进行操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><img src="/./res\AQS原理图.png" alt="AQS原理图" style="zoom:67%;"><h5 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h5><p><strong>AQS 定义两种资源共享方式</strong></p><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code>。</li></ul><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 读写锁允许多个线程同时对某一资源进行读操作。</p><h5 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h5><p>如果需要自定义同步器一般的方式是这样：</p><ol><li>自定义同步组件继承 <code>AbstractQueuedSynchronizer</code> 并重写指定方法。重写方法很简单，无非是对共享资源state的获取和释放。</li><li>将 AQS 组合在自定义同步组件中并调用其模板方法，模板方法会调用重写的方法。</li></ol><p><strong>AQS 使用模板方法设计模式，自定义同步器需要重写下面几个 AQS 钩子方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>什么是钩子方法呢？</strong> 钩子方法被声明在抽象类中，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板方法设计模式通过钩子方法控制固定步骤的实现。</p><p>篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/zpScSCktFpnSWHWIQem2jg">用 Java8 改造后的模板方法模式真的是 yyds!open in new window</a>。</p><p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p><h4 id="基于AQS的组件"><a href="#基于AQS的组件" class="headerlink" title="基于AQS的组件"></a>基于AQS的组件</h4><ul><li><strong><code>Semaphore</code>(信号量)：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li><li><strong><code>CountDownLatch </code>（倒计时器）：</strong> <strong><code>CountDownLatch</code> 是一个同步工具类</strong>，用来协调多个线程间的同步。通常用来控制线程等待，可以让某一个线程等待，直到倒计时结束后再开始执行。(<a href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">CountDownLatch的理解和使用 )</a>)</li><li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，主要应用场景也和 <code>CountDownLatch</code> 类似，可以实现线程等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。<code>CyclicBarrier</code> 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障后，屏障才会开门，被屏障拦截的线程才会继续执行。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，parties 表示屏障拦截的线程数量，线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 自己到达了屏障，然后就会被阻塞。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><p><strong>JDK1.7以前：</strong></p><img src="/./res\java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）" style="zoom:50%;"><p><strong>JDK1.8以后：</strong></p><img src="/./res\java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:50%;"><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区（元空间）</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对运行时数据区域的规定很宽松。以堆为例：可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。可以使用任何垃圾回收算法管理堆，也可以完全不进行垃圾回收。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作当前线程字节码的行号指示器。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各线程之间计数器互不影响。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>多线程的情况下，程序计数器用于记录当前线程执行到的位置，线程切换回来时能够知道上次运行到哪儿了。</li></ul><p><strong>注意</strong>：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>虚拟机栈是 JVM 运行时数据区域的一个核心</strong>，除了一些 Native 方法调用是通过本地方法栈实现的，其他方法调用都是通过虚拟机栈实现的。</p><p>方法调用的数据通过虚拟机栈传递，每一次方法调用都会有一个对应的栈帧被压入虚拟机栈中，方法调用结束后，对应的栈帧会被弹出。</p><p>虚拟机栈由一个个栈帧组成，每个栈帧中有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构中的栈类似，都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><img src="/./res\stack-area.png" alt="Java 虚拟机栈" style="zoom: 67%;"><p>虚拟机栈空间虽然不是无限的，但一般正常调用是不会出现问题的。如果函数调用陷入无限循环的话，就会导致虚拟机栈压入太多栈帧而占用太多空间，导致栈空间过深。当线程请求的栈的深度超过 Java 虚拟机栈的最大深度时，就会抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 正常返回，另一种是抛出异常。两种方式都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法是正常完成还是异常完成都算作方法结束。</strong></p><p>除了 <code>StackOverFlowError</code> 错误外，虚拟机栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为虚拟机栈的内存大小可以动态扩展， 如果动态扩展时无法申请到足够的内存空间，就会抛出<code>OutOfMemoryError</code>异常。</p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 如果虚拟机栈的内存大小不允许动态扩展，当线程请求的栈的深度超过 Java 虚拟机栈的最大深度时，就会抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果虚拟机栈的内存大小可以动态扩展， 当虚拟机栈在动态扩展栈时无法申请到足够的内存空间，就会抛出<code>OutOfMemoryError</code>异常。</li></ul><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，不同于对象本身，可能是指向对象起始地址的引用指针，也可能指向代表对象的句柄或其他与对象相关的位置）。</p><p><img src="/.%5Cres%5Clocal-variables-table.png" alt="局部变量表"></p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>是方法调用的中转站，存放方法执行过程中产生的中间计算结果。计算过程中产生的临时变量也会放在操作数栈中。</p><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>用于一个方法需要调用其他方法的场景。Class 文件的常量池里保存了大量的符号引用。当一个方法调用其他方法时，需要将常量池中指向方法的符号引用转换为调用方法在内存地址中的直接引用。动态链接的作用就是将符号引用转换为调用方法的直接引用。</p><img src="/./res\jvmimage-20220331175738692.png" alt="img" style="zoom: 80%;"><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，本地方法栈为虚拟机执行 Native 方法服务。</strong> 在 HotSpot 虚拟机中本地方法栈和虚拟机栈合二为一。</p><p>本地方法执行时也会创建一个栈帧压入本地方法栈中，栈帧中存放本地方法的局部变量表、操作数栈、动态链接、方法返回地址。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是所有线程共享的一块内存区域，是 Java 虚拟机管理的内存中最大的一块，堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>堆的唯一目的就是存放对象实例，几乎所有对象实例和数组都在堆中分配内存。</strong></p><p>“几乎”所有的对象都在堆中分配，但是，从 JDK 1.7 开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（即没有逃逸出去），那么对象可以直接在栈上分配内存。</p><p>堆是垃圾收集器管理的主要区域，因此堆也被称为 <strong>GC 堆</strong>。现在收集器基本都采用分代垃圾收集算法，所以堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等。进一步划分是为了更好地回收内存或更快地分配内存。</p><p>在 JDK 7 及 JDK 7 之前，堆内存被通常分为下面三部分：</p><ul><li>新生代内存(Young Generation)</li><li>老年代(Old Generation)</li><li>永久代(Permanent Generation)</li></ul><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><strong>JDK 8 之后 PermGen(永久代) 被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> </p><img src="/./res\hotspot-heap-structure.png" alt="堆内存结构" style="zoom:67%;"><p>大部分情况，会首先在 Eden 区给对象分配内存，在一次新生代垃圾回收后，如果对象还存活，就会进入 S0 或 S1，初始年龄为 1，每次新生代垃圾回收后对象的年龄会加 1，当年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。<strong>对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</strong></p><p>堆很容易出现 <code>OutOfMemoryError</code> 错误，表现形式 有几种，比如：</p><ol><li>**<code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code>**：当 JVM 花大量时间执行垃圾回收却只能回收少量堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> : 创建新对象时, 如果堆内存中的空间不足以存放新对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap sizeopen in new window</a>)</li></ol><h5 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p><strong>字符串常量池</strong>是 JVM 为了提升性能、减少内存消耗，针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> , <code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的键值对是字符串和字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</p><p>JDK1.7 之前，字符串常量池存放在永久代中。JDK1.7 将字符串常量池和静态变量从永久代移动了 Java 堆中。</p><img src="/./res\method-area-jdk1.6.png" alt="method-area-jdk1.6" style="zoom:67%;"><img src="/./res\method-area-jdk1.7.png" alt="method-area-jdk1.7" style="zoom:67%;"><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>因为永久代（方法区的实现）GC 回收效率太低，只有整堆收集 Full GC 时才会执行 GC。Java 程序中通常有大量被创建的字符串等待回收，将字符串常量池放到堆中能够更高效及时地回收字符串内存。</p><blockquote><p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>在不同的虚拟机中，方法区的实现是不同的。</p><p>当虚拟机要使用一个类时，需要加载并解析 Class 文件来获取相关信息，再将信息存入方法区。方法区会存储被虚拟机加载的<strong>类信息、字段信息、方法信息、常量 、即时编译器编译后的代码缓存等</strong>。</p><p><strong>方法区和永久代、元空间是什么关系呢？</strong> </p><p>方法区和永久代、元空间的关系很像接口和类的关系，永久代和元空间可以看作是类，方法区可以看作是接口，也就是说永久代和元空间是 HotSpot 虚拟机对方法区的两种实现。永久代是 JDK 1.8 之前的方法区实现，元空间是 JDK 1.8 及以后的方法区实现。</p><img src="/./res\method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现" style="zoom:67%;"><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><ol><li><p>永久代的内存大小固定，无法调整，由 JVM 设置。元空间使用本地内存，受本机可用内存的限制，虽然仍旧可能溢出，但是几率更小。</p><blockquote><p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p></li><li><p>元空间里存放类的元数据，加载多少类的元数据不由 <code>MaxPermSize</code> 决定, 而由系统实际可用空间决定，这样能加载的类就更多了。</p></li><li><p>JDK8 合并 HotSpot 和 JRockit 的代码时，JRockit 里没有永久代，合并后就没有必要设置永久代了。</p></li></ol><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前，永久代还没被彻底移除时通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>垃圾收集行为在方法区比较少，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 时，方法区（HotSpot 的永久代）被彻底移除了，取而代之是元空间，元空间使用本地内存。下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始大小（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><p>与永久代不同，如果不指定大小，随着更多类的创建，虚拟机会耗尽所有可用的本地内存。</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class 文件中除了有类信息、字段信息、方法信息等描述信息外，还有存放编译期生成的各种字面量和符号引用的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中固定值的表示方法，通过字面量就能知道值的含义。字面量包括整数字面量、浮点数字面量和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口符号引用。</p><p>常量池表会在类加载后放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，不过包含了更广泛的数据。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当运行时常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存是特殊的内存缓冲区，通过 JNI 的方式在本地内存上分配。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是直接内存也被频繁地使用，也可能发生 <code>OutOfMemoryError</code> 错误。</p><p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I&#x2F;O，也被称为 New I&#x2F;O）</strong>，引入了一种基于<strong>通道（Channel）与缓存区（Buffer）的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>直接内存的分配不会受到 Java 堆的限制，但是会受到本地内存大小和处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。堆外内存就是把内存分配在堆（新生代+老年代+永久代）以外的内存，堆外内存受操作系统管理而不是虚拟机，能够在一定程度上减少垃圾回收对应用程序造成的影响。</p><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h4><p>Java 自动内存管理主要针对对象内存的分配和回收。Java 自动内存管理最核心的功能是 <strong>堆</strong>内存中对象内存的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>现在收集器基本都采用分代垃圾收集算法，Java 堆被划分为几个不同的区域，这样就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老年代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt="堆内存结构" style="zoom:67%;"><p><strong>JDK 8 版本之后 PermGen (永久) 已被 Metaspace (元空间) 取代，元空间使用的是直接内存</strong> 。</p><h4 id="GC类型"><a href="#GC类型" class="headerlink" title="GC类型"></a>GC类型</h4><p>JVM 的 GC 分为两种：Minor GC 和 Full GC</p><ul><li><strong>Minor GC (Young GC)</strong><br>Minor GC 也叫 Young GC，主要对堆内存中新生代进行垃圾收集。Minor GC 比较频繁，回收的速度也比较快。</li><li><strong>Major GC (Full GC)</strong><br>Major GC 也叫 Full GC，主要对堆内存中老年代、新生代和方法区进行垃圾收集，Major GC 执行频率很低，一般几个小时才会执行一次，执行速度也比Minor GC 慢很多，大概在10倍以上。</li></ul><p><strong>HotSpot VM 的 GC 分类有两大种</strong>：</p><ul><li><p>**部分收集 (Partial GC)**：</p><blockquote><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></blockquote></li><li><p>**整堆收集 (Full GC)**：对整个 Java 堆和方法区进行垃圾收集。</p></li></ul><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><h5 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h5><p>大多数情况下，对象在新生代 Eden 区分配内存。当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC。如果 GC 期间虚拟机发现对象无法存入 Survivor 区，就会通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代，老年代的空间足够存放，不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。</p><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><p>虚拟机采用分代收集的思想来管理内存，所以需要识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>大部分情况，对象首先在 Eden 区域分配内存。如果对象在 Eden 区域出生且经第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，就会移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>对象在 Survivor 中每经过一次 MinorGC，年龄就加 1 ，当年龄增加到一定程度（默认为 15 岁），就会晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置</p><h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p>空间分配担保是<strong>为了确保 Minor GC 之前老年代还有容纳新生代所有对象的空间</strong>。</p><blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须<strong>先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会<strong>先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败</strong>(Handle Promotion Failure)；<strong>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</strong>，<strong>如果大于，将尝试进行一次 Minor GC</strong>，尽管这次 Minor GC 是有风险的；<strong>如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC</strong>。</p><p>JDK 6 Update 24 之后规则变为<strong>虚拟机会检查老年代的连续空间是否大于新生代对象总大小或者历次晋升的平均大小，如果大于就进行 Minor GC，否则就进行 Full GC</strong>。</p></blockquote><h4 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>计数器为 0 的对象不可能再被使用，需要被回收。</li></ul><p><strong>引用计数法实现简单、效率高，但是目前主流的虚拟机中并没有选择这个算法，因为它很难解决对象之间循环引用的问题。</strong></p><p><img src="/.%5Cres%5Cobject-circular-reference.png" alt="对象之间循环引用"></p><h5 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h5><p>可达性算法将一系列称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，如果一个对象到 GC Roots 没有任何引用链相连，说明此对象不可用 ，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><img src="/./res\jvm-gc-roots.png" alt="可达性分析算法" style="zoom:67%;"><p><strong>哪些对象可以作为 GC Roots？</strong></p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>在可达性分析法中不可达的对象，也并非是“非死不可”的，这些对象暂时处于“缓刑阶段”。要真正宣告一个对象死亡，至少要经历两次标记过程；</p><p>可达性分析法中不可达的对象会被第一次标记然后进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。如果对象没有覆盖 <code>finalize</code> 方法，或虚拟机已经调用过<code>finalize</code> 方法，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象会被放在一个队列中进行第二次标记，除非对象与引用链上任何一个对象建立关联，否则就会被回收。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象引用链是否可达，对象的存活都与“引用”有关。</p><p><img src="/.%5Cres%5Cjava-reference-type.png" alt="Java 引用类型总结"></p><p><strong>强引用（StrongReference）</strong></p><p>大部分引用都是强引用，是使用最普遍的引用。如果一个对象具有强引用，就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误使程序异常终止，也不会回收具有强引用的对象。</p><p><strong>软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器不会回收，如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。垃圾回收器线程扫描它所管辖的内存区域时，一旦发现了只具有弱引用的对象，无论当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器线程优先级很低， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>虚引用（PhantomReference）</strong></p><p>“虚引用”，就是形同虚设，与其他几种引用不同，虚引用不会决定对象的生命周期。如果一个对象仅持有虚引用，就和没有任何引用一样，在任何时候都可以被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收器回收的活动。</strong></p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现对象有虚引用，就会在回收对象内存前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果发现虚引用加入到引用队列中，就可以在被引用的对象的内存被回收之前采取必要的行动。</p><p>在程序设计中很少使用弱引用与虚引用，使用软引用的情况较多，因为<strong>软引用可以加快 JVM 垃圾回收的速度，防止内存溢出（OutOfMemory）等问题</strong>。</p><h4 id="常量和类的回收"><a href="#常量和类的回收" class="headerlink" title="常量和类的回收"></a>常量和类的回收</h4><p><strong>字符串常量池</strong></p><p>假设字符串常量池中存在字符串 “abc”，如果没有任何 String 对象引用该字符串常量，就说明常量 “abc” 是废弃常量，如果这时发生垃圾回收且有必要的话，”abc” 就会被清理出常量池。</p><p><strong>类</strong></p><p>满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，仅仅是“可以”，并不是和对象一样不使用了就必然会被回收。</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）” 和 “清除（Sweep）”两个阶段：首先标记所有不需要回收的对象，标记完成后统一回收所有没被标记的对象。</p><p>标记-清除算法是最基础的收集算法，后续的算法都是对其不足进行改进得到。标记-清除算法有两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记、清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><img src="/./res\mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法" style="zoom:67%;"><p>具体是标记不可回收对象还是可回收对象，众说纷纭，两种说法其实都没问题，个人更倾向于前者。</p><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>对象创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，将所有可达对象的标记位设置为 1 (true)；</li><li>清除阶段清除标记位为 0 (false)的对象。</li></ol><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。复制算法将内存分为大小相同的两块，每次使用其中一块。当一块内存使用完后，就将还存活的对象复制到另一块，然后再把原来那块内存一次清理掉。每次内存回收都是对内存区间的一半进行回收。</p><img src="/./res\copying-garbage-collection-algorithm.png" alt="复制算法" style="zoom:67%;"><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果存活对象数量比较多，复制性能会变得很差。</li></ul><h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>标记-整理（Mark-and-Compact）算法是根据老年代特点提出的算法，标记过程与“标记-清除”算法一样，后续不是直接回收可回收对象，而是让所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><img src="/./res\mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;"><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不高的场景。</p><h5 id="分代收集算法（目前使用的）"><a href="#分代收集算法（目前使用的）" class="headerlink" title="分代收集算法（目前使用的）"></a>分代收集算法（目前使用的）</h5><p>现在虚拟机垃圾收集都采用分代收集算法，根据对象存活周期将内存分为几块。一般将 Java 堆分为新生代和老年代，然后根据各个年代的特点选择合适的垃圾收集算法。</p><p>在新生代中，每次垃圾收集都会有大量对象死去，所以可以选择”复制“算法，只需少量的对象复制成本就可以完成垃圾收集。老年代中的对象存活几率比较高，而且没有额外的空间对它进行分配担保，所以必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>Serial（串行）收集器是最基本的垃圾收集器，它是一个单线程收集器，只使用一条垃圾收集线程进行垃圾收集工作，且<strong>在进行垃圾收集工作时必须暂停其他所有工作线程</strong>（ <strong>“Stop The World”</strong> ），直到垃圾收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><img src="/./res\serial-garbage-collector.png" alt="Serial 收集器" style="zoom:67%;"><p>虚拟机的设计者知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>相比其他垃圾收集器，Serial 收集器没有线程交互的开销，所以有很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机是个不错的选择。</p><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余和 Serial 收集器完全一样。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><img src="/./res\parnew-garbage-collector.png" alt="ParNew 收集器 " style="zoom:67%;"><p>ParNew 收集器是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，此时用户线程处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程和垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序继续运行，垃圾收集器运行在另一个 CPU 上。</li></ul><h5 id="Parallel-Scavenge收集器（JDK1-8默认使用）"><a href="#Parallel-Scavenge收集器（JDK1-8默认使用）" class="headerlink" title="Parallel Scavenge收集器（JDK1.8默认使用）"></a>Parallel Scavenge收集器（JDK1.8默认使用）</h5><p>Parallel Scavenge 收集器也是多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><p>Parallel Scavenge 收集器的关注点是吞吐量（高效率的利用 CPU），而 CMS 等垃圾收集器的关注点是用户线程的停顿时间（提高用户体验）。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 消耗的总时间的比值。 </p><p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，可以使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机完成。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><img src="/./res\parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图" style="zoom:67%;"><p><strong>这是 JDK1.8 默认收集器</strong>，默认使用 Parallel Scavenge + Parallel Old。</p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p><strong>Serial 收集器的老年代版本</strong>，也是单线程收集器。主要有两大用途：一是在 JDK1.5 及以前的版本中与 Parallel Scavenge 收集器搭配使用，二是作为 CMS 收集器的后备方案。</p><img src="/./res\serial-garbage-collector1.png" alt="Serial 收集器" style="zoom:67%;"><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><p><strong>Parallel Scavenge 收集器的老年代版本</strong>，使用多线程和“标记-整理”算法。在注重吞吐量及高效率利用 CPU 的场合，可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><img src="/./res\parallel-scavenge-garbage-collector1.png" alt="Parallel Old收集器运行示意图" style="zoom:67%;"><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p><strong>CMS（Concurrent Mark Sweep）收集器以最短回收停顿时间为目标，非常适合在注重用户体验的应用上使用。</strong></p><p><strong>CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，实现垃圾收集线程与用户线程同时工作。</strong></p><p>从 <strong>Mark Sweep</strong> 可以看出，CMS 收集器使用 <strong>“标记-清除”算法</strong>，整个工作过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停其他所有线程，记录与 root 直接相连的对象，速度很快；</li><li><strong>并发标记：</strong> 同时开启 GC 线程和用户线程，用一个闭包结构记录可达对象。这个闭包结构并不能保证包含当前所有可达对象，因为用户线程会不断更新引用域，GC 线程无法保证可达性分析的实时性。</li><li><strong>重新标记：</strong> 重新标记会修正并发标记期间因为用户程序运行导致标记变动的那些对象的标记，这个阶段的停顿时间比初始标记阶段稍长，比并发标记阶段短很多。</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始回收未标记的对象。</li></ul><img src="/./res\cms-garbage-collector.png" alt="CMS 收集器" style="zoom:67%;"><p>CMS收集器是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。</p><p>也有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li>使用的“标记-清除”算法在收集结束后会产生大量内存碎片。</li></ul><h5 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h5><p><strong>G1 (Garbage-First) 是面向服务器的垃圾收集器，主要针对具有多个 CPU 及大容量内存的设备，以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量。</strong></p><p>G1 收集器具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能使用多个 CPU 或 CPU 核心来缩短 Stop-The-World 停顿时间，也可以通过并发让 GC 线程和用户线程同时执行。</li><li><strong>分代收集</strong>：虽然 G1 不需要其他收集器配合就能独立管理整个 GC 堆，但还是保留了分代的概念。</li><li><strong>空间整合</strong>：G1 整体来看是使用“标记-整理”算法实现的，局部来看是使用“复制”算法实现。</li><li><strong>可预测的停顿</strong>：降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型。使用者可以指定在一个 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png" alt="G1 收集器" style="zoom:67%;"><p><strong>G1 收集器在后台维护了一个优先列表，会根据允许的收集时间，优先回收价值最大的 Region</strong>。通过 Region 划分内存空间以及有优先级的回收 Region，使 G1 收集器能在有限时间内达到尽可能高的收集效率。</p><h5 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h5><p>ZGC 采用复制算法，不过 ZGC 对算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p><p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UseZGC className</span><br></pre></td></tr></table></figure><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，类似 C 语言的结构体。</p><p><code>ClassFile</code> 的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version; <span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version; <span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count; <span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags; <span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class; <span class="comment">//当前类</span></span><br><span class="line">    u2             super_class; <span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class 文件的组成：</p><img src="/./res\16d5ec47609818fc.jpeg" alt="ClassFile 内容分析" style="zoom: 25%;"><h4 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>Class 文件的头 4 个字节称为魔数（Magic Number），魔数的唯一作用是<strong>确定当前Class文件是否能被虚拟机接收</strong>。</p><h4 id="Class-文件版本号（Minor-Major-Version）"><a href="#Class-文件版本号（Minor-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></figure><p>紧接着魔数的四个字节是 Class 文件的版本号：前两个字节是<strong>次版本号</strong>，后两个字节是<strong>主版本号</strong>。</p><p>Java 发布大版本时，主版本号都会加 1。可以使用 <code>javap -v</code> 命令查看 Class 文件的版本号信息。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以在实际开发时要确保 JDK 版本一致。</p><h4 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量类似 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这 14 个表<strong>开始的第一位是 u1 类型的标志位 tag 来标识当前常量的常量类型。</strong></p><table><thead><tr><th align="center">类型</th><th align="center">标志（tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_utf8_info</td><td align="center">1</td><td align="center">UTF-8 编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">５</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">６</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">７</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">８</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_FieldRef_info</td><td align="center">９</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_MethodRef_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodRef_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的符号引用</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">方法类型符号引用</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">方法句柄符号引用</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>：将结果输出到 temp.txt 文件)。</p><h4 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure><p>常量池之后的两个字节是访问标志，用于识别类或接口的访问信息，包括：这个 Class 是类还是接口，是 <code>public</code> 还是 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等。</p><p>类访问和属性修饰符:</p><p><img src="/.%5Cres%5C%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p><h4 id="当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p>类索引、父类索引和接口索引集合按照顺序排在访问标志之后，Java 类的继承关系由类索引、父类索引和接口索引集合三项共同确定。</p><p>类索引用于确定当前类的全限定名，父类索引用于确定当前类的父类的全限定名。由于 Java 是单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合描述了当前类实现的所有接口，这些接口按照 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h4 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表（field info）描述了接口或类中声明的变量。字段包括类变量和实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src="/.%5Cres%5C%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code>,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符) ，能否序列化（transient 修饰符) ，可变性（final) ，可见性（volatile 修饰符）。</li><li><strong>name_index:</strong> 对常量池的引用，表示字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段的描述符；</li><li><strong>attributes_count:</strong> 字段会拥有一些额外的属性，attributes_count 表示属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><img src="/./res\image-20201031084342859.png" alt="字段的 access_flag 的取值" style="zoom:50%;"><h4 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件中对方法的描述与对字段的描述几乎完全一致。方法表的结构也和字段表一样，依次是访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src="/.%5Cres%5C%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><img src="/./res\image-20201031084248965.png" alt="方法表的 access_flag 取值" style="zoom:50%;"><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h4 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在 Class 文件、字段表、方法表中都有属性表集合，用于描述某些场景专有的信息。与 Class 文件中其它数据项目不同，属性表集合不要求各个属性表有严格的顺序，且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自定义的属性信息，Java 虚拟机运行时会忽略掉不认识的属性。</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>从类加载到虚拟机内存中到卸载出内存，整个生命周期可以概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中<strong>验证、准备、解析</strong>统称为连接（Linking）。</p><img src="/./res\lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:50%;"><h4 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h4><p><strong>Class 文件加载到虚拟机内存后才能运行和使用。</strong></p><p>加载 Class 文件分为三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><img src="/./res\class-loading-procedure.png" alt="类加载过程" style="zoom:50%;"><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>类加载的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取类的二进制字节流。</li><li>将字节流代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区数据的访问入口。</li></ol><p>加载通过 <strong>类加载器</strong> 完成。类加载器有很多种，具体使用哪种类加载器加载类由 <strong>双亲委派模型</strong> 决定。</p><p>每个 Java 类都有一个引用，这个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 加载的，而是 JVM 在需要时自动创建的，数组类通过 <code>getClassLoader()</code> 方法获取的 <code>ClassLoader</code> 和该数组元素类型的 <code>ClassLoader</code> 是一致的。</p><p>非数组类的加载阶段是可控性最强的阶段，在这个阶段还可以自定义类加载器来控制字节流的获取方式（重写类加载器的 <code>loadClass()</code> 方法）。</p><p>加载阶段与连接阶段的部分动作(如文件格式验证)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p><strong>验证是连接阶段的第一步，验证确保 Class 文件的字节流包含的信息符合 Java 虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身安全。</strong></p><p>验证阶段在整个类加载过程中耗费的资源相对较多，但很有必要，可以有效防止恶意代码的执行。</p><p>不过，验证阶段不是必须的。如果程序代码已经被反复使用和验证过，就可以考虑使用 <code>-Xverify:none</code> 参数关闭大部分的类验证措施来缩短虚拟机类加载的时间。</p><p>验证阶段主要由四个阶段组成：</p><ol><li>文件格式验证（对Class 文件进行格式检查）</li><li>元数据验证（对字节码描述的信息进行语义检查）</li><li>字节码验证（对程序进行语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><img src="/./res\class-loading-process-verification.png" alt="验证阶段示意图" style="zoom: 67%;"><p>文件格式验证基于类的二进制字节流进行，保证类的二进制字节流能够正确解析并存储于方法区。其余三个验证阶段都在方法区存储结构上进行，不会再直接读取、操作字节流。</p><p>符号引用验证发生在类加载过程中的解析阶段，具体是在 JVM 将符号引用转为直接引用时。</p><p>符号引用验证是为了确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个对象中不存在的字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个不存在的方法时，抛出该异常。</li></ul><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p><strong>准备阶段正式为类变量分配内存并设置类变量初始值</strong>，将在方法区中分配内存。对于该阶段有以下几点需要注意：</p><ol><li>这时仅对类变量（ 即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量）进行内存分配，不包括实例变量。实例变量会在对象实例化时在 Java 堆中分配内存。</li><li>从概念上讲，类变量应在 <strong>方法区</strong> 中分配内存。JDK 7 之前，HotSpot 使用永久代来实现方法区，这时完全符合这个逻辑概念的。 而 JDK 7 及以后，HotSpot 把原本放在永久代的字符串常量池、静态变量移动到了堆中，这时类变量就会在 Java 堆中分配内存。相关阅读：<a href="https://github.com/fenixsoft/jvm_book/issues/75">《深入理解 Java 虚拟机（第 3 版）》勘误#75open in new window</a></li><li>初始值通常是数据类型默认的零值（如 0、0L、null、false 等），比如定义了 <code>public static int value = 111</code> ，在准备阶段 value 的初始值是 0 而不是 111，在初始化阶段才会给 value 赋值 111。如果给 value 变量加上了 final 关键字，<code>public static final int value = 111</code> ，那么在准备阶段时就会给 value 赋值 111。</li></ol><p><strong>基本数据类型的零值</strong>：</p><p><img src="/.%5Cres%5C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>解析阶段虚拟机会将常量池内的符号引用转换为直接引用</strong>，主要针对类或接口的符号引用、字段的符号引用、类中方法的符号引用、接口中方法的符号引用、方法类型符号引用、方法句柄符号引用和调用限定符共 7 类符号引用。</p><ul><li>符号引用：符号引用用一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标。符号引用与虚拟机实现的内存布局无关，引用的目标不一定是已经加载到虚拟机内存中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的。</li><li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或者是间接定位到目标的句柄。直接引用与虚拟机实现的内存布局直接相关，同一个符号引用在不同虚拟机上翻译出来的直接引用一般不相同。如果有直接引用，那么引用的目标必定已经在虚拟机内存中了。</li></ul><p>程序执行方法时，系统需要明确知道方法的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法，只要知道方法在方法表中的偏移量就可以调用该方法了。通过解析方法的符号引用就可以转变为目标方法在方法表中的位置，从而调用该方法。</p><p>综上，解析阶段虚拟机会将常量池内的符号引用转换为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。</p><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p><strong>初始化阶段会执行初始化方法 <code>&lt;clinit&gt; ()</code>，是类加载的最后一步。初始化阶段 JVM 才开始真正执行类中的 Java 程序代码(字节码)。</strong></p><blockquote><p><clinit> ()&#96;方法是编译之后自动生成的。 </clinit></p></blockquote><p>调用 <code>&lt;clinit&gt; ()</code> 方法时，虚拟机会确保其在多线程环境下的安全性。<code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，如果在多线程环境下进行类初始化可能会引起多个线程阻塞，并且这种阻塞很难被发现。所以如果多个线程同时初始化一个类，那么只会有一个线程执行这个类的 <code>&lt;clinit&gt; ()</code> 方法，其他线程都需要等待，直到活动线程初始化完毕。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li><p>当遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这 4 条字节码指令时，会对类进行初始化。</p><ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即创建一个类的实例对象时。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即访问类的静态变量 (不是静态常量，常量会被加载到运行时常量池)时。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即给类的静态变量赋值时。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即调用类的静态方法时。</li></ul></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时，如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等。如果类没初始化就会对其进行初始化。</p></li><li><p>初始化一个类时，如果其父类还未初始化，则先对父类进行初始化。</p></li><li><p>虚拟机启动时，虚拟机会先初始化包含 <code>main</code> 方法的主类。</p></li><li><p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，使用这 2 个调用时必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p><blockquote><p>Reflection 和 MethodHandle 本质上都是在模拟方法的调用，Reflection 是模拟 Java 代码层次的方法调用，而 MethodHandle 是模拟字节码层次的方法调用。</p></blockquote></li><li><p>当一个接口中定义了默认方法（被 default 关键字修饰的接口方法），如果要初始化接口的实现类，就需要先初始化该接口。</p></li></ol><h4 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h4><p><strong>卸载类就是 GC 类的 Class 对象。</strong></p><p>卸载类需要满足 3 个要求：</p><ol><li>该类的所有实例对象都已被 GC，也就是说堆中不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用。</li><li>该类的类加载器实例已被 GC。</li></ol><p>在 JVM 生命周期内，jvm 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载的。</p><p>JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，这些类加载器的实例不会被回收。而我们自定义的类加载器的实例是可以被回收的，所使用自定义类加载器加载的类是可以被卸载的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li>类加载器负责加载类，实现类加载过程中加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li>数组类不是通过 <code>ClassLoader</code> 加载的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，<strong>类加载器加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>除了加载类之外，类加载器还可以加载 Java 应用所需的资源，如文本、图像、配置文件、视频等。</p><h4 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h4><p>JVM 启动时，并不会一次性加载所有类，而是根据需要动态加载。也就是说，大部分类在使用时才会加载，这样对内存更加友好。</p><p>已经加载的类放在 <code>ClassLoader</code> 中。类加载时会先判断当前类是否被加载过，如果当前类已被加载就直接返回，否则会尝试加载。也就是说，对于一个类加载器来说，相同名称的类只会被加载一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内置类加载器"><a href="#内置类加载器" class="headerlink" title="内置类加载器"></a>内置类加载器</h4><p>   中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li>**<code>BootstrapClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，没有父级，用来加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类以及 <code>-Xbootclasspath</code>参数指定路径下的所有类。</li><li>**<code>ExtensionClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及 <code>java.ext.dirs</code> 系统变量指定路径下的所有类。</li><li>**<code>AppClassLoader</code>(应用程序类加载器)**：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><p>除了这三种类加载器之外，还可以自定义类加载器，以满足特殊需求。</p><img src="/./res\class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom:67%;"><p><code>BootstrapClassLoader</code> 是 JVM 自身的一部分，其他的类加载器都在 JVM 外部实现，且全都继承 <code>ClassLoader</code> 抽象类。这样做的好处是可以自定义类加载器，让应用程序自己决定如何获取所需的类。</p><p>每个 <code>ClassLoader</code> 都可以通过 <code>getParent()</code> 获得父类 <code>ClassLoader</code>，如果获取到的 <code>ClassLoader</code> 为 <code>null</code>，说明该类是通过 <code>BootstrapClassLoader</code> 加载的。</p><p><strong>为什么获取到 <code>ClassLoader</code> 为 <code>null</code> 就是由 <code>BootstrapClassLoader</code> 加载的呢？</strong> 因为 <code>BootstrapClassLoader</code> 由 C++ 实现，在 Java 中没有与之对应的类，所以拿到的结果是 <code>null</code>。</p><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>除了 <code>BootstrapClassLoader</code> ，其他类加载器均由 Java 实现且继承<code>ClassLoader</code>抽象类。如果要自定义类加载器，需要继承 <code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code> 类有两个关键的方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，<strong>实现了双亲委派机制</strong> 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时会调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>如果不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法，无法被父类加载器加载的类会通过这个方法被加载。如果想打破双亲委派模型，就重写 <code>loadClass()</code> 方法。</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><code>ClassLoader</code> 使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例在亲自查找类或资源前，会先将查找类或资源的任务委托给父类加载器。<code>BootstrapClassLoader</code> 没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。<strong>层次图见上图</strong>。</p><p>可以看出：</p><ul><li><code>ClassLoader</code> 使用委托模型来查找类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应有父类加载器。</li><li><code>ClassLoader</code> 实例在亲自查找类或资源前，会将查找类或资源的任务委托给父类加载器。</li></ul><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载器接收到类加载请求时，会先将请求转发给父类加载器。在父类加载器没有找到请求的类的情况下，类加载器才会尝试亲自去加载。</p><p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>类加载时，会先判断当前类是否已经被加载。如果已经被加载，就直接返回，否则会尝试加载。</li><li>类加载器在进行类加载时，在亲自加载类之前，会先把请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样，请求最终都会到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父类加载器无法完成加载请求（搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li></ul><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：类的全名相同且加载类的类加载器也相同。只有两者都相同，才认为两个类相同。即使两个类来源于同一个 <code>Class</code> 文件且被同一个虚拟机加载，只要加载它们的类加载器不同，那两个类就不相同。</p><h5 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h5><p>双亲委派模型保证了 Java 程序的稳定，避免了类的重复加载，也保证了 Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，然后自己编写一个 <code>Object</code> 类的话，程序运行时，系统就会加载两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的 <code>Object</code> 类，而不是自己写的 <code>Object</code> 类。因为 <code>AppClassLoader</code> 在加载自己写的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现已经加载过 <code>Object</code> 类，就会直接返回，不会再加载自己写的 <code>Object</code> 类。</p><h5 id="打破双亲委派模型的方法"><a href="#打破双亲委派模型的方法" class="headerlink" title="打破双亲委派模型的方法"></a>打破双亲委派模型的方法</h5><p>自定义加载器需要继承 <code>ClassLoader</code> 抽象类。如果不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法，无法被父类加载器加载的类最终会通过这个方法加载。如果想打破双亲委派模型就重写 <code>loadClass()</code> 方法。</p><p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p></blockquote><p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><img src="/./res\tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构" style="zoom:67%;"><h3 id="重要的JVM参数"><a href="#重要的JVM参数" class="headerlink" title="重要的JVM参数"></a>重要的JVM参数</h3><h4 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h4><p><img src="/.%5Cres%5C%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-53ddeca6.png" alt="内存区域常见配置参数"></p><h5 id="显式指定堆内存–Xms和-Xmx"><a href="#显式指定堆内存–Xms和-Xmx" class="headerlink" title="显式指定堆内存–Xms和-Xmx"></a>显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h5><p>如果我们需要指定堆内存最小和最大堆大小，可以使用以下参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure><ul><li><strong>heap size</strong> 表示要初始化的内存大小。</li><li><strong>unit</strong> 表示要初始化内存的单位。单位为<em><strong>“ g”</strong></em> (GB)、**<em>“ m”*<strong>（MB）、</strong></em>“ k”***（KB）。</li></ul><p>如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，参数应该这样来写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></table></figure><h5 id="显式指定新生代内存-Young-Generation"><a href="#显式指定新生代内存-Young-Generation" class="headerlink" title="显式指定新生代内存(Young Generation)"></a>显式指定新生代内存(Young Generation)</h5><p>在配置完堆内存后，需要配置 <code>Young Generation</code> 在堆内存中所占的比例。默认情况下，YG 的最小为 1310 <em>MB</em>，最大<em>无限制</em>。</p><p>有两种指定新生代内存(Young Generation)大小的方法：</p><p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br></pre></td></tr></table></figure><p>如果要为新生代分配最小 256m 的内存，最大 1024m 的内存，参数应该这样来写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br></pre></td></tr></table></figure><p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p><p>如果要为新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），参数应该这样来写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，因为 Full GC 的成本远高于 Minor GC，所以尽可能将对象分配在新生代是明智的做法。在实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p>还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置老年代与新生代内存的比值。</p><p>比如设置老年代与新生代内存的比值为 1，也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1&#x2F;2。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=1</span><br></pre></td></tr></table></figure><h5 id="显式指定永久代-元空间的大小"><a href="#显式指定永久代-元空间的大小" class="headerlink" title="显式指定永久代&#x2F;元空间的大小"></a>显式指定永久代&#x2F;元空间的大小</h5><p><strong>从 Java 8 开始，如果没有指定 Metaspace 的大小，随着类的创建，虚拟机会耗尽所有可用的系统内存（永久代不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除时通常通过下面的参数来调节方法区大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">#方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">#方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>垃圾收集行为在永久代比较少出现，但并非数据进入方法区后就“永久存在”了。</p><p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p><p>下面是一些常用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 使用过程中触发 Full GC 的阈值</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><blockquote><p>Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。</p><p>Metaspace 由于使用扩容到<code>-XX:MetaspaceSize</code> 参数指定的量后，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p><p>也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。</p><p>垃圾搜集器内部是根据变量 <code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MetaspaceGC::initialize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// Set the high-water mark to MaxMetapaceSize during VM initializaton since</span></span><br><span class="line">  <span class="comment">// we can&#x27;t do a GC during initialization.</span></span><br><span class="line">  _capacity_until_GC = MaxMetaspaceSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h4><h5 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h5><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集open in new window</a>算法至关重要。</p><p>JVM 具有四种类型的 GC 实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS 垃圾收集器</li><li>G1 垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><h5 id="GC-日志记录"><a href="#GC-日志记录" class="headerlink" title="GC 日志记录"></a>GC 日志记录</h5><p>生产环境或者其他要测试 GC 问题的环境，一定会配置打印 GC 日志的参数，便于分析 GC 相关的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必选</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># 打印对象分布</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line"><span class="comment"># 打印堆数据</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment"># 打印Reference处理信息</span></span><br><span class="line"><span class="comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span></span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line"><span class="comment"># 打印STW时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span></span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 开启日志文件分割</span></span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line"><span class="comment"># 最多分割几个文件，超过之后从头文件开始写</span></span><br><span class="line">-XX:NumberOfGCLogFiles=14</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></table></figure><h4 id="OOM相关"><a href="#OOM相关" class="headerlink" title="OOM相关"></a>OOM相关</h4><p>对于大型应用程序，内存不足错误是非常常见的，这会导致应用程序崩溃。</p><p>JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，可以用来查找泄漏:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</span><br><span class="line">-XX:OnOutOfMemoryError=<span class="string">&quot;&lt; cmd args &gt;&quot;</span></span><br><span class="line">-XX:+UseGCOverheadLimit</span><br></pre></td></tr></table></figure><p>这里有几点需要注意:</p><ul><li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li><li><strong>HeapDumpPath</strong> 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用<code>.hprof</code>格式</li><li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError=&quot;shutdown -r&quot;</code> 。</li><li><strong>UseGCOverheadLimit</strong> 是一种策略，限制抛出 OutOfMemory 错误之前花费在 GC 中的时间。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><code>-server</code> : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM</li><li><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存。</li><li><code>-XX:+UseLWPSynchronization</code>: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。</li><li><code>-XX:LargePageSizeInBytes </code>: 设置用于 Java 堆的较大页面大小; 它采用 GB&#x2F;MB&#x2F;KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</li><li><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。</li><li><code>-XX:SurvivorRatio</code> : eden&#x2F;survivor 空间的比例, 例如<code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</li><li><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</li><li><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</li><li><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</li><li><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。</li></ul><h3 id="OOM问题排查和解决"><a href="#OOM问题排查和解决" class="headerlink" title="OOM问题排查和解决"></a>OOM问题排查和解决</h3><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><ul><li><p><strong>堆溢出原因</strong></p><ul><li>无法在 Java 堆中分配对象</li><li>应用程序保存了无法被 GC 的对象。</li><li>应用程序过度使用 finalizer。</li></ul><p>对象数量达到堆最大容量限制后就会产生内存溢出异常。报错信息有两种：</p><ol><li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :在创建新的对象时, 如果堆内存中的空间不足以存放新创建的对象, 就会引发此错误。</li></ol></li><li><p><strong>排查解决思路：</strong></p><ul><li><p>查找关键报错信息，如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure></li><li><p>使用内存映像分析工具（如Eclipsc Memory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。</p></li><li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，修复应用程序中的内存泄漏。</p></li><li><p>如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 -Xmx 增加堆大小。</p></li></ul></li></ul><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>关于虚拟机栈和本地方法栈，两种异常：</p><ul><li><strong>栈溢出原因</strong><ul><li>是否有递归调用</li><li>是否有大量循环或死循环</li></ul></li></ul><ol><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，当线程请求的栈深度超过 Java 虚拟机栈最大深度时，就会抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong>若栈的内存大小可以动态扩展， 如果动态扩展栈时无法申请到足够的内存空间，就会抛出<code>OutOfMemoryError</code>异常。</li></ol><ul><li><strong>栈溢出排查解决思路</strong></li></ul><ol><li>查找关键报错信息，确定是StackOverflowError还是OutOfMemoryError</li><li>如果是StackOverflowError，检查代码是否递归调用方法等</li><li>如果是OutOfMemoryError，检查是否有死循环创建线程等，通过-Xss降低的每个线程栈的容量</li></ol><h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><p>方法区会存储被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量 、即时编译器编译后的代码缓存等。<strong>运行时产生大量的类，会填满方法区，造成溢出</strong>。</p><ul><li><p><strong>方法区溢出原因</strong></p><ul><li>使用 CGLib 生成了大量的代理类，导致方法区被撑爆</li><li>在 Java7 之前，频繁的错误使用 String.intern()</li><li>应用长时间运行，没有重启</li></ul></li><li><p><strong>方法区溢出排查解决思路</strong>： 方法区溢出的报错信息为 <strong><code>java.lang.OutOfMemoryError: Metaspace</code></strong></p><ul><li>检查是否永久代空间设置得过小</li><li>检查代码是否频繁错误得使用String.intern方法</li><li>检查是否使用 CGLib 生成了大量的代理类</li><li>重启大法，重启JVM</li></ul></li></ul><h4 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。但是，直接内存也被频繁地使用，也可能OOM。JDK1.4 加入了NIO (New Input&#x2F;Output) 类，可以使用 native 函数库直接分配堆外内存，然后将 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用，避免了在 Java 堆和直接内存中来回复制数据。</p><p><strong>直接内存溢出原因</strong></p><ul><li>直接内存的分配不受 Java 堆大小的限制，<strong>受本机总内存大小限制</strong>。</li><li>直接内存由 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</li><li>NIO程序中，使用ByteBuffer.allocteDirect(capability)会分配直接内存，可能导致直接内存溢出。</li></ul><p><strong>直接内存溢出</strong></p><ul><li>检查代码是否恰当</li><li>检查JVM参数-Xmx，-XX:MaxDirectMemorySize 是否合理。</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p><strong>定义</strong>：设计模式（Design pattern）是一套被反复使用、代码设计经验的总结。</p><p><strong>好处</strong>：使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 </p><p><strong>模式：在某些场景下，针对某类问题的某种通用的解决方案。</strong></p><blockquote><p> 场景：项目所在的环境</p><p> 问题：约束条件，项目目标等</p><p> 解决方案：通用、可复用的设计，解决约束达到目标。</p></blockquote><p><strong>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong></p><p><strong>结构型模式：把类或对象结合在一起形成一个更大的结构。</strong></p><p><strong>行为型模式：类和对象如何交互，及划分责任和算法。</strong></p><img src="/./res\aefc6eb7f5ba13216d5f21051327816e.png" alt="img" style="zoom:67%;"><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><p><strong>总原则——开闭原则（Open Closed Principle）</strong></p><p><strong>在程序需要拓展时，不能修改原有代码，而是扩展原有代码</strong>，实现一个热插拔的效果。</p><p><strong>1、单一职责原则（Single Responsibility Principle）</strong></p><p>不要有多于一个导致类变更的原因，每个类应该实现单一的职责，否则就应该把类拆分。</p><p><strong>2、里氏替换原则（Liskov Substitution Principle）</strong></p><p>所有引用父类的地方必须能透明地使用其子类的对象。</p><p>里氏代换原则是对开闭原则的补充。实现开闭原则的关键就是抽象化，而父类与子类的继承关系就是抽象化的具体实现。里氏替换原则中，<strong>子类尽量不要重写和重载父类的方法</strong>，因为父类代表定义好了的结构，并通过这个规范的接口与外界交互，子类不应该随便破坏它。</p><p><strong>3、依赖倒置原则（Dependence Inversion Principle）</strong></p><p>面向接口编程，依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>接口中不应存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口要好。</p><p><strong>5、迪米特法则（最少知道原则）(Law of Demeter)</strong></p><p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应将逻辑封装在方法内部，并通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>尽量使用对象组合&#x2F;聚合来将已有的对象纳入到新对象中，而不是继承。</p><p>组合&#x2F;聚合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，使新对象可以调用已有对象的功能。</p><p><a href="https://mp.weixin.qq.com/s/n3vsRQZPe0j5oIOk3umj7A">常用设计模式汇总，告诉你如何学习设计模式 (qq.com)</a></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><a href="https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%7B%22request_id%22:%22166070068316782248515287%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166070068316782248515287&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107296517-null-null.142%5Ev41%5Epc_rank_34,185%5Ev2%5Etag_show&utm_term=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187">我给面试官讲解了单例模式</a></p><h3 id="定义与优缺点"><a href="#定义与优缺点" class="headerlink" title="定义与优缺点"></a>定义与优缺点</h3><p><strong>单例模式是指在内存中仅创建一次对象。</strong>当程序<strong>多次使用同一对象且作用相同</strong>时，为了防止频繁创建对象占用内存，所以仅在内存中<strong>创建一次对象</strong>，并让所有需要调用的地方共享这一单例对象，从而节约系统资源。</p><p>单例模式有两种类型：</p><ul><li><p><strong>饿汉式</strong>：在<strong>类加载</strong>时就创建单例对象，等待程序使用，不存在并发安全问题和性能问题。</p></li><li><p><strong>懒汉式</strong>：在<strong>需要使用</strong>对象时才创建单例对象，正确的实现方式是：<strong>Double Check + Lock</strong>，可以解决并发安全问题和性能问题。</p></li><li><p>开发中如果对<strong>内存要求非常高</strong>，就使用<strong>懒汉式</strong>。</p></li><li><p>如果对<strong>内存要求不高</strong>，就使用饿汉式。</p></li><li><p>为了防止多线程环境下因为指令重排序导致 NullPointerException，<strong>需要给单例对象添加volatile关键字防止指令重排序</strong>。</p></li><li><p>最优雅的实现方式是<strong>枚举</strong>，不仅没有线程安全问题，而且 Enum 类内部会<strong>防止反射和反序列化破坏单例</strong>。</p></li></ul><p>最常见的单例模式是 Spring 中的 bean。单例模式三要素：</p><ul><li>静态成员私有化</li><li>构造函数私有化</li><li>创建一个静态 public 方法用于创建单例对象</li></ul><p><strong>优点</strong></p><ul><li>减少占用的系统资源，节省内存</li><li>减少对共享资源的多重占用</li><li>减少对象的实例化，提供了唯一实例的受控访问</li></ul><p><strong>缺点</strong></p><ul><li>不能使用在变化的对象上</li><li>扩展难度大</li><li>滥用单例会出现一些负面问题</li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式在<strong>类加载</strong>时就创建单例对象，在程序调用时<strong>直接返回</strong>该单例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化静态成员变量,该实例在类加载时就被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Single</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公有的静态方法返回实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡。</li><li>优点：没有任何锁，执行效率高，线程安全</li><li>缺点：容易造成内存的浪费</li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式在<strong>需要使用</strong>对象时才创建单例对象，先判断单例对象否已经创建，如果已经创建就直接返回单例对象，否则先执行实例化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Single1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的时候通过类.方法的形式返回单例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Single</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>懒汉式只在需要的时候才通过类.方法的形式创建单例对象，解决了饿汉式内存浪费的问题</li><li>懒汉式<strong>需要使用 synchronized 关键字加锁，如果不加锁会出现问题：在单例对象还没有初始化时，多个线程同时调用该方法，就会创建多个对象，违反了单例模式的设计规则</strong></li><li>如果在静态方法上加锁，在多线程下会导致并行变串行，性能较低</li></ul><p><strong>每次获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例。<strong>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</strong></p><h3 id="双检锁懒汉式-重点"><a href="#双检锁懒汉式-重点" class="headerlink" title="双检锁懒汉式(重点)"></a>双检锁懒汉式(重点)</h3><p><strong>Double Check（双重校验） + Lock（加锁）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;   <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 volatile 关键字修饰单例对象，保证单例对象的修改对所有线程可见</strong>。</li><li><strong>只对单例对象初始化的步骤加锁，既不会出现创建多个对象的情况，也不影响多线程下的并发执行</strong>。</li></ul><p>使用 volatile 防止指令重排：</p><p>JVM 中会经过三步：</p><p>（1）为 singleton 分配内存空间</p><p>（2）初始化 singleton 对象</p><p>（3）将 singleton 指向分配好的内存空间</p><p>JVM 在 最终结果正确的情况下，可以不按照程序编码的顺序执行语句，以提高程序的性能。</p><p>在这三步中，第2、3步可能会指令重排序，导致创建对象的顺序变为1-3-2。当多个线程获取对象时，线程A正在创建对象的过程中，执行了1、3步骤，此时线程B判断singleton不为空，获取到未初始化的singleton对象，就会报NPE异常。</p><img src="/./res\aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTIyMzkwNzk3LTRkZjBkMDA4LTM3MmMtNDkxZi04YjlhLWY4NjBmODAzNzFhYi5wbmc" alt="image.png" style="zoom:67%;"><h3 id="枚举模式-最安全"><a href="#枚举模式-最安全" class="headerlink" title="枚举模式(最安全)"></a>枚举模式(最安全)</h3><p><a href="https://blog.csdn.net/LoveLion/article/details/110983839">单例模式之枚举实现_LoveLion的博客-CSDN博客_枚举实现单例模式</a></p><ul><li><p>将类定义为枚举类，在枚举类中仅定义一个对象，<strong>Java 虚拟机会保证枚举对象的唯一性，从而实现单例模式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是枚举类型的单例模式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全。</span></span><br></pre></td></tr></table></figure></li><li><p>将已有的类改造为单例类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">SingletonEnum</span><span class="params">()</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先将Singleton类的构造函数设置为private私有的，然后在Singleton类中定义一个静态的枚举类型SingletonEnum。</li><li>SingletonEnum中定义了枚举类型的实例对象Singleton，再按照单例模式的要求在其中定义一个Singleton类型的对象instance，其初始值为null；</li><li>将 SingletonEnum 的构造函数改为私有的，在私有构造函数中创建一个Singleton的实例对象；最后在 getInstance() 方法中返回该对象。</li><li>在实现过程中，<strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong>。</li></ul></li></ul><p><strong>枚举实现单例模式的优势在哪里？</strong></p><p><strong>优势1</strong>：代码对比饿汉式与懒汉式更加简洁。</p><p><strong>优势2</strong>：不需要做任何额外的操作去保证对象单一性与线程安全性</p><p><strong>程序启动时会调用 Singleton 的构造器实例化一个 Singleton 对象赋给 INSTANCE，之后再也不会实例化</strong>。</p><p><strong>优势3</strong>：使用枚举可以防止调用者使用<strong>反射</strong>、<strong>序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p><ul><li><p><strong>防反射</strong>：枚举类默认继承 Enum 类，利用反射调用 newInstance() 时，会判断该类是否是枚举类，如果是就抛出异常。</p></li><li><p><strong>防止反序列化创建多个枚举对象</strong>：Singleton 对象的枚举类型和枚举名字都是唯一的，所以在序列化时，仅将枚举的<strong>类型和名字</strong>输出到文件中。在反序列化成对象时，<strong>利用 Enum 类的 valueOf(String name) 方法</strong>，根据名字查找对应的枚举对象。</p></li></ul><p>小结：</p><p>（1）Enum 类内部使用 Enum 类型判定防止通过反射创建多个对象</p><p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），通过 valueOf() 方法匹配枚举名找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p><p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与饿汉式单例有异曲同工之妙。</p><h3 id="破坏单例模式的几种方式"><a href="#破坏单例模式的几种方式" class="headerlink" title="破坏单例模式的几种方式"></a>破坏单例模式的几种方式</h3><p>除了枚举单例，其他几种单例模式都会在以下几种情况中被破坏。</p><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><ul><li><p>如果单例类实现了 Cloneable 接口，且没有重写父类的 clone() 方法，调用 clone() 方法的话就会生成一个新对象，破坏单例模式。<strong>因为 clone() 方法不会调用构造函数，而是直接从内存中 copy 内存区域，所以单例模式的类切记不要实现 Cloneable 接口。</strong></p></li><li><p>防止克隆攻击的解决方案：重写父类的 clone() 方法，clone() 方法直接去调用 getInstance()。</p></li></ul><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><ul><li><p>如果单例类实现了 Serializable 接口，将单例对象序列化与反序列化后就会得到一个新对象，破坏单例模式。因为<strong>在反序列化时，如果单例类实现了 Serializable 接口，就会通过 newInstance() 方法通过反射创建一个新对象</strong>。</p></li><li><p>解决方案：自定义 readResolve() 方法。因为如果单例类实现了 Serializable 接口且自定义了 readResolve() 方法，就会将 readResolve() 方法返回的对象作为反序列化的结果。</p></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>工厂模式</strong>是最常用的设计模式之一，属于创建型模式，提供了创建对象的最佳方式。工厂模式创建对象时不会对客户端暴露创建逻辑，即当调用者想要创建对象时，只需告诉工厂类，由工厂类去创建对象，调用者不用自己创建，也无需知道是如何创建的。</p><p>工厂模式分为<strong>简单工厂模式</strong>，<strong>工厂方法模式</strong>，<strong>抽象工厂模式</strong>，都属于创建型模式。主要功能都是将对象的实例化部分抽取出来，以降低系统耦合度。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li><p><strong>介绍</strong></p><p>简单工厂模式将不同对象的创建进行了简单的封装，也就是将不同对象的创建操作全都放到一个类中，这个类就是简单工厂类；当需要某个对象时，只需让简单工厂类根据需求创建相应的对象即可。</p></li><li><p><strong>优缺点</strong></p><ul><li><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需的类的对象。使用者不用知道怎么创建对象，使得各模块各司其职，降低了系统耦合性。</li><li><strong>缺点：</strong>扩展性差，违背了<strong>开闭原则</strong>。新增产品时，需要修改工厂类。</li></ul></li><li><p><strong>实现案例</strong></p><ul><li><p>创建一个电脑抽象类</p></li><li><p>创建继承了电脑抽象类的，具体的不同品牌的电脑的实体类</p></li><li><p>创建一个电脑工厂类，根据电脑的名字创建具体的电脑</p></li><li><p><strong>测试：使用工厂生产不同品牌电脑并使用</strong></p></li></ul></li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul><li><p><strong>介绍</strong></p><p>工厂方法模式中，工厂类下面还有很多子工厂类，对象是由子工厂类创建的。工厂方法模式改进了简单工厂模式，需要一个新产品时，只需扩展一个新的子工厂类即可，不用修改原有的代码，符合开闭原则。</p></li><li><p><strong>优缺点</strong></p><ul><li><strong>优点</strong>：<strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加对应的产品类和子工厂类即可，无需修改原有的代码。<strong>也符合单一职责原则</strong>，每个子工厂类只负责一种产品，而不是一个工厂生成所有商品。</li><li><strong>缺点：</strong>新增产品时需要提供对应的子工厂类，系统中类的个数将会成倍增加，增加了系统的复杂性。</li></ul></li><li><p><strong>实现案例</strong></p><ul><li><p><strong>创建一个电脑抽象类</strong></p></li><li><p><strong>创建继承了电脑抽象类的，具体的不同品牌的电脑的实体类</strong></p></li><li><p><strong>创建一个电脑抽象工厂类</strong></p></li><li><p><strong>根据不同的电脑品牌创建电脑抽象工厂类的子类</strong></p></li><li><p><strong>测试：使用不同子工厂类生产不同品牌电脑并使用</strong></p></li></ul></li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul><li><p><strong>介绍</strong></p><p>工厂方法模式针对某一类产品，而抽象工厂模式可以针对多类产品。即工厂方法模式解决的是生产不同品牌的同一类型的产品，而抽象工厂模式解决的是生产不同品牌的多种类型的产品。</p></li><li><p><strong>优缺点</strong></p><ul><li><strong>优点：</strong>抽象工厂类创建了多个类型的产品，有需求时可以创建相关产品子类和子工厂类来获取。</li></ul></li><li><p><strong>缺点：</strong>扩展新种类产品困难。抽象工厂模式需要在抽象工厂类中提前确定需要的产品种类，如果需要的产品种类没有在抽象工厂类中提前确定，就需要去修改抽象工厂类，一旦修改了抽象工厂类，那么所有的子工厂类也需要修改，扩展不方便。</p></li><li><p><strong>实现案例</strong></p><ul><li><p><strong>创建各种类型的电脑抽象类</strong></p></li><li><p><strong>创建具体的不同品牌的各种类型的电脑实体类</strong></p></li><li><p><strong>创建一个电脑的抽象工厂类</strong></p></li><li><p><strong>创建电脑抽象工厂类的子类（根据不同的电脑品牌）</strong></p></li><li><p><strong>测试：使用不同子工厂创建不同品牌的不同种类的电脑</strong></p></li></ul></li></ul><p>​<img src="https://img-blog.csdnimg.cn/20201125000745500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzMyMTk1,size_4,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 基础八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> Java基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架后端八股</title>
      <link href="/2024/11/20/%E5%90%8E%E7%AB%AF/"/>
      <url>/2024/11/20/%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h2><h3 id="Spring概念"><a href="#Spring概念" class="headerlink" title="Spring概念"></a>Spring概念</h3><p>Spring 是一款<strong>开源的轻量级 Java 开发框架</strong>，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>Spring 提供的核心功能主要是 <strong>IoC 和 AOP</strong>。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP (Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><h3 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p><img src="/.%5Cres%5C20200831175708.png" alt="Spring5.x主要模块"></p><h4 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h4><p><strong>Spring 框架的核心模块，主要为 IoC 依赖注入功能提供支持</strong>。Spring 其他所有功能都需要依赖于该模块。</p><ul><li><strong>spring-core</strong> ：Spring 框架的核心工具类，Spring 的其他模块基本都需要依赖于该模块。</li><li><strong>spring-beans</strong> ：<strong>对 bean 的创建、配置和管理等功能提供支持。</strong></li><li><strong>spring-context</strong> ：对国际化、事件传播、资源加载等功能提供支持。</li><li><strong>spring-expression</strong> ：对表达式语言（Spring Expression Language） SpEL 提供支持，只依赖 core 模块，可以单独使用。</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li><strong>spring-aspects</strong> ：为集成 AspectJ 提供支持。</li><li><strong>spring-aop</strong> ：提供<strong>面向切面编程的实现。</strong></li><li><strong>spring-instrument</strong> ：为 JVM 添加代理（agent）。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限</li></ul><h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><ul><li><strong>spring-messaging</strong> 是 Spring4.0 新加入的模块，<strong>为 Spring 框架集成一些基础的报文传送应用。</strong></li></ul><h4 id="Data-Access-Intergration"><a href="#Data-Access-Intergration" class="headerlink" title="Data Access &#x2F; Intergration"></a>Data Access &#x2F; Intergration</h4><ul><li><strong>spring-jdbc</strong> ：<strong>提供访问数据库的抽象 JDBC。</strong>不同的数据库有自己独立的 API 用于操作数据库， JDBC 屏蔽了不同数据库的影响，Java 程序只需和 JDBC API 交互即可访问不同数据库。</li><li><strong>spring-tx</strong> ：提供对事务的支持。</li><li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。Spring Framework 4.1 以后还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul><li><strong>spring-web</strong> ：<strong>为 Web 功能的实现提供最基础的支持。</strong></li><li><strong>spring-webmvc</strong> ：提供 Spring MVC 的实现。</li><li><strong>spring-websocket</strong> ：提供对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 引入的响应式框架。与 Spring MVC 不同，WebFlux 不需要 Servlet API，是完全异步的。</li></ul><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><ul><li><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p></li></ul><h3 id="Spring-Spring-MVC-Spring-Boot"><a href="#Spring-Spring-MVC-Spring-Boot" class="headerlink" title="Spring &#x2F; Spring MVC &#x2F; Spring Boot"></a>Spring &#x2F; Spring MVC &#x2F; Spring Boot</h3><ul><li><p><strong>Spring</strong> 是一款<strong>开源的轻量级 Java 开发框架</strong>，旨在简化 J2EE 企业应用程序开发，Spring 中包含多个功能模块，其中最重要的是 Spring-Core（为 IoC 依赖注入功能提供支持） 模块， Spring 中的其他模块的功能实现基本都需要依赖于该模块。</p></li><li><p><strong>Spring MVC</strong> 是 Spring 中的重要模块，让 <strong>Spring 能够快速构建 MVC 架构的 Web 程序</strong>。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，核心思想是将<strong>业务逻辑、数据、显示</strong>分离来组织代码。</p></li><li><p><strong>Spring Boot</strong> 旨在简化 Spring 开发（减少配置文件，开箱即用！）。因为使用 Spring 开发时需要用 XML 或 Java 进行显式配置，过于麻烦。于是，Spring Boot 诞生了！</p></li></ul><h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><h3 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h3><p>Bean 指<strong>被 IoC 容器管理的对象</strong>，可以通过 <strong>xml 配置文件、注解或 Java 配置类</strong>告诉 IoC 容器要管理哪些对象。</p><h3 id="声明Bean的方式"><a href="#声明Bean的方式" class="headerlink" title="声明Bean的方式"></a>声明Bean的方式</h3><ul><li><code>@Component</code> ：被 <code>@Component</code> 注解标注的类会被注册为 <code>Bean</code>。如果一个类不知道属于哪个层，可以使用 <code>@Component</code>  注解标注。</li><li><code>@Repository</code> : 在 Dao 层使用， Dao 层主要用于数据库相关操作。</li><li><code>@Service</code> : 在 Service 层使用，Service 层主要涉及业务逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 在 Controller 层使用，Controller 层主要用于接受用户请求并调用 Service 层返回数据给前端。</li></ul><h3 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h3><ul><li><strong><code>@Component</code> 注解作用于类，<code>@Bean</code>注解作用于方法。</strong></li><li><code>@Component</code> 通常通过<strong>类路径扫描来自动侦测并自动装配到 Ioc 容器中</strong>（使用 <code>@ComponentScan</code> 注解定义要扫描的路径，从中找出被 <code>@Component</code> 注解标注的类并自动装配到 Ioc  容器中）。</li><li>被 <code>@Bean</code> 注解标注的方法通常会<strong>在方法中产生 Bean 对象</strong>，然后再把 Bean 对象放入 IOC 容器中。被 <code>@Bean</code> 注解标注的方法 Spring 只会调用一次。</li><li><strong><code>@Bean</code> 的自定义性比 <code>@Component</code> 更强</strong>，很多地方只能通过 <code>@Bean</code> 注解来注册 bean。比如需要将第三方库中的类装配到 <code>Spring</code>容器中，就只能通过 <code>@Bean</code>来实现。</li></ul><h3 id="注入-Bean-的方式"><a href="#注入-Bean-的方式" class="headerlink" title="注入 Bean 的方式"></a>注入 Bean 的方式</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h3 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h3><ul><li>@Autowired 是 <strong>Spring 提供的注解</strong>，@Resource 是 <strong>JDK 提供的注解</strong></li><li>@Autowired 默认注入方式是 <strong>byType 根据类型匹配</strong>，如果一个接口有多个实现类，byType 方式会注入失败，就需要 <strong><code>byName</code> 根据名称匹配</strong>，名称通常就是类名的首字母小写。建议使用 @Autowired + @Qualifier，通过 @Qualifier 注解来显式指定名称。</li><li>@Resource 默认注入方式是 <strong>byName</strong>，其次是 <strong>byType</strong>。@Resource 有两个属性 name 和 type，仅指定 name 属性则注入方式为 byName，如果仅指定type 属性则注入方式为byType，如果同时指定 <code>name</code>  和 <code>type</code> 属性（不建议这么做）则注入方式为 <code>byType</code> + <code>byName</code>。</li></ul><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中每个类只有唯一的 Bean 实例。Spring 中的 Bean 默认是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建新的 Bean 实例。也就是连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用）: 每一次 HTTP 请求都会产生新的 Bean（请求 Bean），该 Bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用） : 每一次来自新 session 的 HTTP 请求都会产生一个 Bean（会话 Bean），该 Bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用）： Web 应用启动时创建一个 Bean（应用 Bean），该 Bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用）：每一次 WebSocket 会话都会产生一个新的 Bean。</li></ul><p>配置方式：</p><p><strong>xml 方式</strong>：通过 scope 属性配置 bean 的作用域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注解方式</strong>：@Bean + @Scope 注解配置bean的作用域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例-Bean-的线程安全问题"><a href="#单例-Bean-的线程安全问题" class="headerlink" title="单例 Bean 的线程安全问题"></a>单例 Bean 的线程安全问题</h3><ul><li><p><strong>单例 Bean 存在线程安全问题</strong>，<strong>多个线程同时操作一个单例 Bean 时存在资源竞争</strong>。</p><p>常见的有两种解决办法：</p><ol><li>Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义 <code>ThreadLocal</code> 变量，将可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>大部分 Bean 都是无状态（<strong>没有实例变量</strong>）的（如 Dao、Service），这种情况下 Bean 是线程安全的。</p><h4 id="无状态和有状态"><a href="#无状态和有状态" class="headerlink" title="无状态和有状态"></a>无状态和有状态</h4><ul><li><strong>有状态会话 Bean</strong>  ：有状态就是有数据存储功能，有状态 Bean 就是有可变实例变量的 Bean ，可以保存数据，是<strong>非线程安全</strong>的。每个用户开始都会得到一个初始 Bean，在用户生存期内，Bean 会保持用户的信息，即“有状态”。一旦用户灭亡，Bean 的生命期也结束。</li><li><strong>无状态会话 Bean</strong>  ：无状态 Bean 就是没有可变实例变量的 Bean，不能保存数据，是<strong>线程安全</strong>的。无状态 Bean 没有特定的用户，不能保持用户的信息，所以叫无状态 Bean。无状态会话 Bean 并非没有实例变量。</li></ul></li></ul><h4 id="解决有状态Bean的线程安全问题"><a href="#解决有状态Bean的线程安全问题" class="headerlink" title="解决有状态Bean的线程安全问题"></a>解决有状态Bean的线程安全问题</h4><p>Spring对bean的配置中有四种配置方式，我们只说其中两种：singleton单例模式、prototype原型模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;testManager&quot;</span> class=<span class="string">&quot;com.sw.TestManagerImpl&quot;</span> scope=<span class="string">&quot;singleton&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;testManager&quot;</span> class=<span class="string">&quot;com.sw.TestManagerImpl&quot;</span> scope=<span class="string">&quot;prototype&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>默认的配置是 singleton。</p><p>singleton 表示该 bean 全局只有一个实例。</p><p>prototype 表示该 bean 每次被注入时，都会重新创建一个实例，适用于有状态的Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果有两个用户同时访问</span><br><span class="line"></span><br><span class="line">假定为user1,user2</span><br><span class="line"></span><br><span class="line">当user1 调用到程序中的<span class="number">1</span>步骤的时候，该Bean的私有变量user被付值为user1</span><br><span class="line"></span><br><span class="line">当user1的程序走到<span class="number">2</span>步骤的时候，该Bean的私有变量user被重新付值为user1_create</span><br><span class="line"></span><br><span class="line">理想的状况，当user1走到<span class="number">3</span>步骤的时候，私有变量user应该为user1_create;</span><br><span class="line"></span><br><span class="line">但如果在user1调用到<span class="number">3</span>步骤之前，user2开始运行到了<span class="number">1</span>步骤了，由于单态的资源共享，则私有变量user被修改为user2</span><br><span class="line"></span><br><span class="line">这种情况下，user1的步骤<span class="number">3</span>用到的user.getId()实际用到是user2的对象。</span><br></pre></td></tr></table></figure><p>对于这种情况我们可以这样解决</p><p>1.将有状态的 bean 配置成 <strong>prototype</strong> 模式，这样每个线程拿到的都是新的 Bean 实例，但是这样会产生消耗较多的内存空间。</p><p>2.在类中定义 <code>ThreadLocal</code> 变量，给每条线程设置变量副本。</p><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><ul><li>加载 Spring 配置文件，通过反射生成 Bean 实例。</li><li>Bean 实例化后调用属性的 set 方法设置对象属性。</li><li>检查当前 Bean 是否实现了 <code>xxxAware</code> 接口，执行相应的 set 方法。<ul><li>如果实现了 <code>BeanNameAware</code> 接口，Spring 会调用 <code>setBeanName()</code> 方法将当前 Bean 的名字作为属性传入。</li><li>如果实现了 <code>BeanFactoryAware</code> 接口，Spring 将调用 <code>setBeanFactory()</code> 方法将 BeanFactory 容器实例传入。</li><li>如果实现了 <code>ApplicationContextAware</code> 接口，Spring 将调用 <code>setApplicationContext()</code> 方法将当前 Bean 所在应用上下文的引用传入。</li></ul></li><li><strong>BeanPostProcessor 的前置处理</strong>：检查当前 Bean 是否实现了 <code>BeanPostProcessor</code> 接口，如果实现了 Spring 将调用 <code>postProcessBeforeInitialization()</code> 方法。</li><li>检查当前 Bean 是否实现了 <code>InitializingBean</code> 接口，如果实现了 Spring 将调用 <code>afterPropertiesSet()</code> 方法。</li><li>检查当前 Bean 在配置文件中的定义是否包含 <code>init-method</code> 属性，如果有则调用相应的方法。</li><li><strong>BeanPostProcessor的后置处理</strong>：检查当前 Bean 是否实现了 <code>BeanPostProcessor</code>  接口，如果实现了 Spring 将调用 <code>postProcessAfterInitialization()</code> 方法。</li><li>此时 Bean 已经准备就绪，可以被应用程序使用了，并且将一直驻留在应用上下文中，直到应用上下文被销毁。</li><li>销毁 Bean 时，如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring  将调用 <code>destroy()</code> 方法。如果 Bean 在配置文件中的定义包含 <code>destroy-method </code> 属性，也会调用相应的方法。</li></ul><p><img src="/.%5Cres%5Cb5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期"></p><h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="IOC的定义"><a href="#IOC的定义" class="headerlink" title="IOC的定义"></a>IOC的定义</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486938&idx=1&sn=c99ef0233f39a5ffc1b98c81e02dfcd4&chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&token=1736772241&lang=zh_CN#rd">面试被问了几百遍的 IoC 和 AOP )</a></p><p><strong>IoC（Inverse of Control:控制反转）将原来在程序中手动创建对象的控制权交给 Spring 框架管理。</strong> 由 IoC 容器来管理对象间的依赖关系，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p><p><strong>IoC 容器是 Spring 实现 IoC 的载体，IoC 容器就像一个工厂。需要创建对象时，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何创建的。</strong></p><p>Spring 启动时会加载配置文件，使用反射机制来创建和初始化对象，并将创建的对象存入 Spring 容器中，需要时直接从容器中注入即可。</p><p><strong>IoC 容器实际上是 Map，Map 中存放的是各种对象。</strong></p><p><img src="/.%5Cres%5Cfrc-365faceb5697f04f31399937c059c162.png" alt="img"></p><h3 id="IOC-的实现"><a href="#IOC-的实现" class="headerlink" title="IOC 的实现"></a>IOC 的实现</h3><ul><li><strong>导入 Spring 依赖</strong></li></ul><p>新建 Maven 程序，在 pom.xml 中引入 Spring 相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-context 中引入了 aop、core、beans 和 expression</p><ul><li><strong>新建 Person 类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法person()被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了setAge()方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了setName()方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>创建Spring配置文件</strong></li></ul><p>在 resources 目录下新建 Spring 的配置文件 application.xml，并将 Person 类添加到配置文件中，由 Spring 来管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.whut.entity.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hwf&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>① <code>&lt;bean&gt;</code> 标签代表将该类的对象交由 Spring 来管理。</p><p>② bean 标签的作用相当于创建了一个类的对象，id 为对象名，class 为对象类型。</p><p>③ 对象的属性由 <code>&lt;property&gt;</code> 标签定义，name 表示属性名，如果属性为基本数据类型，则使用 value 来赋值，如果属性为引用数据类型，则使用 ref 来赋值。</p><p>④ 属性的设置是利用 set 方法来注入的，所以必须有对应的 set() 方法</p><ul><li><strong>从 IOC 容器中获取对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">springApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以读取XML文件的形式来获取Spring的上下文对象</span></span><br><span class="line">        <span class="comment">//这一步会读取xml配置文件，创建和初始化配置文件中的对象并存入Spring容器中</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从容器中获取对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOC容器的启动过程"><a href="#IOC容器的启动过程" class="headerlink" title="IOC容器的启动过程"></a>IOC容器的启动过程</h3><p><a href="https://javadoop.com/post/spring-ioc">Spring IOC 容器源码分析_Javadoop</a></p><p><a href="https://blog.csdn.net/hbs321123/article/details/38824091">FileSystemXmlApplicationContext</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:/project/bean.xml&quot;</span>);<span class="comment">//根据具体路径加载文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:/*.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>注：其中 <code>FileSystemXmlApplicationContext</code> 和 <code>ClassPathXmlApplicationContext</code> 与 <code>BeanFactory</code> 的 xml 文件定位方式一样是基于路径的。<br>BeanFactory 是生产 bean 的工厂，负责生产和管理 bean 实例，ApplicationContext 其实就是一个 BeanFactory。</p><ul><li><p><strong>ClassPathXmlApplicationContext(String configLocation)</strong></p><p>调用上述的构造器时会进入如下重载的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>super(parent)</code>：调用父类构造器，如果当前应用环境存在父环境，则建立两者的父子环境关系。</li><li><code>setConfigLocations(configLocations)</code>：对配置文件的路径进行处理，添加到<code>configLocations</code>数组中</li><li><strong>refresh()<strong>：</strong>核心的初始化方法</strong>。为什么叫 refresh()，而不叫 init() ？因为 ApplicationContext 建立起来以后，可以通过 refresh() 方法来重建，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</li></ul></li><li><p><strong>refresh()</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，xml 配置文件会被解析成一个个 BeanDefinition，并注册到 BeanFactory 中</span></span><br><span class="line">      <span class="comment">// 此时 Bean 还没有初始化，只是将配置信息提取出来了</span></span><br><span class="line">      <span class="comment">// 注册是将这些配置信息保存到注册中心中(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 子类可以在这步添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 接口的实现类</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>obtainFreshBeanFactory()<strong>：</strong>初始化 BeanFactory，加载并注册 Bean；注意这一步结束后 Bean 还没有初始化</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**refreshBeanFactory()**：关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，就销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 可以有多个，但这里说的是当前 ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下面这两个方法很重要</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据配置文件加载 Bean，然后放到 BeanFactory 中。</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① **createBeanFactory()**：初始化一个DefaultListableBeanFactory</p><p>② **customizeBeanFactory(beanFactory)**：配置BeanFactory的两个配置属性：是否允许Bean覆盖、是否允许循环引用</p><p>③ <strong>loadBeanDefinitions(beanFactory)：</strong>根据配置文件加载 Bean，然后放到 BeanFactory 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader，用来加载各个 Bean</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**loadBeanDefinitions(beanDefinitionReader)**：通过初始化的 Reader 加载 xml 配置并解析成一个个 BeanDefinition，再将 BeanDefinition 注册到BeanFactory，即使用一个 beanDefinitionMap 来存储 BeanDefinition。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">    <span class="comment">//configResources为null</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//configLocations为之前加载过的配置文件路径数组，不为null</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//所以后续走的是loadBeanDefinitions(configLocations)</span></span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**BeanDefinition()**：BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的 Bean 都会转换成 BeanDefinition 存在于 Spring 的 BeanFactory 中。BeanDefinition 中保存了 Bean 的信息，比如 Bean 指向哪个类、是否是单例、是否懒加载、依赖了哪些 Bean 等。</li></ul><p>到此为止完成了 Bean 容器的初始化、加载和注册 Bean，但是还没有初始化 Bean，下面是 Bean 的初始化过程</p><ul><li>**prepareBeanFactory(beanFactory)**：实例化 BeanFactory 后的相关操作，会设置 BeanFactory 的类加载器，初始化所有实现了 BeanFactoryPostProcessor 接口的 Bean 并调用其 postProcessBeanFactory(factory) 方法，并“手动”注册了一些特殊的 Bean，如 environment、systemProperties 等</li><li>**finishBeanFactoryInitialization(beanFactory)**：初始化所有 singleton beans (懒加载的除外)</li></ul><h3 id="Bean的定义覆盖"><a href="#Bean的定义覆盖" class="headerlink" title="Bean的定义覆盖"></a>Bean的定义覆盖</h3><p>BeanFactory 的属性 allowBeanDefinitionOverriding：<strong>是否允许具有相同名称的 Bean 覆盖之前的 Bean</strong>。</p><ul><li>**设为 true (默认为 true)**：同一个配置文件中不能定义两个相同名称的 Bean，否则会报错；不同配置文件中可以定义两个相同名称的 Bean，只不过后加载的配置文件中的 Bean 会覆盖掉前面加载的配置文件中的 Bean。</li><li><strong>设为false</strong>：不允许相同名称的 Bean 加载到 Spring 容器中，否则直接报错。</li></ul><h3 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h3><p>参考：<a href="https://blog.csdn.net/qq_19801061/article/details/118991633">https://blog.csdn.net/qq_19801061/article/details/118991633</a></p><p>循环依赖就是循环引用，即两个或两个以上的 bean 互相持有对方的引用形成闭环。如A依赖于B，B依赖于C，C又依赖于A。</p><p><strong>Spring 可以通过三级缓存机制解决单例模式下的循环依赖问题</strong>。</p><p>Spring中循环依赖的三种情况：</p><p>① <strong>构造器循环依赖</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassA</span><span class="params">(ClassB classB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classB = classB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassB</span><span class="params">(ClassA classA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classA = classA;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 无法解决构造器循环依赖问题，会报出 BeanCurrentlylnCreationException 异常。</p><p>② <strong>单例模式下的属性注入循环依赖</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Spring 可以通过三级缓存机制解决单例模式下的属性注入循环依赖问题</strong>。</p><p>③ <strong>多例模式下的属性注入循环依赖</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 无法解决多例模式下的属性注入循环依赖问题。在多例模式下，一个类存在多个对象，因此 Spring 注入对象时，不知道选择哪个对象进行属性注入。</p><h4 id="三级缓存机制"><a href="#三级缓存机制" class="headerlink" title="三级缓存机制"></a><strong>三级缓存机制</strong></h4><ul><li><strong>三级缓存对象</strong></li></ul><p>Spring 有三个缓存，用于存储单例 Bean，<strong>三个缓存彼此互斥，不会同时存储同一个单例 Bean</strong>。调用 getBean() 方法会依次从三个缓存中获取指定单例 Bean， 读取顺序是一级缓存 &#x3D;&gt; 二级缓存 &#x3D;&gt; 三级缓存。三级缓存对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 一级缓存：存储经历了完整生命周期的单例 Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 二级缓存：存储提前曝光的已经实例化但未初始化的单例 Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 三级缓存：存储已经实例化但未初始化的单例 Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><strong>单例对象的初始化过程</strong>：</p><ul><li><strong>createBeanInstance：实例化</strong>，<strong>调用构造方法实例化对象</strong>。</li><li><strong>populateBean：填充属性</strong>，填充单例 bean 的属性。</li><li><strong>initializeBean</strong>：<strong>初始化</strong>，调用 spring xml 中 init-method 属性对应的 init() 方法。</li></ul><h4 id="A-B-A循环注入的过程"><a href="#A-B-A循环注入的过程" class="headerlink" title="A-B-A循环注入的过程"></a><strong>A-B-A循环注入的过程</strong></h4><p>A 先实例化并存储到三级缓存 singletonFactories 中，进行属性注入时发现自己依赖于对象 B，就尝试获取对象 B，但是查询了一二三级缓存都没有发现 B，于是去创建 B 对象。B 实例化后发现自己又依赖于对象 A，于是尝试获取对象 A，在一级缓存 singletonObjects 中发现没有，在二级缓存 earlySingletonObjects 中发现也没有，最后在三级缓存 singletonFactories 中找到了对象 A，就将对象 A 从三级缓存移动到二级缓存，在拿到对象 A 后 B 顺利完成了初始化，完全初始化之后就将自己放入一级缓存 singletonObjects 中。此时对象 A 通过查询一级缓存拿到了对象 B，也顺利完成初始化，然后也进入一级缓存 singletonObjects 中。</p><p><strong>加入三级缓存的前提是完成了实例化，即执行了构造方法，这也是 Spring 无法解决构造器循环依赖的原因</strong>。</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="AOP定义"><a href="#AOP定义" class="headerlink" title="AOP定义"></a>AOP定义</h3><p>AOP(面向切面编程)能够将<strong>与业务无关，却被业务模块共同调用的逻辑（如事务处理、日志管理、权限校验等）封装起来</strong>，从而减少重复代码，降低模块间的耦合度，调高可拓展性和可维护性。</p><p>Spring AOP 基于<strong>动态代理</strong>创建代理对象。</p><ul><li><p>如果要代理的对象<strong>实现了某个接口</strong>，Spring AOP 会使用 <strong>JDK Proxy</strong> 去创建代理对象。</p></li><li><p>如果要代理的对象<strong>没有实现接口</strong>，就无法使用 JDK Proxy 进行代理，Spring AOP 会使用 <strong>Cglib</strong> 生成被要代理的对象的子类作为代理对象。</p><p>如下图所示：</p></li></ul><p><img src="/.%5Cres%5C230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"></p><p>AOP 切面编程的专业术语：</p><table><thead><tr><th align="left">术语</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">目标(Target)</td><td align="center">被通知(代理)的对象</td></tr><tr><td align="left">代理(Proxy)</td><td align="center">向目标对象应用通知之后创建的代理对象</td></tr><tr><td align="left">连接点(JoinPoint)</td><td align="center">目标对象所属类中定义的所有方法均为连接点</td></tr><tr><td align="left">切入点(Pointcut)</td><td align="center">被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td align="left">通知(Advice)</td><td align="center">增强的逻辑代码，即拦截到目标对象的连接点后要做的事</td></tr><tr><td align="left">切面(Aspect)</td><td align="center">切入点(Pointcut) + 通知(Advice)</td></tr><tr><td align="left">织入(Weaving)</td><td align="center">将通知应用到目标对象，进而生成代理对象的过程</td></tr></tbody></table><h3 id="AOP体系与概念"><a href="#AOP体系与概念" class="headerlink" title="AOP体系与概念"></a>AOP体系与概念</h3><h4 id="AOP主要做三件事情"><a href="#AOP主要做三件事情" class="headerlink" title="AOP主要做三件事情"></a><strong>AOP主要做三件事情</strong></h4><p>① 在哪里切入，即非业务操作在哪些业务代码中执行。</p><p>② 什么时候切入，在业务代码执行前还是执行后切入。</p><p>③ 切入后做什么事，比如权限校验、日志管理等</p><h4 id="AOP相关概念和注解"><a href="#AOP相关概念和注解" class="headerlink" title="AOP相关概念和注解"></a><strong>AOP相关概念和注解</strong></h4><p>① Aspect：切面，可以在切面上定义切入点和通知。使用 @Aspect 定义切面类。</p><p>② Pointcut：切入点，被切面拦截 &#x2F; 增强的连接点。使用 @Pointcut 定义切入点。切入点分为 <code>execution</code> 方式和 <code>annotation</code> 方式，前者用路径表达式指定要织入切面的类，后者在被指定注解修饰的代码中织入切面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execution()方式:指定路径下的类织入切面</span></span><br><span class="line"><span class="comment">//第一个 * 号的位置：表示返回值类型，* 表示所有类型。</span></span><br><span class="line"><span class="comment">//包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，在本例中指 com.mutest.controller包、子包下所有类的方法</span></span><br><span class="line"><span class="comment">//第二个 * 号的位置：表示类名，* 表示所有类</span></span><br><span class="line"><span class="comment">//*(..)：这个星号表示方法名，* 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.mutest.controller..*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//annotation()方式：被指定注解修饰的代码织入切面</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(org.springframework.web.bind.annotation.PostMapping)&quot;)</span></span><br></pre></td></tr></table></figure><p>③ Advice：通知，包括切入时机和增强内容。增强内容就是要做什么事，比如权限校验和日志管理。切入时机就是什么时候切入，分为前置处理、后置处理等。</p><ul><li>@Before：前置处理，在业务代码执行前执行指定的处理方法。</li><li>@After：后置处理，在业务代码执行后执行指定的处理方法。</li><li>@Around：环绕处理。</li><li>@AfterReturning：和 @After 类似，区别在于 @AfterReturning 可以捕获业务代码执行完成后的返回值，对返回值进行增强处理。</li><li>@AfterThrowing：被切入的方法抛出异常时执行指定的处理方法，在该方法中可以做异常处理。</li></ul><p>④ Joint Point：连接点，目标对象所属类中定义的所有方法均为连接点。</p><p>⑤ Weaving：织入，将通知应用到目标对象，进而生成代理对象的过程。</p><h3 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h3><p><strong>Spring AOP 是运行时增强，AspectJ 是编译时增强。</strong> Spring AOP 基于动态代理，AspectJ 基于字节码操作。</p><p>Spring AOP 集成了 AspectJ ，AspectJ 算是 Java 生态系统中最完整的 AOP 框架。AspectJ 相比 Spring AOP 功能更强大，Spring AOP 相比 AspectJ 更简单，</p><p>如果切面比较少，两者的性能差异就不大。切面多的话，最好选择 AspectJ ，会比 Spring AOP 快很多。</p><h3 id="AspectJ-定义的通知类型"><a href="#AspectJ-定义的通知类型" class="headerlink" title="AspectJ 定义的通知类型"></a>AspectJ 定义的通知类型</h3><ul><li><strong>Before</strong>：在目标对象的方法调用前触发。</li><li><strong>After</strong>：在目标对象的方法调用后触发。</li><li><strong>AfterReturning</strong>：在目标对象的方法调用完成，返回结果值后触发。</li><li><strong>AfterThrowing</strong>：在目标对象的方法抛出异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li><strong>Around</strong>：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，可以直接拿到目标对象和要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后执行指定的处理方法，甚至可以不调用目标对象的方法。</li></ul><h3 id="多个切面的执行顺序控制"><a href="#多个切面的执行顺序控制" class="headerlink" title="多个切面的执行顺序控制"></a>多个切面的执行顺序控制</h3><ul><li><strong>使用 <code>@Order</code> 注解直接定义切面顺序</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br></pre></td></tr></table></figure><ul><li><strong>实现 <code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ul><li>定义一个接口及其实现类</li><li>创建一个代理类，同样实现该接口</li><li>将目标对象注入代理类，然后在代理类的对应方法调用目标类中的对应方法。这样就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DogProxy</span> <span class="variable">dogProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        dogProxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个接口 Eatable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//定义一个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现类 Dog 实现接口 Eatable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//实现抽象方法eat</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个代理类同样实现 Eatable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogProxy</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//将代理对象作为代理类的一个属性</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogProxy</span><span class="params">(Dog dog)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//插入前置代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗在吃饭前要喝水&quot;</span>);</span><br><span class="line">        <span class="comment">//调用代理对象的方法</span></span><br><span class="line">        dog.eat();</span><br><span class="line">        <span class="comment">//插入后置代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗在吃饭后要运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a><strong>JDK动态代理</strong></h4><ul><li>定义一个接口及其实现类</li><li>定义一个类实现 InvocationHandler 接口并重写 invoke 方法，在 invoke 方法中调用目标类中的方法并自定义一些处理逻辑</li><li>通过 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 方法创建代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口Eatable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//定义一个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现类Dog实现接口Eatable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//实现抽象方法eat</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义InvocationHandler接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//target是被代理类的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法前的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前的操作&quot;</span>);</span><br><span class="line">        <span class="comment">//调用被代理类的原生方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法后的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后的操作&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理对象</span></span><br><span class="line">        <span class="type">Eatable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//MyInvocationHandler</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">Eatable</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Eatable)Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">        proxyInstance.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a><strong>CGLIB动态代理</strong></h4><ul><li>定义一个类</li><li>定义一个类实现 MethodInterceptor 接口并重写 intercept 方法，intercept 方法用于拦截增强目标类的方法，和 JDK 动态代理中的 invoke 方法类似</li><li>通过 Enhancer 类的 create() 方法创建代理对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个被CGLIB代理的代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现了MethodInterceptor的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//方法执行前的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">//调用被代理类的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="comment">//方法执行后的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer类的对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        <span class="comment">//设置拦截方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">//生成代理对象</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl) enhancer.create();</span><br><span class="line">        userService.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cglib-和-JDK-的-Proxy-区别"><a href="#Cglib-和-JDK-的-Proxy-区别" class="headerlink" title="Cglib 和 JDK 的 Proxy 区别"></a><strong>Cglib 和 JDK 的 Proxy 区别</strong></h4><ul><li>JDK 动态代理是实现目标对象的接口，Cglib 是继承目标对象。</li><li>JDK 和 Cglib 都在运行期生成字节码，JDK 直接写 Class 字节码，Cglib 使用 ASM 框架写 Class 字节码。Cglib 实现更复杂，生成代理类效率较低。</li><li>JDK 通过反射机制调用目标方法，Cglib 通过 FastClass 机制调用目标方法，Cglib 执行效率更高。</li></ul><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h4><p><img src="https://img-blog.csdnimg.cn/20201011154637538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vY2FzX3dhbmc=,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>Spring 不直接管理事务，而是提供多种事务管理器，将事务管理的职责委托给相应的持久化框架</strong>。Spring 通过 PlatformTransactionManager 接口为各个平台如 JDBC、Hibernate 等提供对应的事务管理器，事务管理器的具体实现由各个平台负责。具体的事务管理机制对 Spring 来说是透明的，所以 <strong>Spring 事务管理的一个优点就是能为不同的事务 API 提供统一的编程模型</strong>。</p><p>PlatformTransactionManager 接口的内容如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span>()...&#123;  </span><br><span class="line">    <span class="comment">// 由 TransactionDefinition 得到 TransactionStatus 对象</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException; </span><br><span class="line">    <span class="comment">// 提交</span></span><br><span class="line">    Void <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;  </span><br><span class="line">    <span class="comment">// 回滚</span></span><br><span class="line">    Void <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><h4 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h4><p>TransactionDefinition 接口定义了一些基本的事务属性。</p><ul><li><strong>事务名称</strong>：有多个事务时可用于区分事务。对应注解中的属性 value、transactionManager。</li><li><strong>隔离级别</strong>：用于分级加锁处理策略解决数据库容易出现的问题。对应注解中的属性 isolation。</li><li><strong>超时时间</strong>：定义事务执行的超时时间，超时后就会回滚，防止事务长期占用资源。对应注解中的属性 timeout。</li><li><strong>是否只读</strong>：表示事务是否是只读取数据、不更新数据，可以帮助数据库引擎优化事务。对应注解中的属性 readOnly。</li><li><strong>传播机制</strong>：定义事务的传播特性，共有7种类型。对应注解中的属性 propagation。</li><li><strong>回滚机制</strong>：定义事务遇到异常时的回滚策略。对应注解中的属性 rollbackFor、noRollbackFor、rollbackForClassName、noRollbackForClassName。</li></ul><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p><code>TransactionStatus</code> 接口用来记录事务的状态，该接口定义了一组方法用来获取或判断事务的状态。其接口内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h4><p><strong>事务传播机制用于解决多个事务方法相互调用的问题</strong>。当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p><ul><li><strong>REQUIRED(默认)：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。</li><li><strong>REQUIRES_NEW：</strong>创建一个新事务，如果当前存在事务，就把当前事务挂起。即不管外部方法是否开启事务，都会开启自己的事务，且事务间相互独立，互不干扰。</li><li><strong>NESTED：</strong>如果当前存在事务，则创建一个新事务作为当前事务的嵌套事务。如果当前没有事务，则创建一个新事务。</li><li><strong>MANDATORY：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li><strong>SUPPORTS：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式运行。</li><li><strong>NOT_SUPPORTED：</strong>以非事务方式运行，如果当前存在事务，则把当前事务挂起。执行完后，恢复挂起的事务。</li><li><strong>NEVER：</strong>以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>通过 <code>TransactionTemplate</code> 或 <code>TransactionManager</code> 手动管理事务，实现更细粒度的事务控制，是典型的模板模式。</p><p> <code>TransactionTemplate</code> 的继承结构如下：</p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240305204939995.png" alt="image-20240305204939995"></p><p>使用 TransactionTemplate 执行事务的过程如下：</p><p>① 创建 TransactionTemplate 对象（如果自定义了 TransactionTemplate 的 bean 则使用自定义的 bean，否则使用自动装配的默认 bean）</p><p>② 新建事务方法，并调用 excute() 方法执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用户并创建账户余额(手动事务，不带结果)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserBalanceAndUserWithinTT</span><span class="params">(String name, BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="comment">//实现一个没有返回值的事务回调</span></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;[addUserBalanceAndUser] begin!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1.新增用户</span></span><br><span class="line">                    userService.addUser(name);</span><br><span class="line">                    <span class="comment">//2.新增用户余额</span></span><br><span class="line">                    <span class="type">UserBalance</span> <span class="variable">userBalance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBalance</span>();</span><br><span class="line">                    userBalance.setName(name);</span><br><span class="line">                    userBalance.setBalance(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1000</span>));</span><br><span class="line">                    userBalanceRepository.insert(userBalance);</span><br><span class="line">                    log.info(<span class="string">&quot;[addUserBalanceAndUser] end!!!&quot;</span>);</span><br><span class="line">                    <span class="comment">//注意：这里catch住异常后，设置setRollbackOnly，否则事务不会滚。当然如果不需要自行处理异常，就不要catch了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 异常回滚</span></span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    log.error(<span class="string">&quot;异常回滚!,e=&#123;&#125;&quot;</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><p>execute() 方法是 TransactionTemplate 执行事务的核心方法，主要步骤如下：</p><ul><li>getTransaction() 获取事务。</li><li>doInTransaction() 执行业务逻辑，即用户的业务代码。如果没有返回值，就是 doInTransactionWithoutResult()。</li><li>如果事务执行成功，则调用 commit() 方法提交事务，否则调用 rollback() 回滚事务。</li></ul><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p><strong>定义</strong>：基于 <strong>Spring AOP 实现</strong>，对目标方法前后进行拦截，将事务处理的功能织入到目标方法中。在目标方法开始前创建或者加入一个事务，在目标方法结束后根据执行情况提交或回滚事务。<strong>使用 @Transactional 注解，并定义传播机制 + 回滚策略来实现</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2      * 创建用户并创建账户余额</span></span><br><span class="line"><span class="comment"> 3      *</span></span><br><span class="line"><span class="comment"> 4      * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> 5      * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment"> 6      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> 7      */</span></span><br><span class="line"> <span class="number">8</span>     <span class="meta">@Transactional(propagation= Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line"> <span class="number">9</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserBalanceAndUser</span><span class="params">(String name, BigDecimal balance)</span> &#123;</span><br><span class="line"><span class="number">11</span>         log.info(<span class="string">&quot;[addUserBalanceAndUser] begin!!!&quot;</span>);</span><br><span class="line"><span class="number">12</span>         <span class="comment">//1.新增用户</span></span><br><span class="line"><span class="number">13</span>         userService.addUser(name);</span><br><span class="line"><span class="number">14</span>         <span class="comment">//2.新增用户余额</span></span><br><span class="line"><span class="number">15</span>         <span class="type">UserBalance</span> <span class="variable">userBalance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBalance</span>();</span><br><span class="line"><span class="number">16</span>         userBalance.setName(name);</span><br><span class="line"><span class="number">17</span>         userBalance.setBalance(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1000</span>));</span><br><span class="line"><span class="number">18</span>         <span class="built_in">this</span>.addUserBalance(userBalance);</span><br><span class="line"><span class="number">19</span>         log.info(<span class="string">&quot;[addUserBalanceAndUser] end!!!&quot;</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>① <code>@Transactional</code> 的作用范围</p><ol><li>方法：推荐在方法上使用，不过只能应用到 public 方法上，否则不生效。</li><li>类：如果在类上使用，表明该注解对该类中所有的 public 方法都生效。</li><li>接口：不推荐在接口上使用</li></ol><p>② <strong><code>@Transactional</code> 的工作机制是基于 AOP 实现，AOP 又基于动态代理实现。如果目标对象实现了接口，会采用 JDK 动态代理，如果目标对象没有实现接口，会使用 CGLIB 动态代理。</strong><code>createAopProxy()</code> 方法决定了是使用 JDK 还是 Cglib 来做动态代理。</p><p>③ <strong>若同一类中没有 <code>@Transactional</code> 注解的方法调用了有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</strong></p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="Spring-Boot优点"><a href="#Spring-Boot优点" class="headerlink" title="Spring Boot优点"></a>Spring Boot优点</h3><ul><li><p>开发基于 Spring 的应用程序很容易。</p></li><li><p>Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。</p></li><li><p>Spring Boot 不需要编写大量样板代码、XML 配置和注释。</p></li><li><p>Spring Boot 应用程序可以很容易地与 Spring 生态系统集成，如 Spring  JDBC、Spring ORM、Spring Data、Spring Security 等。</p></li><li><p>Spring Boot 遵循“固执己见的默认配置”，以减少开发工作(默认配置可以修改)。</p></li><li><p>Spring Boot 应用程序提供嵌入式 HTTP 服务器，如 Tomcat 和 Jetty，可以轻松地开发和测试 web 应用程序。</p></li><li><p>Spring Boot 提供命令行接口(CLI)工具，用于开发和测试 Spring Boot 应用程序，如 Java或 Groovy。</p></li><li><p>Spring Boot 提供了多种插件，可以使用内置工具(如 Maven 和 Gradle)开发和测试 Spring Boot 应用程序。</p></li></ul><h3 id="Spring-Boot-Starters"><a href="#Spring-Boot-Starters" class="headerlink" title="Spring Boot Starters"></a>Spring Boot Starters</h3><p>Spring Boot Starters 是一系列依赖关系的集合，可以简化项目依赖间的关系。<br>在没有 Spring Boot Starters 之前，开发 Web 应用程序时需要手动一个一个添加 Spring MVC、Tomcat 和 Jackson 这样的库。有了Spring Boot Starters 后只需添加 <strong>spring-boot-starter-web</strong> 一个依赖就可以了，这个依赖中包含了开发 Web 应用程序需要的所有依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="内嵌-Servlet-容器"><a href="#内嵌-Servlet-容器" class="headerlink" title="内嵌 Servlet 容器"></a>内嵌 Servlet 容器</h3><p>Spring Boot 支持以下嵌入式 Servlet 容器：</p><img src="/./res\image-20220706144429941.png" alt="image-20220706144429941" style="zoom:67%;"> <h4 id="修改嵌入式容器"><a href="#修改嵌入式容器" class="headerlink" title="修改嵌入式容器"></a>修改嵌入式容器</h4><p>Spring Boot (spring-boot-starter-web) 使用 Tomcat 作为默认的嵌入式 Servlet 容器，如果想使用 Jetty 的话只需修改 pom.xml (Maven) 或 build.gradle (Gradle) 就可以了。</p><p><strong>Maven：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--从Web启动器依赖中排除Tomcat--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加Jetty依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>Gradle：</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>) &#123;</span><br><span class="line">     exclude <span class="attr">group:</span> <span class="string">&#x27;org.springframework.boot&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">compile(<span class="string">&quot;org.springframework.boot:spring-boot-starter-jetty&quot;</span>)</span><br></pre></td></tr></table></figure><p>从上面可以看出使用 Gradle 更加简洁明了，但是国内目前还是 Maven 使用的多一点，我个人觉得 Gradle 在很多方面都要好很多。</p><h3 id="常用基本注解"><a href="#常用基本注解" class="headerlink" title="常用基本注解"></a>常用基本注解</h3><h4 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h4><p>可以把 <code>@SpringBootApplication</code> 看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p><p>三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制。</li><li><code>@ComponentScan</code>：扫描被 <code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code> 注解注释的 bean，注解默认会扫描该类所在包下所有的类。</li><li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><h4 id="ComponentScan、-Import"><a href="#ComponentScan、-Import" class="headerlink" title="@ComponentScan、@Import"></a>@ComponentScan、@Import</h4><p>@ComponentScan：扫描包</p><p>@Import：使用类的<strong>无参构造函数</strong>创建一个实例注册到 IOC 容器中</p><p>【注意】@Import 所创建的实例在 IOC 容器中<strong>默认的 id 名为类的全限定名</strong>，如 User 类就是：com.atguigu.bean.User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  在容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>@ConditionalOnBean 和 @ConditionalOnMissBean、@Conditional</p><p>简单理解就是<code>@ConditionalOnBean</code>是依赖，<code>@ConditionalOnMissBean</code>是排斥，<code>@Conditional</code> 是条件。</p><p><a href="https://blog.csdn.net/weixin_43993065/article/details/106740140">@ConditionalOnMissingBean注解使用案例</a></p><h3 id="RESTful-Web-服务常用的注解"><a href="#RESTful-Web-服务常用的注解" class="headerlink" title="RESTful Web 服务常用的注解"></a>RESTful Web 服务常用的注解</h3><h4 id="Spring-Bean-相关"><a href="#Spring-Bean-相关" class="headerlink" title="Spring Bean 相关"></a>Spring Bean 相关</h4><ul><li><p><code>@Autowired</code>：自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。比如：Service 类注入到 Controller 类中。</p></li><li><p><code>@RestController</code>：<code>@RestController</code> 注解是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的合集，表示这是个控制器 bean，并且是将函数的返回值直接填入 HTTP 响应体中，是 REST 风格的控制器。</p></li><li><p><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用 <code>@Component</code> 注解标注。</p></li><li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p></li></ul><h4 id="处理常见的HTTP请求类型"><a href="#处理常见的HTTP请求类型" class="headerlink" title="处理常见的HTTP请求类型"></a>处理常见的HTTP请求类型</h4><p><strong>5 种常见的请求类型：</strong></p><ul><li><p><strong>GET</strong>：从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</p><p><code>@GetMapping(&quot;users&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users&quot;, method=RequestMethod.GET)</code></p></li><li><p><strong>POST</strong>：在服务器上创建新资源。举个例子：<code>POST /users</code>（创建学生）</p><p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p></li><li><p><strong>PUT</strong>：更新服务器上的资源。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</p><p><code>@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.PUT)</code></p></li><li><p><strong>DELETE</strong>：从服务器删除特定资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</p><p><code>@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.DELETE)</code></p></li><li><p><strong>PATCH</strong>：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</p></li><li><p><code>@PatchMapping(&quot;/users&quot;)</code></p></li></ul><h4 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h4><p><strong>1.<code>@PathVariable</code> 和 <code>@RequestParam</code></strong></p><p><code>@PathVariable</code> 用于获取路径参数，<code>@RequestParam</code> 用于获取查询参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getKlassRelatedTeachers</span><span class="params">(</span></span><br><span class="line"><span class="params">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span><br><span class="line"><span class="params">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们请求的 url 是：<code>/klasses/123456/teachers?type=web</code></p><p>那么我们服务获取到的数据就是：<code>klassId = 123456, type = web</code>。</p><p><strong>2.<code>@RequestBody</code></strong></p><p>用于读取 Request 请求 body 中的 <strong>json</strong> 数据并绑定到 Java 对象上去。系统会使用 <code>HttpMessageConverter</code> 或自定义的 <code>HttpMessageConverter</code> 将请求 body 中的 json 字符串转换为 java 对象。</p><p>需要注意的是：**一个请求方法只可以有一个 <code>@RequestBody</code>，但是可以有多个 <code>@RequestParam</code> 和 <code>@PathVariable</code>**。</p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>通过 <code>@EnableAutoConfiguration</code> 注解在 META-INF&#x2F;spring.factories 文件中找到所有自动配置类，然后将这些自动配置类加载到 spring 容器中。</p><ul><li><code>@EnableAutoConfiguration</code> 注解使用 <code>@Import</code> 注解导入 <code>AutoConfigurationImportSelector</code> 类。</li><li><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code> 接口中的 <code>selectImports</code> 方法，该方法用于<strong>获取所有需要被加载到 IoC 容器中的类的全限定名</strong>。</li><li><code>selectImports</code> 方法中的 <code>getAutoConfigurationEntry()</code> 方法负责加载自动配置类。</li></ul><img src="/./res\3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;"><p>结合 <code>getAutoConfigurationEntry()</code> 的源码来详细分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AutoConfigurationEntry</span> <span class="variable">EMPTY_ENTRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>();</span><br><span class="line"></span><br><span class="line">AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.用于获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName。</span></span><br><span class="line">            <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.获取需要自动装配的所有配置类，读取 META-INF/spring.factories</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="built_in">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</li><li>获取 <code>EnableAutoConfiguration</code> 注解中的 <code>exclude</code> 和 <code>excludeName</code>。</li><li>读取 <code>META-INF/spring.factories</code> 文件，获取所有需要被自动装配的自动配置类。<code>getcandidateconfigurations</code> 方法会将所有<strong>自动配置类的信息以 List 形式返回</strong>。这些信息会被 Spring 容器当做 bean 来管理。</li><li>经历了一遍筛选，如果 <code>@ConditionalOnXXX</code> 中的所有条件都满足，类就会生效。</li></ol><h3 id="启动机制"><a href="#启动机制" class="headerlink" title="启动机制"></a>启动机制</h3><p>spring boot 启动流程分析 - 掘金 (juejin.cn)](<a href="https://juejin.cn/post/7035910505810100255">https://juejin.cn/post/7035910505810100255</a>)</p><p><a href="https://blog.csdn.net/weixin_46047193/article/details/123557570?ops_request_misc=%7B%22request_id%22:%22165993113716782184616144%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165993113716782184616144&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123557570-null-null.142%5Ev39%5Epc_rank_34,185%5Ev2%5Etag_show&utm_term=springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187"> Spring Boot面试必问：启动流程</a></p><ol><li>首先从 main 中找到 run() 方法，在执行 run() 方法之前先 new 一个 <code>SpringApplication</code> 对象。</li><li>进入 run() 方法，创建应用监听器 <code>SpringApplicationRunListeners</code> 开始监听。</li><li>加载 SpringBoot 配置环境 <code>ConfigurableEnvironment</code>，然后把配置环境加入监听对象中。</li><li>加载应用上下文 <code>ConfigurableApplicationContext</code>，作为 run() 方法的返回对象。</li><li>最后创建 Spring 容器，调用 <code>refreshContext(context)</code> 方法，实现 starter 自动配置和 bean 实例化等工作。</li></ol><p><img src="/.%5Cres%5Cimage-20220712153744731.png" alt="SpringApplication的实例化"></p><h4 id="SpringApplication的实例化"><a href="#SpringApplication的实例化" class="headerlink" title="SpringApplication的实例化"></a>SpringApplication的实例化</h4><p>SpringApplication 实例化的过程中，主要做了以下4件事：</p><ul><li><h5 id="推断应用类型是否是Web环境"><a href="#推断应用类型是否是Web环境" class="headerlink" title="推断应用类型是否是Web环境"></a>推断应用类型是否是Web环境</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br></pre></td></tr></table></figure><p>通过判断是否存在 Servlet 和 ConfigurableWebApplicationContext 类来判断是否是Web环境，如果该应用是一个web应用，会启动Springboot内嵌的web服务器</p></li><li><p><strong>设置初始化器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br></pre></td></tr></table></figure><p>该方法会加载所有配置的 ApplicationContextInitializer 并进行实例化，加载过程为从  jar 包的类路径下的 META-INF&#x2F;spring.factories 中读取配置文件中 Key 为 org.springframework.context.ApplicationContextInitializer 的 value 值，将其放入到列表中并去重，然后根据这些 value 值通过反射来实例化对应的类，这些类就是一个个的初始化器，他们都是 ApplicationContextInitializer 的实现类。ApplicationContextInitializer 是一个回调接口，它会在 ConfigurableApplicationContext 容器 refresh() 方法调用之前被调用，做一些容器的初始化工作。</p></li><li><p><strong>设置监听器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure><p>该方法会加载所有配置的 ApplicationListener并进行实例化，加载过程为从jar包的类路径下的META-INF&#x2F;spring.factories中读取配置文件中Key为org.springframework.context.ApplicationListener的 value值，将其放入到列表中并去重，然后根据这些value值通过反射来实例化对应的类，这些类就是一个个的监听器，他们都是ApplicationListener的实现类。</p></li><li><p><strong>推断应用入口类(Main)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br></pre></td></tr></table></figure><p>通过构造一个运行时异常，通过异常栈中方法名为main的栈帧来得到入口类的名字。</p></li></ul><h4 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h4><ul><li><p><strong>获取RunListeners</strong></p><p>加载所有配置的 SpringApplicationRunListener 并进行实例化，加载过程为从 jar 包的类路径下的 META-INF&#x2F;spring.factories 中读取配置文件中 Key 为 org.springframework.context.SpringApplicationRunListener 的 value 值，将其放入到列表中并去重，然后根据这些 value 值通过反射来实例化对应的类，这些类就是一个个的运行时监听器，他们都是 SpringApplicationRunListener 的实现类。</p></li><li><p><strong>准备Environment环境</strong></p><p>根据SpringApplicationRunListeners以及参数来准备环境，主要用来配置Property Sources和Profiles，为应用程序环境配置哪些配置文件处于active（活动）状态。</p></li><li><p><strong>创建Spring Context</strong></p><p>根据应用程序的类型来创建web应用的Spring上下文环境和非web应用的Spring上下文环境</p></li><li><p><strong>Spring Context前置处理</strong></p><p>主要用来配置Bean生成器以及资源加载器，然后调用SpringApplication实例创建时设置的初始化器，依次对它们进行遍历，并调用initialize方法。</p></li><li><p><strong>Spring Context刷新</strong></p><p>首先调用父类的refresh方法完成容器刷新的基础操作，然后注册一个关闭容器时的钩子函数，用来完成一些容器销毁时的清理工作</p></li><li><p><strong>Spring Context后置处理</strong></p><p>在容器完成刷新后，依次调用注册的Runners，Runners可以是两个接口的实现类：org.springframework.boot.ApplicationRunner、org.springframework.boot.CommandLineRunner。CommandLineRunner、ApplicationRunner 接口是在容器启动成功后的最后一步回调</p></li></ul><h3 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486181&idx=2&sn=10db0ae64ef501f96a5b0dbc4bd78786&chksm=cea2452ef9d5cc384678e456427328600971180a77e40c13936b19369672ca3e342c26e92b50&token=816772476&lang=zh_CN#rd">《10 分钟搞定 SpringBoot 如何优雅读取配置文件？》open in new window</a> </p><h4 id="通过-value-读取简单的配置信息"><a href="#通过-value-读取简单的配置信息" class="headerlink" title="通过 @value 读取简单的配置信息"></a>通过 <code>@value</code> 读取简单的配置信息</h4><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取简单的配置信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure><h4 id="通过-ConfigurationProperties-读取并与-bean-绑定"><a href="#通过-ConfigurationProperties-读取并与-bean-绑定" class="headerlink" title="通过 @ConfigurationProperties 读取并与 bean 绑定"></a>通过 <code>@ConfigurationProperties</code> 读取并与 bean 绑定</h4><blockquote><p>LibraryProperties 类上加了 @Component 注解，可以像使用普通 bean 一样将其注入到类中使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryProperties</span> </span><br></pre></td></tr></table></figure><h4 id="通过-ConfigurationProperties-读取并校验"><a href="#通过-ConfigurationProperties-读取并校验" class="headerlink" title="通过 @ConfigurationProperties 读取并校验"></a>通过 <code>@ConfigurationProperties</code> 读取并校验</h4><p>我们先将application.yml修改为如下内容，明显看出这不是一个正确的email格式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Guide哥</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">koushuangbwcx@</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ProfileProperties</code>类没有加<code>@Component</code>注解。我们在我们要使用<code>ProfileProperties</code>的地方使用<code>@EnableConfigurationProperties </code>注册我们的配置<code>bean</code>:</p></blockquote><p>具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my-profile&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfileProperties</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ProfileProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadConfigPropertiesApplication</span></span><br></pre></td></tr></table></figure><h4 id="通过-PropertySource-读取指定-properties-文件"><a href="#通过-PropertySource-读取指定-properties-文件" class="headerlink" title="通过 @PropertySource 读取指定 properties 文件"></a>通过 <code>@PropertySource</code> 读取指定 properties 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebSite webSite;</span><br><span class="line"></span><br><span class="line">System.out.println(webSite.getUrl());<span class="comment">//https://javaguide.cn/</span></span><br></pre></td></tr></table></figure><h3 id="请求参数检验"><a href="#请求参数检验" class="headerlink" title="请求参数检验"></a>请求参数检验</h3><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485783&idx=1&sn=a407f3b75efa17c643407daa7fb2acd6&chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&token=292197051&lang=zh_CN#rd">如何在 Spring&#x2F;Spring Boot 中做参数校验？你需要了解的都在这里！ (qq.com)</a></p><h4 id="校验注解"><a href="#校验注解" class="headerlink" title="校验注解"></a>校验注解</h4><p><strong>JSR提供的校验注解</strong>:</p><ul><li><code>@Null</code>  被注释的元素必须为 null</li><li><code>@NotNull</code>   被注释的元素必须不为 null</li><li><code>@AssertTrue</code>   被注释的元素必须为 true</li><li><code>@AssertFalse</code>   被注释的元素必须为 false</li><li><code>@Min(value)</code>   被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code>   被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code>   被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code>   被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code>   被注释的元素的大小必须在指定的范围内</li><li><code>@Digits(integer, fraction)</code>  被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code>   被注释的元素必须是过去的日期</li><li><code>@Future</code>   被注释的元素必须是将来的日期</li><li><code>@Pattern(regex= ,flag= )</code>   被注释的元素必须符合指定的正则表达式</li></ul><p><strong>Hibernate Validator提供的校验注解</strong>： </p><ul><li><code>@NotBlank(message = )</code> 验证字符串非null，且长度必须大于0</li><li><code>@Email</code> 被注释的元素必须是电子邮箱地址</li><li><code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内</li><li><code>@NotEmpty</code> 被注释的字符串的必须非空</li><li><code>@Range(min=,max=,message=)</code> 被注释的元素必须在合适的范围内</li></ul><h4 id="验证请求体-RequestBody"><a href="#验证请求体-RequestBody" class="headerlink" title="验证请求体(RequestBody)"></a>验证请求体(RequestBody)</h4><p>在需要验证的参数上加上 <code>@Valid</code> 注解，如果验证失败会抛出 <code>MethodArgumentNotValidException</code>。默认情况下，Spring 会将此异常转换为 HTTP Status 400。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line">publicclass PersonController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title function_">getPerson</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证请求参数-Path-Variables-和-Request-Parameters"><a href="#验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="验证请求参数(Path Variables 和 Request Parameters)"></a>验证请求参数(Path Variables 和 Request Parameters)</h4><p><strong>一定要在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line">publicclass PersonController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title function_">getPersonByID</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">getPersonByName</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestParam(&quot;name&quot;)</span> <span class="meta">@Size(max = 6,message = &quot;超过 name 的范围了&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><p>可以使用 <code>@ControllerAdvice</code> 和 @<code>ExceptionHandler</code> 处理全局异常。</p><p><a href="https://snailclimb.gitee.io/springboot-guide/#/./docs/advanced/springboot-handle-exception-plus">Document (gitee.io)</a></p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>我们使用 <code>@scheduled</code> 注解就能很方便地创建一个定时任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTasks</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ScheduledTasks.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fixedRate：固定速率执行。每5秒执行一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportCurrentTimeWithFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Current Thread : &#123;&#125;&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        log.info(<span class="string">&quot;Fixed Rate Task : The time is now &#123;&#125;&quot;</span>, dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单纯依靠 <code>@scheduled</code> 注解还不行，我们还需要在<code>SpringBoot </code>中我们只需要在启动类上加上 <code>@Enablescheduling</code> 注解，这样才可以启动定时任务。<code>@Enablescheduling </code>注解的作用是发现注解 <code>@scheduled</code> 的任务并在后台执行该任务。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="MySQL-介绍"><a href="#MySQL-介绍" class="headerlink" title="MySQL 介绍"></a>MySQL 介绍</h3><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><h3 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h3><p><a href="https://cloud.tencent.com/developer/article/1784274">非关系型数据库（NOSQL）和关系型数据库（SQL）区别详解</a></p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a><strong>关系型数据库</strong></h4><p>关系型数据库是<strong>以关系模型（二维表格模型）为基础的数据库</strong>。关系模型表明了数据库中存储的数据之间的联系（一对一、一对多、多对多）。关系型数据库中，数据都被存放在各种表中，表中的每一行就存放着一条数据。</p><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<strong>事务</strong>的四大特性 (ACID)。</p><p>最典型的数据结构是<strong>表</strong>，由二维表及其之间的联系所组成的一个数据组织</p><p>优点：</p><p>1、 易于维护：都是使用表结构，格式一致</p><p>2、 使用方便：SQL 语言通用，可用于复杂查询</p><p>3、 复杂操作：<strong>支持 SQL</strong>，可用于一个表以及多个表之间非常复杂的查询。</p><p>缺点：</p><p>1、 读写性能比较差，尤其是海量数据的高效率读写；</p><p>2、 固定的表结构，灵活度稍差</p><p>3、 高并发读写需求，传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。</p><p><strong>常见关系型数据库管理系统(ORDBMS)：</strong></p><p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite）。</p><h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a><strong>非关系型数据库</strong></h4><p>非关系型数据库又称为 NoSQL（Not Only SQL)，意为不仅仅是 SQL，常用于存储非结构化的数据，数据通常以对象的形式存储在数据库中。</p><p><strong>优点：</strong></p><ol><li>格式灵活：存储数据的格式可以是 key - value 形式、文档形式、图片形式等，而关系型数据库只支持基础类型。</li><li>速度快：NoSQL 可以使用硬盘或者 RAM，而关系型数据库只能使用硬盘；</li><li>成本低： 海量数据的维护和处理非常轻松。 </li><li>高扩展：非关系型数据库具有扩展简单、高并发、高稳定性。</li><li>可以实现数据的分布式处理。</li></ol><p><strong>缺点：</strong></p><p>1、 不提供 SQL 支持，学习和使用成本高</p><p>2、 <strong>无事务处理</strong>；</p><p>3、 数据结构相对复杂，复杂查询方面稍欠；</p><p><strong>常见的NOSQL数据库：</strong></p><ol><li>键值数据库：Redis、Memcached、Riak </li><li>列族数据库：Bigtable、HBase、Cassandra </li><li>文档数据库：MongoDB、CouchDB、MarkLogic </li><li>图形数据库：Neo4j、InfoGrid</li></ol><h3 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h3><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li><strong>连接器</strong>：建立连接。</li><li><strong>查询缓存</strong>：查询语句如果命中查询缓存就直接返回，否则继续往下执行。<strong>MySQL 8.0 已删除该模块</strong>；</li><li><strong>解析器</strong>：解析 SQL，对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li><strong>执行 SQL</strong>：<ul><li><strong>预处理</strong>阶段：检查表或字段是否存在，将 <code>select *</code> 中的 <code>*</code>  扩展为表中所有列。</li><li><strong>优化</strong>阶段：选择查询成本最小的执行计划。</li><li><strong>执行</strong>阶段：根据执行计划执行 SQL 查询语句，从<strong>存储引擎</strong>中读取记录，返回给客户端；</li></ul></li></ul><p><img src="/.%5Cres%5Cmysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><p>MySQL 架构分为两层：<strong>Server 层和存储引擎层</strong>。</p><ul><li><strong>Server 层负责建立连接、解析 SQL 和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用 Server 层，最常用的存储引擎是 InnoDB。我们常说的索引数据结构是由存储引擎层实现的，不同存储引擎支持的索引类型不同，InnoDB 支持的索引类型是 B+ 树 ，也就是说在数据表中创建的主键索引和二级索引使用的都是 <strong>B+ 树</strong>索引。</li></ul><h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><p>MySQL 支持多种存储引擎，可以通过 <code>show engines</code> 命令查看 MySQL 支持的存储引擎。</p><p><img src="/.%5Cres%5Cimage-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎"></p><p>从上图可以看出， MySQL 的默认存储引擎是 InnoDB，且只有 InnoDB 是事务性存储引擎，也就是说<strong>只有 InnoDB 支持事务</strong>。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>你也可以通过 <code>show variables like &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p><p><img src="/.%5Cres%5Cimage-20220510105837786.png" alt="查看 MySQL 当前默认的存储引擎"></p><h4 id="存储引擎架构"><a href="#存储引擎架构" class="headerlink" title="存储引擎架构"></a>存储引擎架构</h4><p>MySQL 存储引擎采用插件式架构，支持多种存储引擎，甚至可以为不同的表设置不同的存储引擎。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h4 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h4><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有<strong>表级锁</strong>，而 InnoDB 支持<strong>行级锁</strong>和表级锁，默认行级锁。</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义的四个隔离级别，具有提交事务和回滚事务的能力。</p><p>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别可以解决幻读问题（基于 MVCC 和 Next-Key Lock）。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于<strong>维护数据一致性</strong>非常有帮助，但是对性能有一定的损耗。因此不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库异常崩溃后，重新启动时会保证数据库恢复到崩溃前的状态，恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>Multi-Version Concurrency Control 多版本并发控制</p><blockquote><p>这个对比有点废话，MyISAM 连行级锁都不支持。MVCC 可以看作行级锁的升级，可以有效减少加锁操作，提高性能。</p></blockquote><p><strong>6.索引实现不一样。</strong></p><p>MyISAM 使用 B Tree 作为索引结构，InnoDB 使用 B+ Tree 作为索引结构。</p><p><strong>InnoDB 引擎的数据文件就是索引文件</strong>，而 <strong>MyISAM 引擎的索引文件和数据文件是分离的</strong>。</p><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p><a href="https://www.cnblogs.com/shangping/p/11088503.html">数据库—–三大范式</a></p><ul><li>第一范式：<strong>每列都不可以再拆分</strong>。</li></ul><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306205358725.png" alt="image-20240306205358725"></p><ul><li>第二范式：<strong>非主键列完全依赖于主键</strong>，即<strong>主键可以确定所有非主键的值。</strong>也就是说如果一张表中包含了多个不同实体的属性，那么必须要拆分成多张表。</li></ul><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306205446367.png" alt="image-20240306205446367"></p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306205524003.png" alt="image-20240306205524003"></p><ul><li>第三范式：<strong>非主键列只依赖于主键，不依赖于其他非主键</strong>。也就是说如果已经分好了多张表的话，一张表中只能有另一张表的主键，不能有其他信息。</li></ul><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306210237085.png" alt="image-20240306210237085"></p><p>注意事项：</p><p>1.第二范式与第三范式的本质区别：在于有没有分出两张表。</p><p>2.必须先满足第一范式才能满足第二范式，必须同时满足第一、第二范式才能满足第三范式。</p><h2 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h2><h3 id="inner-join-left-join-right-join"><a href="#inner-join-left-join-right-join" class="headerlink" title="inner join  &#x2F; left join &#x2F; right join"></a>inner join  &#x2F; left join &#x2F; right join</h3><ul><li>left join (左联接) 返回左表中的所有记录和右表中联结字段相等的记录</li><li>right join (右联接) 返回右表中的所有记录和左表中联结字段相等的记录</li><li>inner join (等值连接) 返回两个表中联结字段相等的行</li></ul><p>inner join 取<strong>交集</strong></p><p><a href="https://www.yisu.com/zixun/624524.html">mysql如何求交集</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询交集</span><br><span class="line">SELECT a.oname,a.odesc FROM object_a a INNER JOIN object_b b ON a.oname=b.oname AND a.odesc=b.odesc</span><br><span class="line"># 等价于</span><br><span class="line">SELECT a.oname,a.odesc FROM object_a a INNER JOIN object_b b USING(oname,odesc)</span><br></pre></td></tr></table></figure><h3 id="using-用法-（见上面）"><a href="#using-用法-（见上面）" class="headerlink" title="using 用法 （见上面）"></a>using 用法 （见上面）</h3><p><a href="https://blog.csdn.net/sinat_36925013/article/details/124622701?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-124622701-blog-79622414.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-124622701-blog-79622414.pc_relevant_multi_platform_featuressortv2removedup&utm_relevant_index=10">(Mysql 中用using() 简化连接join</a></p><ul><li>连接查询时如果是同名字段作为连接条件，using可以代替on出现（比on更好）</li><li>using 是针对<strong>同名字段</strong>（<strong>using(id)等价于on A.id&#x3D;B.id</strong>）</li><li>using 关键字使用后会自动合并对应字段为一个</li><li>using 可以同时使用多个字段作为条件</li></ul><h3 id="Union-和-Union-All-的区别"><a href="#Union-和-Union-All-的区别" class="headerlink" title="Union 和 Union All 的区别"></a>Union 和 Union All 的区别</h3><p>都是对两个结果集进行<strong>并集</strong>操作</p><p><strong>Union：不包括重复行，同时进行默认规则的排序；</strong></p><p><strong>Union All：包括重复行，不进行排序；</strong></p><h3 id="on和where的区别"><a href="#on和where的区别" class="headerlink" title="on和where的区别"></a>on和where的区别</h3><p><a href="https://blog.csdn.net/tayngh/article/details/99684035">MYSQL on和where的区别</a></p><p>外连接时：</p><ul><li><p>on条件是在<strong>生成临时表时使用的条件</strong>，它不管on中的条件是否为真，都会返回左（右）边表中的记录。</p></li><li><p>where条件是在<strong>临时表生成好后</strong>，再对临时表进行过滤的条件。</p></li></ul><p>内连接：</p><p>是从结果表中删除与其他被连接表中没有匹配行的所有行，所有在<strong>内连接时on和where的结果是相同的</strong>。</p><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>有以下三种常用的去重方式：</p><ul><li>distinct 去重关键字（要去重的字段要放在第一个）</li><li>group by 按照要去重的字段分组</li><li>union 操作符合并两个结果集会自动去除重复元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT distinct university from user_profile</span><br><span class="line">select university from user_profile group by university</span><br><span class="line">SELECT  university from user_profile union SELECT  university from user_profile</span><br></pre></td></tr></table></figure><h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h3><p>如果给定两个参数，第一个参数指定第一个返回记录行的<strong>偏移量</strong>，第二个参数指定返回记录行的<strong>最大数目</strong>。</p><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。<br>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。<br>如果只给定一个参数，它表示返回最大的记录行数目。</p><p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1。<br>初始记录行的偏移量是 0 (而不是 1)。</p><p>例5.检索记录行 6-10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 5,5</span><br></pre></td></tr></table></figure><p>例6.检索记录行 11-last</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 10,-1</span><br></pre></td></tr></table></figure><p>例7.检索前 5 个记录行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 5</span><br></pre></td></tr></table></figure><h3 id="确定集合"><a href="#确定集合" class="headerlink" title="确定集合"></a>确定集合</h3><p>用来查找属性值属于指定集合的元组。<br>格式为：</p><p><img src="/.%5Cres%5Cimage-20220815212327699.png" alt="image-20220815212327699"> </p><p>IN：当列中的值与IN中的某个常量值相等时，则结果为True，表明此记录为符合查询条件的记录。<br>NOT IN：当列中的值与某个常量值相等时，结果为False，表明此记录为不符合查询条件的记录。</p><p>例17.查询所有班名是“电子信息工程技术”、“电子声像”或“电子组装技术”的班号和班名。</p><p><img src="/.%5Cres%5Cimage-20220815212310445.png" alt="image-20220815212310445"> </p><p>等价于：</p><p><img src="/.%5Cres%5Cimage-20220815212255169.png" alt="image-20220815212255169"> </p><p>例18.查询班名既不是“电子信息工程技术”、也不是“电子声像”和“电子组装技术”的班号和班名。</p><p><img src="/.%5Cres%5Cimage-20220815212241613.png" alt="image-20220815212241613"> </p><p>等价于：</p><p><img src="/.%5Cres%5Cimage-20220815212151942.png" alt="image-20220815212151942"> </p><h3 id="where过滤空值"><a href="#where过滤空值" class="headerlink" title="where过滤空值"></a>where过滤空值</h3><p>解法一：</p><p><strong><code>select device_id,gender,age,university</code></strong><br><strong><code>from user_profile</code></strong><br><strong><code>where age is not NULL;</code></strong></p><p>解法二：</p><p><strong><code>select device_id,gender,age,university</code></strong><br><strong><code>from user_profile</code></strong><br><strong><code>where age !=&#39;&#39;;</code></strong></p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>复旦大学学生gpa最高值</p><hr><p><strong>问题分解：</strong></p><ul><li>限定条件：复旦大学学生，<code>university=&#39;复旦大学&#39;</code>；</li><li>gpa最高值：max(gpa)；当然也可以按 gpa 降序排序，取第一名</li></ul><hr><p><strong>细节问题：</strong></p><ul><li>表头重命名：as</li></ul><p><strong>完整代码：</strong></p><p><img src="/.%5Cres%5Cimage-20220815213744043.png" alt="image-20220815213744043"></p><h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND"></a>ROUND</h3><p>ROUND(x) 函数返回最接近于参数 x 的整数；</p><p>ROUND(x,y) 函数对参数 x 进行四舍五入的操作，返回值保留小数点后面指定的 y 位。</p><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p><strong>MySQL 索引是帮助存储引擎快速获取数据的一种数据结构</strong>。</p><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><p>优点：</p><ul><li>使用索引可以<strong>大大加快数据的检索速度</strong>（大大减少检索的数据量）。</li><li>通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。</li><li>可以加速表和表之间的连接。 </li><li>在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要耗费许多时间，且时间随着数据量的增加而增加。 </li><li>对表中的数据进行增删改时，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="索引的必要性"><a href="#索引的必要性" class="headerlink" title="索引的必要性"></a>索引的必要性</h3><p>[MySQL索引详解（优缺点，何时需要&#x2F;不需要创建索引，索引及sql语句的优化）](<a href="https://www.cnblogs.com/l199616j/p/11232392.html#:~:text=MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%2F%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%8F%8Asql%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89">https://www.cnblogs.com/l199616j/p/11232392.html#:~:text=MySQL索引详解（优缺点，何时需要%2F不需要创建索引，索引及sql语句的优化）</a> 1 通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。 2 可以加快数据的检索速度,3 可以加速表与表之间的连接 4 在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时 )</p><p><a href="https://blog.csdn.net/superit401/article/details/51291603">mysql_建立索引的优缺点</a></p><h4 id="什么时候需要索引"><a href="#什么时候需要索引" class="headerlink" title="什么时候需要索引"></a><strong>什么时候需要索引</strong></h4><ol><li>主键自动创建唯一索引</li><li>频繁查询的字段应该创建索引</li><li>用于排序的字段创建索引将大大提高排序的速度</li><li>用于统计或者分组的字段；</li><li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； </li><li>在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。</li></ol><h4 id="什么时候不需要索引"><a href="#什么时候不需要索引" class="headerlink" title="什么时候不需要索引"></a><strong>什么时候不需要索引</strong></h4><ol><li>频繁更新的字段不适合创建索引，因为每次更新不仅要更新记录，还要更新索引</li><li>where 条件里用不到的字段，不创建索引；</li><li>表记录太少，不需要创建索引；</li><li>对于只有很少数据值的列，不创建索引。因为这些列的取值很少，例如<strong>性别列</strong>，在查询的结果中<strong>结果集的数据行仍会占表中数据行中的很大比例</strong>。增加索引并不能明显加快检索速度。</li><li>定义为 text, image 和 bit 数据类型的列，不创建索引。因为这些列的数据量要么相当大，要么取值很少。</li></ol><h3 id="创建索引的方法"><a href="#创建索引的方法" class="headerlink" title="创建索引的方法"></a>创建索引的方法</h3><p>1、使用 <code>CREATE TABLE</code> 语句配合 <code>INDEX </code> 或 <code>UNIQUE </code> 关键字在建表时直接创建索引；</p><p>2、使用 <code>ALTER TABLE</code> 语句来直接创建索引；</p><p>3、使用 <code>CREATE INDEX</code> 语句对表增加普通索引或 <code>UNIQUE</code> 索引。</p><p><strong>create table table_name ( […], INDEX [索引的名字] (列的列表) );</strong><br><strong>alter table table_name add index[索引的名字] (列的列表);</strong><br> <strong>create index &lt;索引的名字&gt; on table_name (列的列表);</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//普通索引</span><br><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    INDEX [indexName] (username(length))  </span><br><span class="line"> );  </span><br><span class="line"></span><br><span class="line">//唯一索引</span><br><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    UNIQUE [indexName] (username(length))  </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE (column_list);</span><br><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_list);</span><br><span class="line">    </span><br><span class="line">CREATE INDEX index_name ON table_name (column_list)</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list)</span><br></pre></td></tr></table></figure><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>按照四个角度来分类索引。</p><ul><li>按「数据结构」分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h3 id="主键索引和辅助索引"><a href="#主键索引和辅助索引" class="headerlink" title="主键索引和辅助索引"></a>主键索引和辅助索引</h3><h4 id="主键索引-聚簇索引"><a href="#主键索引-聚簇索引" class="headerlink" title="主键索引(聚簇索引)"></a>主键索引(聚簇索引)</h4><p>数据表的主键使用的就是主键索引。</p><p><strong>一张数据表有只能有一个主键，并且主键不能为 null、不能重复。由一个或多个列组成，用于唯一性标识数据表中的某一条记录</strong>。</p><p>在 MySQL 的 InnoDB 的表中，当没有显式的指定表的主键时，InnoDB 会检查表中是否有唯一索引且不允许存在 null 值的字段，如果有就选择该字段作为主键，否则就创建一个 6Byte 的自增主键。</p><h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h4><p><strong>二级索引又叫辅助索引，因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的是为了保证属性列数据的唯一性，而不是为了提高查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引用于快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引用于字符串类型的数据，对文本前几个字符创建索引，相比普通索引建立的数据更小。</li><li><strong>全文索引(Full Text)</strong> ：全文索引用于检索大文本数据中的关键字信息，是搜索引擎数据库使用的一种技术。</li></ol><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code> 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引 (B+ 树) 的非叶子节点存储索引，<strong>叶子节点存储索引和索引对应的数据。</strong></p><h5 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a><strong>聚集索引的优点</strong></h5><ul><li>聚集索引的查询速度非常快，因为 B+ 树本身就是多叉平衡树，叶子节点是有序的，<strong>定位到索引的节点，就相当于定位到了数据。</strong></li></ul><h5 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a><strong>聚集索引的缺点</strong></h5><ol><li><strong>依赖于有序的数据</strong> ：因为 B+ 树是多叉平衡树，如果索引的数据不是有序的，就需要在插入时排序，类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度就比较慢。</li><li><strong>更新代价大</strong> ： 如果修改索引列的数据，那么对应的索引也会被修改，而且聚集索引的叶子节点还存放数据，修改代价较大。所以对<strong>于主键索引来说，主键一般不可修改的</strong>。</li></ol><img src="/./res\btree.drawio.png" alt="主键索引 B+Tree" style="zoom:67%;"><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p><strong>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</strong></p><p>非聚集索引的叶子节点不一定存放数据的指针。比如二级索引的<strong>叶子节点存放的是主键，根据主键再回表查数据。</strong></p><h5 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a><strong>非聚集索引的优点</strong></h5><ul><li><strong>更新代价比聚集索引要小</strong> ，因为非聚集索引的叶子节点不存放数据。</li></ul><h5 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h5><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> ：这可能是非聚集索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再回表查询。</li></ol><p><img src="/.%5Cres%5C%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p><p>聚集索引和非聚集索引:</p><p><img src="/.%5Cres%5C20210420165326946.png" alt="img"></p><h5 id="非聚集索引一定回表查询吗"><a href="#非聚集索引一定回表查询吗" class="headerlink" title="非聚集索引一定回表查询吗 ?"></a>非聚集索引一定回表查询吗 ?</h5><p><strong>非聚集索引不一定回表查询。</strong></p><blockquote><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE name=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p></blockquote><h3 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引即需要查询的字段正好是索引的字段，就可以直接根据该索引查到数据，无需回表查询。</strong></p><p>如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是列值 + 主键，然后会“回表”，也就是要通过主键再查找一次，这样就比较慢。覆盖索引就是要查询的字段和索引是对应的，不做回表操作！</p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>使用表中的多个字段创建索引，就是<strong>联合索引</strong>。</p><h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>最左前缀匹配原则指的是，在使用联合索引时 <strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成。</p><p><strong>建立联合索引时，要把区分度大的字段排在前面</strong>，这也可以过滤更多数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p><a href="https://xiaolincoding.com/mysql/base/how_select.html#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8">#</a></p><p>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，<strong>对索引字段先做判断，</strong>过滤掉不符合条件的记录，<strong>减少回表次数</strong>。</p><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 建立了联合索引（age，reword）：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>联合索引当遇到范围查询 (&gt;、&lt;、between、like) 就会停止匹配，也就是 <strong>a 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 reward 字段值。</li></ul></blockquote><h3 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h3><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p></li><li><p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p></li><li><p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p></li><li><p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p></li><li><p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p></li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><p><strong>4.注意避免冗余索引</strong> 。</p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引代替普通索引。</p><h3 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h3><ul><li>前缀索引优化；</li><li>覆盖索引优化；</li><li>主键索引最好是自增的；</li><li>索引最好设置为 NOT NULL</li><li>防止索引失效；</li></ul><h4 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h4><p>前缀索引就是使用字符串的前几个字符建立索引。</p><p>使用前缀索引可以减小索引字段大小，有效提高索引的查询速度。<strong>在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</strong></p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h4 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h4><p>覆盖索引是指 SQL 中查询的所有字段正好是索引的字段，就可以直接根据该索引查到数据，无需回表查询。</p><blockquote><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p></blockquote><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作</p><h4 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h4><p>在建表时默认会将主键索引设置为自增，为什么要这样做呢？</p><p>InnoDB 创建主键索引是聚簇索引，数据被存放在了 B+ Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，当有一条新数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>如果使用自增主键</strong>，那么每次插入的新数据都是追加操作，不需要移动已有的数据。当页面写满时，就会自动开辟一个新页面，所以效率非常高。</p><p><strong>如果使用非自增主键</strong>，每次插入的主键的索引是随机的，可能会插入到数据页中间的位置，就需要移动已有的数据，甚至可能需要从一个页面复制数据到另外一个页面，这种情况称为<strong>页分裂</strong>。<strong>页分裂会导致索引结构不紧凑，从而影响查询效率</strong>。</p><h4 id="索引最好设置为-NOT-NULL"><a href="#索引最好设置为-NOT-NULL" class="headerlink" title="索引最好设置为 NOT NULL"></a>索引最好设置为 NOT NULL</h4><p>有两个原因：</p><ul><li><p>第一原因：<strong>索引列存在 NULL 会导致优化器难以优化</strong>，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂。比如进行索引统计时，<strong>count 会省略值为NULL 的行</strong>。</p></li><li><p>第二个原因：<strong>NULL 值是没意义的值，但是会占用物理空间</strong>，InnoDB 默认行存储格式 <code>COMPACT</code>，会用 1 字节空间存储 NULL 值列表。</p><p><img src="/.%5Cres%5C008eGmZEgy1gp6pbo6xd7j30v602u3yq.jpg" alt="img"></p></li></ul><h4 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h4><p>用上了索引并不意味着查询时就会用到索引，有些情况会导致索引失效，要避免写出索引失效的查询语句，否则查询效率会很低。</p><p>我之前写过索引失效的文章，想详细了解的可以去看这篇文章：<a href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">谁还没碰过索引失效呢?(opens new window)</a></p><h5 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h5><ul><li>对索引使用<strong>左或左右模糊匹配</strong>会造成索引失效， <code>like %xx</code> 或 <code>like %xx%</code> 这两种方式都会造成索引失效，<strong>因为 B+ 树是按照「索引值」有序排列存储的，需要根据前缀进行比较。</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span> name 字段为二级索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%林&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>对索引使用函数、表达式运算</strong>：如果在查询条件中对索引使用函数、表达式运算，会造成索引失效；因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> name 为二级索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> length(name)<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>对索引字段类型隐式转换：</strong>如果索引字段是字符串类型，但是在条件查询中输入的参数是整型，会造成索引失效。在执行计划的结果中会发现这条语句走的全表扫描。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> phone 字段，是二级索引且类型是 <span class="type">varchar</span>。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p><p>id 是整型，但是下面这条语句还是走了索引扫描的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这时因为<strong>字符串部分是输入参数，也就需要将字符串转为数字</strong>，所以这条语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>联合索引非最左匹配</strong>：<strong>使用表中多个字段创建的索引就叫联合索引</strong>，联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的原则进行索引匹配，否则就会导致索引失效。因为<strong>在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</strong></li></ul><blockquote><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有查询优化器，所以 x 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul></blockquote><ul><li><strong>在 WHERE 子句中，如果 OR 前的条件是索引字段，而 OR 后的条件不是索引字段</strong>，那么索引就会失效。因为只要有条件不是索引字段，就会进行全表扫描。</li></ul><h2 id="InnoDB-B-树"><a href="#InnoDB-B-树" class="headerlink" title="InnoDB &#x2F; B+树"></a>InnoDB &#x2F; B+树</h2><h3 id="Inno-DB-数据存储"><a href="#Inno-DB-数据存储" class="headerlink" title="Inno DB 数据存储"></a>Inno DB 数据存储</h3><p><strong>InnoDB 引擎以「数据页」为单位来读写</strong>，需要读一条记录时，会以页为单位整体读入内存。</p><p>即数据库 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都以 16KB 为单位，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 的内容刷新到磁盘中。</p><img src="/./res\243b1466779a9e107ae3ef0155604a17.png" alt="图片" style="zoom:50%;"><h3 id="Inno-DB-数据页结构"><a href="#Inno-DB-数据页结构" class="headerlink" title="Inno DB 数据页结构"></a>Inno DB 数据页结构</h3><img src="/./res\fabd6dadd61a0aa342d7107213955a72.png" alt="图片" style="zoom:67%;"><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向链表</strong>，如下图所示：</p><img src="/./res\557d17e05ce90f18591c2305871af665.png" alt="图片" style="zoom:67%;"><p>采用链表的结构是让数据页之间不需要是物理上的连续，而是逻辑上的连续。</p><p>数据页的主要作用是存储记录，也就是数据库的数据。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，会存储用户记录的相对位置，起到<strong>记录的索引作用</strong>，方便快速找到记录。</p><p>页目录与记录的关系如下图：</p><img src="/./res\261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom:67%;"><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录会存储每组最后一条记录的地址偏移量，地址偏移量会按照顺序存储起来，地址偏移量也叫做槽（slot），<strong>槽相当于指针，指向了不同组的最后一条记录</strong>。</li></ol><p>从图可以看到，<strong>页目录由多个槽组成的</strong>。因为记录是按照「主键值」从小到大排序的，所以槽也是从小到大排序的。因此<strong>查找记录时，可以使用二分法快速定位要查询的记录在哪个槽，定位到槽后，再遍历槽内所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个数据页中的记录链表。</p><p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组只能有 1 条记录；</li><li>最后一个分组的记录条数在 1-8 条之间；</li><li>剩下分组的记录条数在 4-8 条之间。</li></ul><h3 id="B-树的查询"><a href="#B-树的查询" class="headerlink" title="B+ 树的查询"></a>B+ 树的查询</h3><p><strong>InnoDB 采用了 B+ 树构造索引</strong>，“矮胖”的 B+ 树数据结构可以减少进行磁盘 I&#x2F;O 的次数，而且更适合进行关键字的范围查询。</p><p>B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><p><img src="/.%5Cres%5C7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><p>通过上图，我们看出 B+ 树的特点：</p><ul><li><strong>只有叶子节点才存放数据，非叶子节点仅存放索引。</strong></li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>定位记录时，先通过二分法快速定位到包含该记录的页，然后在页内再通过二分法快速定位到记录所在的分组（槽），最后在分组内进行遍历查找。</p><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引。且由于数据在物理上只会保存一份，所以<strong>聚簇索引只能有一个</strong>。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的<strong>唯一列</strong>作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li></ul><p>一张表只能有一个聚簇索引，为了实现非主键字段的快速搜索，就引出了二级索引，也是利用 B+ 树数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><h3 id="为什么使用B-树作为索引"><a href="#为什么使用B-树作为索引" class="headerlink" title="为什么使用B+树作为索引"></a>为什么使用B+树作为索引</h3><p>MySQL 会将数据持久化到硬盘，存储功能由 MySQL 存储引擎实现的，InnoDB 是 MySQL 默认的存储引擎，采用 B+ 树作为索引的数据结构。</p><p>B 树和 B+ 都是多叉树，会将树的高度变矮，所以这两个数据结构非常适合检索磁盘中的数据。</p><p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，而 B 树既存索引又存记录，所以 B + 树的非叶子节点可以存放更多的索引，因此 <strong>B+ 树比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O 次数会更少。</strong></li><li>B+ 树有大量的冗余节点，所有非叶子节点都是冗余索引，冗余索引能提高 <strong>B+ 树插入、删除时的效率</strong>，比如删除根节点时，不会像 B 树那样发生复杂的树变化；</li><li>B+ 树叶子节点间用链表连接，有利于范围查询，而 B 树只能通过树的遍历来完成范围查询，会涉及多个节点的磁盘 I&#x2F;O 操作，所以范围查询效率不如 B+ 树。</li></ul><h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><p>B+ 树与 B 树差异的点，主要是以下这几点：</p><ul><li>叶子节点才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li><li>所有索引都会出现在叶子节点，叶子节点间构成一个有序链表；</li><li>非叶子节点的索引会出现在子节点中，并且是子节点中最大或最小的索引。</li><li>非叶子节点有多少个索引，就有多少个子节点。</li></ul><h4 id="不使用B树的原因"><a href="#不使用B树的原因" class="headerlink" title="不使用B树的原因"></a>不使用B树的原因</h4><p>● B 树的非叶子节点也会存储 key 和 data，因此平均情况下，B 树的查找效率比 B+ 树更高。<br>● B 树的叶子节点是相互独立的，B+ 树的叶子节点有指向相邻节点的指针，因此 B+ 树排序和范围查询的效率更高。<br>● 因此 <strong>B 树更适合用于单一查询更多的数据库，如非关系型数据库。而 B+ 树则更适合用于排序和范围查询更多的数据库，如关系型数据库</strong>。</p><h4 id="不使用-Hash-表的原因"><a href="#不使用-Hash-表的原因" class="headerlink" title="不使用 Hash 表的原因"></a>不使用 Hash 表的原因</h4><p>● hash 冲突<br>● 不支持排序和范围查询</p><h4 id="不使用-BST（二叉搜索树）的原因"><a href="#不使用-BST（二叉搜索树）的原因" class="headerlink" title="不使用 BST（二叉搜索树）的原因"></a>不使用 BST（二叉搜索树）的原因</h4><p>● 不可能一次性把所有索引装入内存，只能逐一加载索引，因此 BST 的 I&#x2F;O 次数过多。且 BST 是二叉树，树的高度更高，存在极端情况下的线性高度问题。<br>● B+ 树单个节点包含的索引更多，相对需要的 I&#x2F;O 次数就更少。<br>● B+ 树高度一般为 2-4 层，只需要 2-4 次 I&#x2F;O。</p><h4 id="不使用红黑树的原因"><a href="#不使用红黑树的原因" class="headerlink" title="不使用红黑树的原因"></a>不使用红黑树的原因</h4><p>● 虽然红黑树结合了平衡树和 BST，解决了 BST 极端情况下的线性高度问题，但是依然存在着 BST 的缺点。<br>● 红黑树、BST 更适合在内存中使用，用于查找和排序。</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><h3 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>事务由 MySQL 引擎实现，常见的 InnoDB 引擎就支持事务。</p><p><strong>InnoDB 支持事务，MyISAM 不支持事务</strong></p><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致；例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不会被其他事务干扰。隔离性可以防止多个事务并发执行导致的数据不一致。</li><li><strong>持久性</strong>（<code>Durabilily</code>）：事务提交后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><blockquote><p>详解：</p><ul><li><strong>原子性（Atomicity）</strong>：<strong>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节</strong>，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li><li><strong>一致性（Consistency）</strong>：是指<strong>事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</strong>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul></blockquote><p><strong>InnoDB 引擎通过什么技术来保证事务的四个特性的呢？</strong></p><ul><li><strong>持久性通过 redo log（重做日志）保证</strong>；</li><li><strong>原子性通过 undo log（回滚日志） 保证</strong>；</li><li><strong>隔离性通过 MVCC（多版本并发控制） 或锁机制保证</strong>；</li><li><strong>一致性通过 持久性+原子性+隔离性 保证</strong>；</li></ul><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p><p><img src="/.%5Cres%5CAIDC.png" alt="AID-&gt;C"></p><h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><p>如果多个事务并发运行并操作相同数据，可能会导致以下的问题。</p><ul><li><strong>脏读（Dirty read）:</strong> <strong>一个事务「读到」了另一个「未提交事务修改过的数据」</strong>；</li><li><strong>不可重复读（Unrepeatable read）:</strong> 一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况。</li><li>**幻读（Phantom read）: **一个事务内多次查询符合某个条件的「记录数量」，出现前后两次记录数量不一样的情况。</li></ul><p>严重性：</p><p><img src="/.%5Cres%5Cd37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p><p><strong>不可重复读和幻读有什么区别呢？</strong></p><ul><li>不可重复读：同样的条件下，读取过的数据，当我们再次读取时值发生了变化。；</li><li>幻读：同样的条件下，第1次和第2次读出来的记录数不一样。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><blockquote><p><strong>丢失修改（Lost to modify）:</strong> 两个事务同时访问一个数据，然后第一个事务先修改该数据，第二个事务接着也修改这个数据。这样第一个事务的修改结果就会丢失。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p></blockquote><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li><strong>READ-UNCOMMITTED(读未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 多次读取同一数据的结果是一致的，除非数据是被本身事务所修改的，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，可以防止脏读、不可重复读以及幻读。</li></ul><img src="/./res\4e98ea2e60923b969790898565b4d643.png" alt="图片" style="zoom:67%;"><p><strong>InnoDB 引擎的默认隔离级别是「可重复读」，但是它通过next-key lock 锁（行锁和间隙锁的组合）锁住了记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</strong></p><h3 id="隔离级别的实现方式"><a href="#隔离级别的实现方式" class="headerlink" title="隔离级别的实现方式"></a>隔离级别的实现方式</h3><p>MySQL 隔离级别基于锁和 MVCC 机制共同实现的。</p><ul><li>对于「读未提交」隔离级别的事务，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好；</li><li>对于「串行化」隔离级别的事务，通过<strong>读写锁</strong>来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务，<strong>通过 Read View 实现，它们的区别在于创建 Read View 的时机不同，Read View 可以理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。</strong><ul><li><strong>「读提交」隔离级别每次 select 时都会生成一个新的 Read View</strong>，这意味着事务期间多次读取同一条数据，前后两次读的数据可能会不一致，因为别的事务可能在这期间修改了数据，并提交了事务。</li><li><strong>「可重复读」隔离级别在启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，</strong>这样就保证了事务期间读到的数据都是事务启动前的记录。</li></ul></li></ul><blockquote><p>这两个隔离级别通过对比<strong>「事务的 Read View 里的字段」和「记录中的两个隐藏列」，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）</strong>。</p></blockquote><h3 id="MVCC-的实现方式"><a href="#MVCC-的实现方式" class="headerlink" title="MVCC 的实现方式"></a>MVCC 的实现方式</h3><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><img src="/./res\readview结构.drawio.png" alt="img" style="zoom:67%;"><p>Read View 有<strong>四个重要的字段</strong>：</p><ul><li>m_ids ：指创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库应该分配给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id + 1；</li><li>creator_trx_id ：指<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><h4 id="聚簇索引记录中的两个隐藏列"><a href="#聚簇索引记录中的两个隐藏列" class="headerlink" title="聚簇索引记录中的两个隐藏列"></a>聚簇索引记录中的两个隐藏列</h4><p>使用 InnoDB 引擎的数据库表，它的聚簇索引记录中包含下面两个隐藏列：</p><ul><li>trx_id：当一个事务修改某条聚簇索引记录时，就会<strong>把这个事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer：每次修改聚簇索引记录时，都会把旧的记录写入 undo 日志中，<strong>roll_pointer 隐藏列是个指针，会指向旧的记录</strong>，可以通过 roll_pointer 找到修改前的记录。</li></ul><img src="/./res\f595d13450878acd04affa82731f76c5.png" alt="图片" style="zoom:67%;"><h4 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h4><p>创建 Read View 后，可以将记录中的 trx_id 分成三种情况：</p><img src="/./res\ReadView.drawio.png" alt="img" style="zoom:67%;"><p>一个事务访问记录时，除了自己的更新记录总是可见外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表明该版本记录是在创建 Read View <strong>前</strong>由已经提交的事务生成的，所以该版本记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表明该版本是在创建 Read View <strong>后</strong>由才启动的事务生成的，所以该版本记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表明生成该版本记录的活跃事务仍然活跃着（还没提交事务），所以该版本记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表明生成该版本记录的活跃事务已经被提交，所以该版本记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p>这种通过对比<strong>「事务的 Read View 里的字段」和「记录中的两个隐藏列」（版本链），来控制并发事务访问同一个记录时的行为，就叫 MVCC（多版本并发控制）</strong>。</p><h3 id="幻读的解决"><a href="#幻读的解决" class="headerlink" title="幻读的解决"></a>幻读的解决</h3><p>InnoDB 的默认隔离级别 RR（可重读）是<strong>可以解决幻读问题</strong>发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong> ：由 <strong>MVCC 机制</strong>来保证不出现幻读。</li><li><strong>当前读</strong>： 使用 <strong>Next-Key Lock 加锁</strong>来保证不出现幻读。</li></ul><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>在可重复读隔离级别下，<strong>普通查询是快照读，是不会看到别的事务插入的数据的</strong>，不会出现幻读。</p><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p><p><code>select ... for update</code> 语句也是当前读，每次执行前都查询最新的数据。</p><p>如下图，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。</p><p><strong>Innodb 引擎为了解决「可重复读」隔离级别中使用「当前读」导致的幻读问题，就引出了 next - key 锁</strong>，即记录锁和间隙锁的组合。</p><ul><li>记录锁，锁记录本身；</li><li>间隙锁，锁两个值之间的空隙，防止其他事务在这个空隙插入新数据，从而避免幻读现象。</li></ul><p>比如，执行这条语句时，会锁住id &gt; 2，如果有其他事务在锁住的范围内插入数据就会被阻塞。</p><img src="/./res\3af285a8e70f4d4198318057eb955520.png" alt="img" style="zoom:50%;"><h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h4><p>MyISAM 仅支持表级锁，一锁就锁整张表，所以并发写的情况下性能非常差。</p><p>InnoDB 不光支持表级锁，还支持行级锁，默认行级锁。行级锁的粒度更小，仅对相关的记录上锁（对一行或者多行记录加锁），所以并发写的情况下性能更高。</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的锁，针对<strong>非索引字段</strong>加锁，对整张表加锁，加锁快，不会出现死锁，但是锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的锁，针对<strong>索引字段</strong>加锁，只对当前操作的行记录进行加锁。 行级锁大大减少了锁冲突的概率，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p>只有通过索引字段检索数据，InnoDB才会使用行级锁，否则将使用表锁！</p><p><strong>注意事项</strong>：</p><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code> 条件中的字段没有命中索引或者索引失效的话，InnoDB 就会使用表级锁对表中所有行记录加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h4 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h4><p>表级锁和行级锁都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称<strong>读锁</strong>，事务读取记录时获取共享锁，允许多个事务同时获取。</li><li><strong>排他锁（X 锁）</strong> ：又称<strong>写锁</strong>&#x2F;<strong>独占锁</strong>，事务修改记录时获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那么其他事务不能再对这条事务加任何类型的锁。</li></ul><p>读读共享、读写互斥、写写互斥</p><p><img src="/.%5Cres%5Cimage-20220724172405583.png" alt="image-20220724172405583"></p><p>对于一般的 <code>SELECT</code> 语句，由于 MVCC 的存在，InnoDB 不会加任何锁。不过， 可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>行锁和表锁会冲突，如果需要用到表锁，如何确定表中的记录没有行锁呢？意向锁可以快速判断是否可以对某个表使用表锁。</p><p>意向锁是<strong>表级锁</strong>，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：如果事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：如果事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>意向锁是数据引擎自己维护的，用户无法手动操作意向锁。在为数据加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据所在表的意向锁。</p><p>如果意向锁被占用了，说明这张表中的某些记录加了行锁，就无法对这张表再加表锁。</p><p>意向锁之间是互相兼容的。</p><p><img src="/.%5Cres%5Cimage-20220724191901458.png" alt="image-20220724191901458"></p><p>意向锁和表级的共享锁、排他锁互斥，不与行级的共享锁、排他锁互斥。</p><p><strong>读读共享、读写互斥、写写互斥</strong></p><p><img src="/.%5Cres%5Cimage-20220724191947649.png" alt="image-20220724191947649"></p><h4 id="InnoDB-行锁类型"><a href="#InnoDB-行锁类型" class="headerlink" title="InnoDB 行锁类型"></a>InnoDB 行锁类型</h4><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-key Lock）</strong> ：Record Lock + Gap Lock，不仅会锁住记录本身，还会锁定一个范围，从而避免插入新记录，解决幻读问题。</li></ul><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</li></ul><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>InnoDB 存储引擎对读操作支持两种一致性锁定读方式，或者说对读操作支持两种加锁方式：</p><ul><li><code>SELECT ... FOR UPDATE</code>，对于读取的行记录加一个 X 排他锁，其他事务不能对锁定的行加任何锁</li><li><code>SELECT ... LOCK IN SHARE MODE</code>，对于读取的行记录添加一个 S 共享锁。其它事务可以向被锁定的行加 S 锁，但是不允许添加 X 锁，否则会被阻塞住</li></ul><h4 id="MySQL加锁方式"><a href="#MySQL加锁方式" class="headerlink" title="MySQL加锁方式"></a>MySQL加锁方式</h4><p>对记录加锁时，<strong>加锁的基本单位是 next - key lock</strong>，由记录锁和间隙锁组合而成，<strong>next-key lock 是 前开后闭 区间，而间隙锁是 前开后开 区间</strong>。</p><blockquote><p>next-key lock 在一些场景下会退化成记录锁或间隙锁。</p><p>例子id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。</p></blockquote><p><img src="/.%5Cres%5C954708d2f29c2a619e861e57cdf74c11.png" alt="图片"></p><h5 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h5><ul><li><strong>用「唯一索引进行等值查询」时，如果查询的记录存在，next-key lock 会退化成「记录锁」</strong>。</li><li><strong>用「唯一索引进行等值查询」时，如果查询的记录不存在，next-key lock 会退化成「间隙锁」。</strong></li></ul><blockquote><p> 如果查询的记录存在</p></blockquote><img src="/./res\2a944fb385d1de277dbfdc78102f36ba.png" alt="图片" style="zoom:67%;"><p>会话1加锁变化过程如下：</p><ol><li>加锁的基本单位是 next-key lock，因此会话1的加锁范围是(8, 16];</li><li>但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 <strong>next-key lock 退化成记录锁，因此最终加锁的范围是 id &#x3D; 16 这一行</strong>。</li></ol><p>所以，会话 2 在修改 id&#x3D;16 的记录时会被阻塞，而会话 3 插入 id&#x3D;9 的记录可以正常执行。</p><blockquote><p>如果查询的记录不存在</p></blockquote><img src="/./res\d82332993969a223fa3433eaf5185134.png" alt="图片" style="zoom:67%;"><p>会话1加锁变化过程如下：</p><ol><li>加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是 (8, 16];</li><li>但是由于是用唯一索引进行等值查询，且查询的记录不存在，所以 next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。</li></ol><p>所以，会话 2 要往这个间隙里面插入 id&#x3D;9 的记录会被阻塞，但是会话 3 修改 id &#x3D;16 是可以正常执行的。</p><h5 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h5><p>范围查询和等值查询的加锁规则是不同的。</p><p>下面这两条查询语句，查询的结果虽然是一样的，但是加锁的范围是不一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">8</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><img src="/./res\c12bdb8af1972d5f287978b489a83304.png" alt="图片" style="zoom:67%;"><p>会话 1 加锁变化过程如下：</p><ol><li>最开始要找的第一行是 id &#x3D; 8，因此 next-key lock  加锁范围是 (4,8]，由于 id 是唯一索引，且记录是存在的，因此会退化成记录锁，最终只对 id &#x3D; 8 这一行加锁；</li><li>由于是范围查找，会继续往后找存在的记录，直到找到 id &#x3D; 16 这一行停下来，然后加 next-key lock 加锁范围 (8, 16]，但由于 id &#x3D; 16 不满足 id &lt; 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。</li></ol><p>所以，会话 1 这时主键索引的锁是记录锁 id&#x3D;8 和间隙锁 (8, 16)。</p><p>会话 2 往间隙锁里插入 id &#x3D; 9 的记录，所以会被锁住。而 id &#x3D; 8 是被加锁的，因此会话 3 的语句也会被阻塞。</p><p>由于 id &#x3D; 16 并没有加锁，所以会话 4 是可以正常执行。</p><h5 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h5><p>用非唯一索引进行等值查询时，查询的记录存不存在，加锁的规则也不同：</p><ul><li><strong>如果查询的记录存在，除了会加 next-key lock 外，还会额外加间隙锁，也就是会加两把锁</strong>。</li><li><strong>如果查询的记录不存在，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁</strong>。</li></ul><blockquote><p>如果查询的记录存在</p></blockquote><img src="/./res\be6818bd1fd22c4e790b989bde11e6b1.png" alt="图片" style="zoom:67%;"><p>会话 1 加锁变化过程如下：</p><ol><li>先对普通索引 b 加上 next-key lock，加锁范围是 (4,8];</li><li>因为是非唯一索引，且查询的记录存在，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。</li></ol><p>所以，会话1的普通索引 b 上共有两个锁，分别是 next-key lock (4,8] 和间隙锁 (8,16) 。</p><p>当会话 2 往间隙锁里插入 id &#x3D; 9 的记录就会被阻塞，会话 3 和会话 4 是因为更改了 next-key lock 范围里的记录而被阻塞。</p><p>b &#x3D; 16 这条记录没有加锁，所以会话 5 是可以正常执行的。</p><blockquote><p>如果查询的记录不存在</p></blockquote><img src="/./res\案例5.drawio.png" alt="img" style="zoom:67%;"><p>会话 1 加锁变化过程如下：</p><ol><li>先对普通索引 b 加上 next-key lock，范围是 (8,16];</li><li>由于查询的记录不存在，所以不会再额外加间隙锁，且 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。</li></ol><p>会话 2 因为往间隙锁里插入了 b &#x3D; 9 的记录，所以会被阻塞，而 b &#x3D; 16 是没有被加锁的，因此会话 3 的语句可以正常执行。</p><h5 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h5><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁</strong>。</p><img src="/./res\ac6c09c4011259d3397e62e52a37d384.png" alt="图片" style="zoom:67%;"><p>会话 1 加锁变化过程如下：</p><ol><li>最开始要找的第一行是 b &#x3D; 8，因此 next-key lock 加锁范围是 (4,8]，由于 b 不是唯一索引，所以不会退化成记录锁。</li><li>由于是范围查找，会继续往后找存在的记录，直到找到 b &#x3D; 16 这一行停下来，然后加 next-key lock 加锁范围是 (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。</li></ol><p>所以，会话 1 的普通索引 b 有两个 next-key lock，分别是 (4,8] 和 (8, 16]。这样，你就明白为什么会话 2 、会话 3 、会话 4 的语句都会被锁住了。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>唯一索引等值查询：</p><ul><li>当查询的记录是存在的，next-key lock 会退化成「记录锁」。</li><li>当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。</li></ul><p>非唯一索引等值查询：</p><ul><li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li><li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li></ul><p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p><ul><li>唯一索引在满足一些条件时，next-key lock 退化为间隙锁和记录锁。</li><li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li></ul><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h2><h3 id="日志的分类"><a href="#日志的分类" class="headerlink" title="日志的分类"></a>日志的分类</h3><p>更新语句会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：</p><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎生成的日志，实现了事务的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎生成的日志，实现了事务的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h4 id="redo-log-和-undo-log-的区别"><a href="#redo-log-和-undo-log-的区别" class="headerlink" title="redo log 和 undo log 的区别"></a>redo log 和 undo log 的区别</h4><p>这两种日志都属于 InnoDB 存储引擎的日志，区别在于：</p><ul><li>redo log 记录了此次事务<strong>「完成后」</strong>的数据状态；</li><li>undo log 记录了此次事务<strong>「开始前」</strong>的数据状态；</li></ul><p><strong>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务</strong>。</p><h4 id="binlog-和-redo-log-的区别"><a href="#binlog-和-redo-log-的区别" class="headerlink" title="binlog 和 redo log 的区别"></a>binlog 和 redo log 的区别</h4><ul><li><strong>binlog</strong> 主要用于数据库还原，属于<strong>数据级别</strong>的数据恢复，主从复制是 binlog 最常见的一个应用场景。<strong>redo log</strong> 主要用于保证事务的持久性，属于<strong>事务级别</strong>的数据恢复。</li><li>redo log 是 InnoDB 引擎特有的，binlog 是所有存储引擎共有的，因为 binlog 是 MySQL 的 Server 层实现的。</li><li>redo log 属于物理日志，主要记录某个数据页的修改。binlog 属于逻辑日志，主要记录数据库执行的所有 DDL 和 DML 语句。</li><li>binlog 通过追加的方式进行写入，大小没有限制。redo log 通过循环的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。</li></ul><p><strong>数据操纵语言</strong>（Data Manipulation Language, DML）   数据定义语言DDL (Data Definition Language)</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 两大作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或用户执行了 ROLLBACK 语句，MySQL 就会使用 undo log 将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）时，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><blockquote><p> MySQL 的数据都是存在磁盘中的，要更新一条记录时，得先要从磁盘读取该记录，然后在内存中修改记录。修改完的记录不会直接写回磁盘，而是缓存起来。如果有查询语句再次命中这条记录，就会直接读取缓存中的记录，不需要再从磁盘中获取数据。</p></blockquote><p>为此，Innodb 存储引擎设计了<strong>缓冲池（Buffer Pool）</strong>，来<strong>提高数据库的读写性能</strong>。</p><p>有了 Buffer Pool 后：</p><ul><li>读取数据时，如果数据存在于 Buffer Pool 中，就会直接读取 Buffer Pool 中的数据。如果数据不存在于 Buffer Pool 中，才会去磁盘中读取。</li><li>修改数据时，如果数据存在于 Buffer Pool 中，就会直接修改 Buffer Pool 中数据所在的页，然后将该页设置为<strong>脏页</strong>（该页的数据和磁盘上的数据不一致），为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，而是由后台线程选择一个合适的时机将脏页写入磁盘。</li></ul><blockquote><p>Buffer Pool 缓存什么？</p></blockquote><p><strong>InnoDB 以「数据页」为单位进行读写</strong>，InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 <strong>16KB</strong>。因此，Buffer Pool 同样按「页」来划分。</p><p>MySQL 启动时，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的 <code>16KB</code> 大小划分出一个个的页，即缓存页</strong>。此时这些缓存页都是空闲的，随着程序的运行，磁盘中的页就会被缓存到 Buffer Pool 中。</p><p>所以，MySQL 刚启动时，会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址映射起来。</p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还缓存 Undo 页、插入缓存页、自适应哈希索引、锁信息等等。</p><p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240310144959039.png" alt="image-20240310144959039"></p><blockquote><p>Undo 页是记录什么？</p></blockquote><p>开启事务后，如果是更新操作，会把被更新的记录的旧值记下来，即生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页。</p><blockquote><p>查询一条记录，就只缓存一条记录吗？</p></blockquote><p>不是。查询一条记录时，InnoDB 会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><h4 id="redo-log-作用"><a href="#redo-log-作用" class="headerlink" title="redo log 作用"></a>redo log 作用</h4><p>redo log 是物理日志，记录某个数据页做了什么修改，比如 对 XX 表中 XX 数据页 XX 偏移量的地方做了XX 更新，每执行一个事务就会产生一条物理日志。</p><p>在事务提交时，不需要把将缓存在 Buffer Pool 里的脏页数据持久化到磁盘，先将 redo log 持久化到磁盘即可。当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，MySQL 重启后，可以根据 redo log 将所有数据恢复到最新的状态。</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><p>Buffer Pool 提高了读写效率，但是 Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p><p>为了防止断电导致数据丢失，当有记录需要更新的时候，InnoDB 引擎会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>，<strong>指 MySQL 的写操作不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上</strong>。</p><h4 id="redo-log-写入磁盘"><a href="#redo-log-写入磁盘" class="headerlink" title="redo log 写入磁盘"></a>redo log 写入磁盘</h4><p>实际上，事务产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作。</p><p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每产生一条 redo log 就会写入到 redo log buffer，后续再持久化到磁盘</p><p>刷盘时机：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的内存大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这个策略可由 innodb_flush_log_at_trx_commit 参数控制。</li></ul><p>参数 <code>innodb_flush_log_at_trx_commit</code> 控制，可取的值有：0、1、2，<strong>默认值为 1</strong>，这三个值分别代表的策略如下：</p><ul><li><strong>参数为 0 时</strong>，每次事务提交时 <strong>redo log 还是留在 redo log buffer 中</strong> ，不会主动触发写入磁盘的操作。</li><li><strong>参数为 1 时</strong>，每次事务提交时都会<strong>将缓存在 redo log buffer 里的 redo log 持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li><li><strong>参数为 2 时</strong>，每次事务提交时都会将缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件中，注意写入「 redo log 文件」并不意味着写入到了磁盘</strong>。操作系统的文件系统中有个 Page Cache，Page Cache 专门用来缓存文件数据的，所以<strong>写入「 redo log文件」意味着写入操作系统的文件缓存</strong>。</li></ul><p>这三个参数的数据安全性和写入性能的比较如下：</p><ul><li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li><li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li></ul><p>所以，数据安全性和写入性能是熊掌不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL 每完成一条更新操作，<strong>Server 层</strong>就会生成一条 binlog，等事务提交时，就会将事务执行期间产生的所有 binlog 一起写入 binlog 文件。binlog 文件<strong>记录了数据库执行的所有 DDL 和 DML 语句</strong>，不会记录查询类的操作，如 SELECT 和 SHOW。</p><blockquote><p>为什么有了 binlog， 还要有 redo log？</p></blockquote><p>这个问题跟 MySQL 的时间线有关系。</p><p>最开始 MySQL 里并没有 InnoDB 引擎，自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p><p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p><h2 id="读写分离和主从复制"><a href="#读写分离和主从复制" class="headerlink" title="读写分离和主从复制"></a>读写分离和主从复制</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><strong>读写分离将对数据库的读写操作分散到不同的数据库节点上。</strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。</p><img src="/./res\9c624bc130d053860a5089cb9a53310a.png" alt="读写分离" style="zoom:67%;"><p>一般情况下会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p><h4 id="读写分离存在的问题"><a href="#读写分离存在的问题" class="headerlink" title="读写分离存在的问题"></a>读写分离存在的问题</h4><p>读写分离对于提升数据库的并发非常有效，但是也会引来一个问题：主库和从库的数据存在延迟。写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题，即<strong>主从同步延迟</strong>。</p><p>主从同步延迟问题的解决，没有特别好的一种方案。你可以根据自己的业务场景，参考一下下面几种解决办法：</p><p><strong>强制将读请求路由到主库处理。</strong></p><p>既然从库的数据过期了，那就直接从主库读取。这种方案会增加主库的压力，但是实现起来比较简单，也是我了解到的使用最多的一种方式。</p><p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HintManager</span> <span class="variable">hintManager</span> <span class="operator">=</span> HintManager.getInstance();</span><br><span class="line">hintManager.setMasterRouteOnly();</span><br><span class="line"><span class="comment">// 继续JDBC操作</span></span><br></pre></td></tr></table></figure><p>对于这种方案，可以将那些必须获取最新数据的读请求都交给主库处理。</p><p><strong>延迟读取</strong></p><p>既然主从同步存在延迟，那就在延迟之后读取，比如主从同步延迟 0.5s，那就 1s 之后再读取数据。这样很方便，但是不好。</p><p>可以这样设计业务流程：对于一些对数据比较敏感的场景，在完成写请求之后，避免立即进行读请求。比如支付成功之后，跳转到一个支付成功的页面，点击返回之后才返回自己的账户进行读请求。</p><p><a href="https://funnylog.gitee.io/mysql45/22%E8%AE%B2MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%22%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%22%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95.html">MySQL45讲</a></p><h4 id="读写分离的实现方式"><a href="#读写分离的实现方式" class="headerlink" title="读写分离的实现方式"></a>读写分离的实现方式</h4><p>想要实现读写分离一般包含如下几步：</p><ol><li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li>保证主从数据库之间的数据是实时同步的，也就是我们常说的<strong>主从复制</strong>。</li><li>将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><h5 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a><strong>代理方式</strong></h5><img src="/./res\461112716e30db118f4c784adc6e2ff7.png" alt="读写分离-代理层" style="zoom:67%;"><p>可以在应用程序和数据库中间加一个代理层。应用程序所有的请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p><p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p><h5 id="组件方式"><a href="#组件方式" class="headerlink" title="组件方式"></a><strong>组件方式</strong></h5><p>也可以通过引入第三方组件来分离读写请求，也是比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。</p><p>如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p><p>你可以在 shardingsphere 官方找到sharding-jdbc 关于读写分离的操作<a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/">sharding-jdbc 关于读写分离的操作open in new window</a></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制的实现"><a href="#主从复制的实现" class="headerlink" title="主从复制的实现"></a>主从复制的实现</h4><p>MySQL binlog 记录了 **MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)**。因此根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p><img src="/./res\主从复制过程.drawio.png" alt="MySQL 主从复制过程" style="zoom:67%;"><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库中，每个从库把 binlog 写到中继日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>具体可以分为以下几步：</p><ol><li>主库将数据库中数据的变化写入  binlog</li><li>从库连接主库</li><li>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</li><li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li><li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li><li>从库的 SQL 线程读取 relay log 同步本地数据（也就是再执行一遍 SQL ）。</li></ol><p> 看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p><p><strong>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</strong></p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><p><strong>为了避免两份日志的逻辑不一致，事务的提交使用了「两阶段提交」</strong>。</p><p><strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入 binlog</strong>，具体如下：</p><ul><li><p><strong>prepare 阶段</strong>：将事务的 XID 写入 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到磁盘；</p></li><li><p><strong>commit 阶段</strong>：把 XID 写入 binlog，然后将 binlog 刷新到磁盘。接着提交事务，将 redo log 对应的事务状态设置为 commit（设置为 commit 状态后，redo log 也会刷新到磁盘， commit 状态是会刷盘的）。</p><blockquote><p>每个事务都有一个唯一的XID，而且这个XID在整个数据库中都是唯一的。</p></blockquote></li></ul><p><strong>问题</strong></p><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交能够保证「单事务」情况下两个日志的内容一致，但却不能保证「多事务」情况下两个日志的提交顺序一致。因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务情况下，两个日志的提交顺序一致。</li></ul><h4 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h4><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交时，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</strong>，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p><p>引入组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog  写入 binlog  文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><p>上面<strong>三个阶段都有一个队列</strong>，每个阶段都有锁进行保护，保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p>对每个阶段引入队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，<strong>锁粒度减小了，使得多个阶段可以并发执行，从而提升效率</strong>。</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库。</p><p>下面这些操作都涉及到了分库：</p><ul><li>你将数据库中的用户表和用户订单表分别放在两个不同的数据库。</li><li>由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。</li></ul><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p><p><strong>垂直拆分</strong></p><p>简单来说，垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p><p><strong>水平拆分</strong></p><p>简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。</p><p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>遇到下面几种场景可以考虑分库分表：</p><ul><li>单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。</li><li>数据库中数据占用的空间越来越大，备份时间越来越长（分库）。</li><li>应用的并发量太大（分库）。</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p><strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作，所以需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</p></li><li><p><strong>事务问题</strong> ：同一个数据库中的表分布在不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求了。</p></li><li><p><strong>分布式 id</strong> ：分库之后， 数据分布在不同服务器的数据库中，数据库的自增主键已经没办法满足主键唯一了。这时就需要引入分布式 id 为不同的数据节点生成全局唯一主键。</p></li></ul><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p><p>比较简单同时也是非常常用的方案就是<strong>停机迁移</strong>。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p><p>如果你不想停机迁移数据的话，可以考虑<strong>双写方案</strong>。双写方案针对不能停机迁移的场景，实现起来比较复杂。具体原理是这样的：</p><ul><li>对老库的更新操作（增删改），同时也要写入新库（双写）。保证新库里的数据是最新的。</li><li>双写只会让老库中被更新过的数据同步到新库，还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li><li>重复上一步的操作，直到老库和新库的数据一致为止。</li></ul><p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p><h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p><img src="/./res\60649996bfc69acb1953063dddf0c2e6.png" alt="img" style="zoom:33%;"><p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="慢查询的定位及优化"><a href="#慢查询的定位及优化" class="headerlink" title="慢查询的定位及优化"></a>慢查询的定位及优化</h3><p><strong>慢查询日志</strong></p><p>开启 MySQL 的<strong>“慢查询日志”</strong>功能，然后稍作配置即可。慢查询日志功能会把查询时间大于设置时间的 SQL 记录下来，并保存到文件中，只需要查看这个文件内容就可以找到对应的慢 SQL 了。</p><p><strong>慢查询日志的配置</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>开启或关闭慢查询日志</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="keyword">ON</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>慢查询的时间阈值，<span class="keyword">SQL</span>执行超过此时间则会被记录到日志</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定生成的慢查询日志路径</span><br><span class="line">slow_query_log_file <span class="operator">=</span> <span class="operator">/</span>opt<span class="operator">/</span>soft<span class="operator">/</span>mysql<span class="operator">/</span>log<span class="operator">/</span>slow.log</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>是否记录未使用索引的<span class="keyword">SQL</span></span><br><span class="line">log_queries_not_using_indexes<span class="operator">=</span><span class="keyword">on</span></span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><ul><li><strong>是否命中索引：</strong>分析语句的执行计划，获得索引使用情况，之后修改语句或者修改索引，使得语句尽可能命中索引。</li><li><strong>是否加载了不需要的数据列：</strong>分析语句看看结果是否加载了不需要的列，对语句进行修改。</li><li><strong>数据量是否太大：</strong>考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h3 id="行计划-explain"><a href="#行计划-explain" class="headerlink" title="行计划  explain"></a>行计划  explain</h3><p>Mysql 提供了 explain 命令对 SQL 进行分析，只要在 SQL 语句前加上 explain 关键字，就可以得到 SQL 的执行计划，执行计划包含了 SQL 中表的读取顺序、查询类型、使用的索引、使用索引的长度 、扫描了多少条记录等，通过执行计划可以快速定位到哪些地方可以进行优化。</p><p><img src="/.%5Cres%5Cimage-20220802165905848.png" alt="image-20220802165905848"></p><ul><li><strong>select_type</strong>：用于区分查询语句的类型，通过这个列可以区分SQL属于简单的select、联合查询、子查询等。<ul><li><strong>SIMPLE：</strong> 简单的 select 查询，不包含任何子查询或联合查询</li><li><strong>PRIMARY：</strong> 主查询，如果有子查询的话最外层的查询会被标记为 PRIMARY。</li><li><strong>SUBQUERY：</strong> 该语句属于子查询语句。</li><li><strong>DERIVED ：</strong> 生成的临时表的查询语句会被标记为 DERIVED 。</li><li><strong>UNION ：</strong> 标记为 UNION 类型的查询语句。</li><li><strong>UNION RESULT:</strong> 从 UNION 语句中获取结果。</li></ul></li><li>**type (重要)**：通过 type 可以直观的判断 SQL 的性能，type包括以下几种类型： system 、const 、eq_ref、ref、Range、Index、All，他性能依次从高到低。<ul><li><strong>System：</strong> 表只有一行记录。</li><li><strong>Const：</strong> 通过索引一次就找到了数据，一般出现在使用 primary key 或 unique 索引匹配到了数据，匹配的条件是常量（字符串、数字）。</li><li><strong>eq_ref：</strong> 使用了主键索引或非空唯一索引，在表中只有一条记录与索引相匹配，匹配条件是某个表的列。</li><li><strong>ref：</strong> 非唯一性索引扫描，和eq_ref 不同的是eq_ref 匹配的是唯一索引，ref它返回所有匹配某个单独值的行,它可能会找到多个符合条件的行。</li><li><strong>range：</strong> 范围数据扫描。</li><li><strong>index：</strong> 全索引扫描，通过扫描整棵索引树获取到结果。</li><li><strong>All：</strong> 全表扫描。</li></ul></li><li><strong>possible_keys:</strong>  可能使用到的索引 。</li><li>**key: ** 实际使用到的索引。如果为空，则说明没有使用索引。</li><li><strong>key_len：</strong> 使用到的索引 key 的长度，如果为联合索引则显示已命中的联合索引长度之和（如：联合索引为 a + b + c ，如果索引命中了 a + b ，那么长度就为a+b的索引长度，通常可以通过 key_len 来分析联合索引所命中的情况）。</li></ul><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul><li><strong>前缀索引优化：</strong>当大字符串的字段作为索引时，可以使用前缀索引减小索引项的大小，从而增加一个索引页中存储的索引值，有效提高索引的查询速度。前缀索引有一定的局限性：<ul><li>order by 就无法使用前缀索引</li><li>无法把前缀索引用作覆盖索引</li></ul></li><li><strong>覆盖索引优化</strong>：使用覆盖索引可以避免回表操作，提高检索速度；同时不需要查询出整行记录，减少了大量的 I&#x2F;O 操作。</li><li><strong>主键索引最好是自增的</strong></li><li><strong>索引最好设置为 NOT NULL</strong><ul><li>索引列存在 NULL 会导致优化器难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为 NULL 的行。</li><li>NULL 是一个没意义的值，但是会占用物理空间，带来存储空间的问题，导致更多的存储空间占用</li></ul></li><li><strong>防止索引失效</strong></li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul><li><p>**禁止使用SELECT *，必须使用 SELECT &lt;字段列表&gt; 进行查询**，原因如下：</p><ul><li>消耗更多的 CPU 和 IO 资源</li><li>无法使用覆盖索引</li></ul></li><li><p><strong>避免使用子查询，可以把子查询优化为连接查询，因为子查询的性能比连接查询要差</strong>。子查询性能差的原因：</p><p><strong>子查询的结果集无法使用索引</strong>，通常子查询的结果集会被存储到临时表中，临时表不存在索引，所以查询性能会受到影响。特别是返回结果集比较大的子查询，其对查询性能的影响也就越大。</p></li><li><p><strong>避免使用 JOIN 关联太多的表</strong></p><ul><li>MySQL 是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置</li><li>对于同一个 SQL ，多关联一个表，就会多分配一个关联缓存，一个 SQL 中关联的表越多，所占用的内存也就越大。</li><li>如果程序中大量使用多表关联的 SQL，同时 join_buffer_size 设置的也不合理，就会造成内存溢出，影响到数据库的稳定性。</li></ul></li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="概念和优缺点"><a href="#概念和优缺点" class="headerlink" title="概念和优缺点"></a>概念和优缺点</h3><p>Redis 是基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存、消息队列、分布式锁等场景</strong>。</p><p>Redis 提供了多种数据类型，比如 String (字符串)、Hash (哈希)、 List (列表)、Set (集合)、Zset (有序集合)、Bitmaps (位图)、HyperLogLog (基数统计)、GEO (地理信息)、Stream (流)，且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p><p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p><p><strong>优点：</strong></p><ul><li>读写性能极高， Redis 读的速度是 110000 次 &#x2F; s，写的速度是 81000 次 &#x2F; s。</li><li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li><li>支持事务， Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操<br>作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li><li>数据结构丰富，除了支持 string 类型的 value 外，还支持 hash、set、zset、list 等数据结构。<br>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li><li>丰富的特性 – Redis 还支持 publish&#x2F;subscribe（发布&#x2F;订阅模式），通知， key 过期等特性。</li></ul><p><strong>缺点：</strong></p><ul><li>容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合用在较小数据量的高性能操作和运算上。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</li></ul><h3 id="Redis-高速原因"><a href="#Redis-高速原因" class="headerlink" title="Redis 高速原因"></a>Redis 高速原因</h3><ul><li><p><strong>内存存储</strong>：Redis 使用内存 (in-memeroy) 存储，没有磁盘 IO 开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)。</p></li><li><p><strong>单线程实现</strong>（Redis 6.0以前）：Redis 使用单线程处理网络请求，避免了多个线程之间线程切换和锁竞争的开销。</p></li><li><p><strong>非阻塞IO</strong>：Redis 使用多路 IO 复用技术，将 epoll 作为多路 IO 复用技术的实现，再加上 Redis 自身的事件处理模型，将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I&#x2F;O 上浪费过多时间。</p></li><li><p>优化的数据结构：Redis 有很多优化的数据结构实现，应用层可以直接使用以提升性能。</p></li><li><p>使用底层模型不同：Redis 自己构建了 VM (虚拟内存)机制。</p></li></ul><blockquote><p>Redis 的 VM (虚拟内存) 机制就是把不经常访问的数据 (冷数据) 从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据 (热数据) 。通过 VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。<br>Redis 提高数据库容量的办法有两种：一种是可以将数据分割到多个 RedisServer 上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。需要特别注意的是Redis并没有使用 OS 提供的 Swap，而是自己实现。</p></blockquote><h3 id="Redis-和-Memcached-的区别"><a href="#Redis-和-Memcached-的区别" class="headerlink" title="Redis 和 Memcached 的区别"></a>Redis 和 Memcached 的区别</h3><p>Redis 可以用作缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，要弄清楚 Redis 和 Memcached 的区别。</p><p>Redis 与 Memcached <strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用做缓存。</li><li>都有过期策略。</li><li>性能都非常高。</li><li>都是分布式缓存。</li></ol><p>Redis 与 Memcached <strong>区别</strong>：</p><ul><li><strong>Redis 支持的数据类型更丰富</strong>（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li><li><strong>Redis 支持数据的持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li><li><strong>Redis 有原生的集群模式</strong>，Memcached 没有原生的集群模式；</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能</strong>，而 Memcached 不支持；</li><li><strong>网络 IO 模型</strong>：Redis使用单线程的多路 IO 复用模型，Memcached 使用多线程的非阻塞 IO 模式。</li><li><strong>Redis 支持服务器端的数据操作</strong>：Memcached 需要将数据拿到客户端修改再set回去，大大增加了网络IO的次数。而 Redis 支持在服务器端进行数据操作。</li></ul><h3 id="为什么用-Redis-而不用-map-guava-做缓存"><a href="#为什么用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么用 Redis 而不用 map&#x2F;guava 做缓存?"></a><strong>为什么用 Redis 而不用 map&#x2F;guava 做缓存?</strong></h3><p>缓存分为本地缓存和分布式缓存，map 和 guava 是本地缓存，特点是轻量以及快速，但是它们的生命周期随着 jvm 的销毁而结束，且在多实例的情况下，每个实例都各自保存一份缓存，缓存不具有一致性。<br>Redis 是<strong>分布式缓存</strong>，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 Redis 服务的高可用，架构上较为复杂。</p><p><strong>对比:</strong></p><ul><li>Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 最多分几个 G 内存；</li><li>Redis <strong>缓存可以持久化</strong>，Map 是内存对象，程序一重启数据就没了；</li><li>Redis 是<strong>分布式缓存</strong>，Map 是本地缓存；</li><li>Redis 每秒可以处理百万级并发，Map 只是一个普通的对象；</li><li>Redis 缓存<strong>有过期机制</strong>，Map 没有；</li><li>Redis 可单独部署，多个项目之间可以共享，本地内存无法共享；</li><li>Redis 有专门的管理工具可以查看缓存数据</li></ul><h3 id="使用-Redis-缓存的原因"><a href="#使用-Redis-缓存的原因" class="headerlink" title="使用 Redis 缓存的原因"></a>使用 Redis 缓存的原因</h3><p>因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p><p><em><strong>1、高性能</strong></em></p><p>用户第一次访问 MySQL 中的数据会比较慢，因为需要从硬盘中读取。将用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据时就可以直接从Redis 缓存中获取，<strong>操作 Redis 缓存就是直接操作内存，速度相当快</strong>。</p><p><em><strong>2、高并发</strong></em></p><p>Redis 的 QPS 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p><p><strong>直接操作缓存能够承受的请求是远远大于直接访问数据库的</strong>，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h3 id="数据类型和使用场景"><a href="#数据类型和使用场景" class="headerlink" title="数据类型和使用场景"></a>数据类型和使用场景</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><img src="/./res\五种数据类型.png" alt="img" style="zoom: 50%;"><p>后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。</p><p>Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流）</p><p><strong>应用场景</strong></p><p>Redis 五种数据类型的应用场景：</p><ul><li>String 类型：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型：消息队列。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><p>这五种数据类型都由多种数据结构实现的，主要是出于时间和空间的考虑，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。</p><p>这五种数据类型与底层数据结构对应关系图如下</p><img src="/./res\9fa26a74965efbf0f56b707a03bb9b7f.png" alt="img" style="zoom: 50%;"><h4 id="SDS（String的底层结构）"><a href="#SDS（String的底层结构）" class="headerlink" title="SDS（String的底层结构）"></a>SDS（String的底层结构）</h4><p><strong>C语言字符串的缺陷</strong></p><ul><li>**获取字符串长度的时间复杂度为O(N)**。C语言的字符数组以”\0”结尾，获取字符串长度就是从头开始遍历到”\0”结束，然后统计字符的个数。</li><li><strong>只能保存文本数据，不能保存像图片、音频、视频这样的二进制数据。</strong>因为除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾。</li><li><strong>C 语言的字符串是不会记录自身的缓冲区大小的，在拼接字符串的时候可能会造成缓冲区溢出</strong>。</li></ul><p><strong>SDS结构设计</strong></p><img src="/./res\image-20220818081642889.png" alt="image-20220818081642889" style="zoom: 50%;"><ul><li><strong>SDS的成员变量</strong><ul><li><strong>len：</strong>记录了字符串的长度</li><li><strong>alloc：</strong>记录了分配给字符数组的空间长度</li><li><strong>flags：</strong>用来表示不同类型的SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64</li><li>**buf[]**：字符数组，用来保存实际数据</li></ul></li><li><strong>SDS相比于C的改进</strong><ul><li><strong>O(1)时间复杂度获取字符串长度</strong>。通过len属性直接返回字符串长度</li><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>使用len属性来记录长度，所以可存储包含 “\0” 的数据</strong>。</li><li><strong>不会发生缓冲区溢出</strong>。在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话Redis会自动扩大SDS的空间大小(<strong>小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容</strong>)，然后才执行实际的修改操作，避免发生缓冲区溢出。</li><li><strong>节省内存空间</strong>。SDS的flags有5种类型，这 5 种类型的主要<strong>区别就在于它们的len和alloc的数据类型不同</strong>，如sdshdr16其数据类型为16位，sdshdr32则是32位。<strong>SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong></li></ul></li></ul><h4 id="哈希表（hash和set的底层结构）"><a href="#哈希表（hash和set的底层结构）" class="headerlink" title="哈希表（hash和set的底层结构）"></a>哈希表（hash和set的底层结构）</h4><ul><li><p><strong>底层存储</strong>：底层采用数组+链表的形式存储元素，采用拉链法解决哈希冲突</p></li><li><p><strong>rehash：</strong>哈希结构体内部定义了两个哈希表，在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li><li><strong>存在的问题：如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong></li></ul></li><li><p><strong>渐进式hash</strong>：为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」分配空间，<strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会依次将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong></li><li>在此期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。查找、删除和更新操作时，会先去「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。<strong>所有的添加操作都会直接添加到「哈希表 2」上</strong></li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</li></ul></li><li><p><strong>rehash触发条件</strong>：rehash 的触发条件跟<strong>负载因子（load factor）</strong>有关系，负载因子&#x3D;哈希表已保存节点数量&#x2F;哈希表大小。触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作</strong></li></ul></li></ul><h4 id="跳表（zset的底层结构）"><a href="#跳表（zset的底层结构）" class="headerlink" title="跳表（zset的底层结构）"></a>跳表（zset的底层结构）</h4><ul><li><strong>定义：</strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是<strong>能快读定位数据。</strong></li><li><strong>底层实现</strong><ul><li>跳表结构包含了：<ul><li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量</li></ul></li><li>每个Zset元素包括以下几部分：<ul><li>元素值ele、元素权重值score、后向指针。其中后向指针指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</li><li><strong>level数组</strong>：跳表的特性是通过一个<strong>zskiplistLevel 结构体类型的 level 数组</strong>来实现的，level数组中的每一个元素代表跳表的一层，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</li><li><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</li></ul></li></ul></li><li><strong>跳表节点的查询过程</strong><ul><li>跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的元素和权重来进行判断：如果当前节点的权重「小于」要查找的权重，或者当前节点的权重「等于」要查找的权重，并且当前节点的元素「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li><li>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</li></ul></li></ul><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p>6.0 以前使用单线程模型处理网络 IO 和执行命令，6.0 以后使用单线程模型执行命令，多线程模型处理网络 IO，<strong>回答时只说单线程模型</strong></p><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;数据读写-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p></li><li><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过<strong>多路 IO 复用</strong> 来监听客户端的大量连接（或者说是监听多个 socket），它会将事件注册到内核中并监听每个事件是否发生。<strong>I&#x2F;O 多路复用技术让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p></li><li><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p><ul><li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li><li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来<strong>异步释放 Redis 内存</strong>，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要<strong>删除一个大 key 的时候，不要使用 del 命令删除</strong>，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该<strong>使用 unlink 命令来异步删除大key</strong>。</li></ul></li></ul><blockquote><p> <strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的<strong>文件事件处理器（file event handler）。由于</strong>文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p> Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。</p></blockquote><p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p><p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p><img src="/./res\后台线程.jpg" alt="img" style="zoom: 33%;"><p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p><ul><li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li><li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li><li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 &#x2F; free(dict) 删除数据库所有对象 &#x2F; free(skiplist) 释放跳表对象；</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Redis 初始化的时候，会做下面这几件事情：</p><ul><li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 一个服务端 socket</li><li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li><li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li></ul><p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情：</p><ul><li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li><li>接着，调用 epoll_wait 函数等待事件的到来：<ul><li>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li><li>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li><li>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li></ul></li></ul><p>Redis 6.0 版本之前的单线模式如下图：</p><img src="/./res\redis单线程模型.drawio.png" alt="img" style="zoom:50%;"><p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I&#x2F;O 和命令处理都是单线程。 </p><h4 id="单线程仍然高速的理由"><a href="#单线程仍然高速的理由" class="headerlink" title="单线程仍然高速的理由"></a>单线程仍然高速的理由</h4><p><strong>QPS</strong>：全名 Queries Per Second，意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W&#x2F;每秒</strong></p><ul><li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li><li>Redis 采用单线程模型<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li><li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是我们经常听到的 select&#x2F;epoll 机制。该机制允许内核中同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，实现一个 Redis 线程处理多个 IO 流的效果。</li></ul><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><strong>Redis 6.0 版本引入的多线程处理网络IO</strong></p><h4 id="Redis-6-0-之前为什么使用单线程"><a href="#Redis-6-0-之前为什么使用单线程" class="headerlink" title="Redis 6.0 之前为什么使用单线程"></a>Redis 6.0 之前为什么使用单线程</h4><p>我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I&#x2F;O 和执行命令）为什么还要使用单线程呢？</p><ol><li>单线程编程容易并且更容易维护；</li><li><strong>Redis 的性能瓶颈不在 CPU ，主要在内存和网络</strong>；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><h4 id="Redis-6-0-之后为什么引入多线程"><a href="#Redis-6-0-之后为什么引入多线程" class="headerlink" title="Redis 6.0 之后为什么引入多线程"></a>Redis 6.0 之后为什么引入多线程</h4><p><strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</strong>。</p><p>所以为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理</strong>，因此，也不需要担心线程安全问题。</p><p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上</strong></p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="数据不丢失"><a href="#数据不丢失" class="headerlink" title="数据不丢失"></a>数据不丢失</h3><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p><p>Redis 共有三种数据持久化的方式：</p><ul><li><strong>AOF 日志</strong>：每执行一条<strong>写操作命令</strong>，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li></ul><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p><img src="/./res\6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img" style="zoom:50%;"><h4 id="先执行命令的好处和坏处"><a href="#先执行命令的好处和坏处" class="headerlink" title="先执行命令的好处和坏处"></a>先执行命令的好处和坏处</h4><p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p><ul><li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li><li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li></ul><p>当然，这样做也会带来风险：</p><ul><li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li><li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><h4 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h4><p>Redis 提供了 3 种写回硬盘的策略，<strong>控制内核缓冲区写入到硬盘的时间</strong>。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p><ul><li><strong>Always</strong>：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li><strong>Everysec</strong>：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><img src="/./res\98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom: 50%;"><p>Redis 写入 AOF 日志的过程，如下图：</p><img src="/./res\4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" style="zoom:50%;"><p>具体说说：</p><ol><li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li><li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li></ol><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><blockquote><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p></blockquote><p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p>AOF 重写机制是<strong>在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</strong>。</p><p><strong>过程</strong></p><p>①触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会<strong>读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</strong>（新的 AOF 文件）。</p><blockquote><p>Redis 的<strong>重写 AOF 过程是由&#x3D;&#x3D;后台子进程&#x3D;&#x3D; bgrewriteaof来完成的</strong>，这么做可以达到两个好处：</p><ul><li><strong>子进程进行 AOF 重写期间，主进程可以继续处理命令请求</strong>，从而避免阻塞主进程；</li><li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，**创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生&#x3D;&#x3D;「写时复制」&#x3D;&#x3D;**，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li></ul><p>但是重写过程中，主进程依然可以正常处理命令，那问题来了，重写 AOF 日志过程中，<strong>如果主进程修改了已经存在 key-value</strong>，那么会发生写时复制，此时这个 key-value 数据在<strong>子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</strong></p></blockquote><p>②为了解决<strong>重写 AOF 日志过程中，主进程修改了已经存在 key-value</strong>的这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p><blockquote><p>在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令；</li><li>将执行后的写命令追加到 「AOF 缓冲区」；</li><li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li></ul><p>当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 <strong>AOF 重写缓冲区</strong>中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p></blockquote><img src="/./res\202105270918298.png" alt="img" style="zoom:50%;"><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>因为 <strong>AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢</strong></p><blockquote><p>为了解决这个问题，Redis 增加了 RDB 快照。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。</p></blockquote><p>所以，<strong>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据</strong>，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><h4 id="RDB-做快照时会阻塞线程吗"><a href="#RDB-做快照时会阻塞线程吗" class="headerlink" title="RDB 做快照时会阻塞线程吗"></a>RDB 做快照时会阻塞线程吗</h4><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li></ul><blockquote><p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p><ul><li>900 秒之内，对数据库进行了至少 1 次修改；</li><li>300 秒之内，对数据库进行了至少 10 次修改；</li><li>60 秒之内，对数据库进行了至少 10000 次修改。</li></ul></blockquote><h4 id="RDB-在执行快照的时候，数据能修改吗？"><a href="#RDB-在执行快照的时候，数据能修改吗？" class="headerlink" title="RDB 在执行快照的时候，数据能修改吗？"></a>RDB 在执行快照的时候，数据能修改吗？</h4><p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p><p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p><img src="/./res\c34a9d1f58d602ff1fe8601f7270baa7.png" alt="img" style="zoom: 50%;"><p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p><img src="/./res\ebd620db8a1af66fbeb8f4d4ef6adc68.png" alt="img" style="zoom: 50%;"><p><strong>数据丢失：</strong></p><p>Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程的内存数据和子线程的内存数据已经分离了，<strong>子线程写入到 RDB 文件的内存数据只能是原本（修改前）的内存数据</strong>。</p><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p><strong>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</strong></p><p><strong>AOF 优点是丢失数据少，但是数据恢复不快。</strong></p><p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主进程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主进程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><img src="/./res\f67379b60d151262753fec3b817b8617.png" alt="img" style="zoom: 50%;"><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><p><strong>混合持久化优点：</strong></p><ul><li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li></ul><p><strong>混合持久化缺点：</strong></p><ul><li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li><li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li></ul><h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p>单机Redis存在单点风险问题，如果Redis宕机，会导致大量请求直接落到数据库，造成数据库压力过大。<strong>如果保证Redis服务的高可用？</strong></p><p>① <strong>主从复制</strong>：基于主从复制搭建一个Redis集群，主节点master负责处理写请求，从节点slave负责处理读请求，master宕机时从slave中选出一台作为master即可。</p><p>② **Redis Sentinel(哨兵模式)**：基于主从复制的Redis集群解决方案，用于解决集群主从节点的故障切换问题。</p><p>③ **Redis Cluster(切片集群)**：Redis Sentinel方案主要提高了Redis集群的可用性和读吞吐量，并不能缓解写压力以及解决缓存数据量过大的问题，此时就需要用到Redis分片集群了。</p><h3 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h3><h4 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h4><p>将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点 (master)，后者称为从节点 (slave)，数据的复制是单向的，只能由主节点到从节点。</p><p>所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。主从服务器之间的命令复制是<strong>异步</strong>进行的。具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，<strong>主从服务器间的数据就不一致了</strong>。</p><p><strong>作用</strong></p><ul><li><strong>数据冗余：</strong>主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复</li><li><strong>读写分离：</strong>可以用于实现读写分离，主库写、从库读</li><li><strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li></ul><p><strong>主从数据同步</strong></p><ul><li><p><strong>全量同步</strong></p><p>Redis 全量同步发生在 Slave 初始化阶段，这时 Slave 需要将 Master 上的所有数据都复制一份。具体步骤如下：</p><ul><li>当一个从库启动时，从库给主库发送 psync 命令进行数据同步</li><li>当主库接收到 psync 命令后就会保存 RDB 文件并发送给从库，发送期间会使用 replication buffer 记录后续的所有写操作 ，从库收到数据后，会先清空当前数据库，然后加载从主库获取的RDB 文件。</li><li>当主库完成 RDB 文件发送后，再把将保存发送RDB文件期间写操作的 replication buffer 发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</li></ul></li><li><p><strong>增量同步</strong></p><p>Redis 增量同步是指 Slave 初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程，主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p></li></ul><img src="/./res\2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="img" style="zoom: 50%;"><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>Redis 的主从服务器如果出现故障宕机，需要手动恢复。为了解决这个问题，Redis 增加了哨兵模式（<strong>Redis Sentinel</strong>），哨兵模式可以监控主从服务器，并提供<strong>主从节点故障转移功能。</strong></p><p><strong>作用</strong></p><ul><li><strong>监控：</strong>监控所有 Redis 节点的状态是否正常</li><li><strong>通知：</strong>可以通过 API 通知系统管理员或者其他计算机程序，其中一个受监控的 Redis 实例出现问题</li><li><strong>故障切换：</strong>如果一个 master 出现故障，Sentinel 会进行故障切换，自动将一台 slave 升级为 master，确保整个 Redis 系统的可用性</li></ul><p><strong>多哨兵模式</strong></p><p>只用一个哨兵监控 Redis 服务器可能会出现问题，让<strong>多个哨兵通过投票的方式来确定 Redis 服务器是否真的不可用，可以避免误判</strong>。这些哨兵中会有一个 <strong>Leader 来负责故障切换</strong>。Leader 的选取主要用到分布式领域的共识算法，共识算法就是让分布式系统中的节点就一个问题达成共识，哨兵选取 Leader 使用的是 <strong>Raft 算法</strong>。</p><p><strong>故障切换的过程</strong></p><p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行切换过程，当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，最终由 Leader 来进行切换操作。切换成功后，就会通过<strong>发布订阅</strong>模式，让各个哨兵把自己监控的从服务器实现切换主机。</p><img src="/./res\26f88373d8454682b9e0c1d4fd1611b4.png" alt="img" style="zoom: 50%;"><h4 id="切片集群模式"><a href="#切片集群模式" class="headerlink" title="切片集群模式"></a>切片集群模式</h4><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p><p><strong>定义和作用</strong></p><p>主从复制和 Redis 哨兵本质上是通过增加副本的方式提高 Redis 服务的可用性和读吞吐量，这两种方案都不支持横向扩展来<strong>缓解写压力以及解决缓存数据量过大的问题</strong>，如果写压力太大或缓存数据量太大可以采用 Redis 切片集群。<strong>Redis 切片集群就是部署多台 Redis 实例，这些 Redis 实例没有主从之分，同时对外提供读&#x2F;写服务，缓存的数据相对均匀地分布在这些 Redis 实例上</strong>。</p><p><strong>Redis Cluster</strong></p><ul><li>Redis Cluster是Redis3.0提出的分片集群解决方案，通过分片来进行数据管理，采用的是<strong>虚拟槽分区</strong>，每一个键值对都属于一个**hash slot(虚拟槽)**，虚拟槽均匀的分布在多个Redis实例上。</li><li>当要读取数据时只需要计算出对应key所在的虚拟槽即可；Redis Cluster是去中心化的，任何一个Redis实例宕机其他实例不受影响；当要新增Redis实例时只需要将一些虚拟槽从已有的实例中移动过去。</li><li><strong>虚拟槽分区机制解耦了数据与节点之间的关系，提升了集群的横向扩展性和容错性</strong>。</li><li>Redis Cluster是一个典型的分布式系统，各个节点需要互相通信，基于<strong>Gossip协议</strong>来实现数据的最终一致性(每个Redis节点都维护了一份集群的状态信息)</li></ul><p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p><ul><li>根据键值对的 key，按照 CRC16（<strong>循环校验码（CRC码）</strong>） 算法计算一个 16 bit 的值。</li><li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ul><p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p><ul><li><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384&#x2F;9 个。</li><li><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li></ul><p><strong>数据、哈希槽，以及节点三者的映射分布关系</strong></p><img src="/D:/笔记/八股笔记.assets/redis切片集群映射分布关系.jpg" alt="img" style="zoom: 50%;"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.10 –p 6379 cluster addslots 0,1</span><br><span class="line">redis-cli -h 192.168.1.11 –p 6379 cluster addslots 2,3</span><br></pre></td></tr></table></figure><p>然后在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到对应的节点 1 和节点 2 上了。</p><p>需要注意的是，在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</p><h3 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h3><h4 id="脑裂定义"><a href="#脑裂定义" class="headerlink" title="脑裂定义"></a>脑裂定义</h4><p>由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p><p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 <strong>如果主节点的网络突然发生了问题，它与所有的从节点都失联了</strong>，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p><blockquote><p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是<strong>哨兵就会在「从节点」中选举出一个 leeder 作为主节点</strong>，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p><p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p></blockquote><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p><p>在 Redis 的配置文件中有两个参数我们可以设置：</p><ul><li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li><li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li></ul><p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p><p>这两个配置项组合后的要求是，<strong>主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</strong></p><p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p><blockquote><p>再来举个例子。</p><p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。</p><p>同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。</p><p>这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p></blockquote><h2 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h2><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>先说一下对 key 设置过期时间的命令。 设置 key 过期时间的命令一共有 4 个：</p><ul><li><code>expire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期。</li><li><code>pexpire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。</li><li><code>expireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；</li><li><code>pexpireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）</li></ul><h3 id="判定过期"><a href="#判定过期" class="headerlink" title="判定过期"></a>判定过期</h3><p>如果对 key 设置了过期时间，Redis 就会把这个 key 带上过期时间存储到<strong>过期字典</strong>中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p><p>字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。</p><p>查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与系统时间进行对比，如果没有过期就读取。</li></ul><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配合使用。</p><p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p><ul><li>定时删除；</li><li>惰性删除；</li><li>定期删除；</li></ul><h4 id="定时删除策略"><a href="#定时删除策略" class="headerlink" title="定时删除策略"></a>定时删除策略</h4><p>定时删除策略的做法是，<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></p><p><strong>优点</strong>：可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</p><p><strong>缺点</strong>：在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</p><h4 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h4><p>惰性删除策略：<strong>不主动删除过期键，每次访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p><p><strong>优点</strong>：因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</p><p><strong>缺点</strong>：如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</p><h4 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h4><p>定期删除策略：<strong>每隔一段时间「随机」取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p><p><strong>优点</strong>：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</p><p><strong>缺点</strong>：</p><ul><li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li><li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li></ul><h4 id="Redis使用的过期删除策略"><a href="#Redis使用的过期删除策略" class="headerlink" title="Redis使用的过期删除策略"></a>Redis使用的过期删除策略</h4><p>惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p><p>Redis 的惰性删除流程：</p><p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p><ul><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与系统时间进行对比，如果没有过期就读取。</li></ul><p>Redis 的定期删除的流程：</p><ol><li>从过期字典中随机抽取 20 个 key；</li><li>检查这 20 个 key 是否过期，并删除已过期的 key；</li><li>如果本轮检查的已过期 key 的数量，超过 5 个，也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li></ol><p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p><h3 id="持久化时的过期内存处理"><a href="#持久化时的过期内存处理" class="headerlink" title="持久化时的过期内存处理"></a>持久化时的过期内存处理</h3><p>Redis 持久化文件有两种格式：AOF（Append Only File）和 RDB（Redis Database）</p><p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p><ul><li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li><li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li></ul><p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p><ul><li><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li><li>RDB 加载阶段：要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul><li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li><li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li></ul></li></ul><h3 id="主从模式的过期内存处理"><a href="#主从模式的过期内存处理" class="headerlink" title="主从模式的过期内存处理"></a>主从模式的过期内存处理</h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p><p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p><h2 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h2><p>过期删除策略是删除已过期的 key，而当 Redis 的运行内存已经超过设置的最大内存之后，就会使用内存淘汰策略删除符合条件的 key。</p><p> 在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p><p><strong>1、不进行数据淘汰的策略</strong></p><p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：当运行内存超过设置的最大内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p><p><strong>2、进行数据淘汰的策略</strong></p><p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 </p><p><strong>在设置了过期时间的数据中进行淘汰</strong>：</p><ul><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li><li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li><li><strong>volatile-lru</strong>：<strong>淘汰所有设置了过期时间的键值中最久未使用的键值</strong>；</li><li><strong>volatile-lfu</strong>：淘汰所有设置了过期时间的键值中最少使用的键值；</li></ul><p><strong>在所有数据范围内进行淘汰</strong>：</p><ul><li><strong>allkeys-random</strong>：随机淘汰任意键值;</li><li><strong>allkeys-lru</strong>：淘汰所有键值中最久未使用的键值；</li><li><strong>allkeys-lfu</strong>：淘汰所有键值中最少使用的键值。</li></ul><h3 id="LRU和LFU"><a href="#LRU和LFU" class="headerlink" title="LRU和LFU"></a>LRU和LFU</h3><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p><p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，<strong>最新操作的键会被移动到表头</strong>，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p><p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p><ul><li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li><li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li></ul><h4 id="Redis-LRU"><a href="#Redis-LRU" class="headerlink" title="Redis LRU"></a>Redis LRU</h4><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p><p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p><p>Redis 实现的 LRU 算法的优点：</p><ul><li>不用为所有的数据维护一个大链表，节省了空间占用；</li><li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li></ul><p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p><p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p><h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p><h4 id="Redis-LFU"><a href="#Redis-LFU" class="headerlink" title="Redis LFU"></a>Redis LFU</h4><p><strong>最不经常使用</strong>(最少次)算法（Least Frequently Used）</p><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p><p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p><p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。</p><img src="/./res\lru字段.png" alt="img" style="zoom: 50%;"><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存异常（缓存雪崩、缓存击穿、缓存穿透）"><a href="#缓存异常（缓存雪崩、缓存击穿、缓存穿透）" class="headerlink" title="缓存异常（缓存雪崩、缓存击穿、缓存穿透）"></a>缓存异常（缓存雪崩、缓存击穿、缓存穿透）</h3><img src="/./res\061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片" style="zoom:67%;"><h3 id="如何避免缓存雪崩"><a href="#如何避免缓存雪崩" class="headerlink" title="如何避免缓存雪崩"></a>如何避免缓存雪崩</h3><p>缓存雪崩：<strong>大量缓存数据在同一时间过期，如果此时有大量的请求，就都无法在 Redis 中处理，于是全部请求都直接访问数据库，导致数据库的压力骤增，严重的会造成数据库宕机</strong>。</p><p>对于缓存雪崩问题，可以采用两种方案解决。</p><ul><li><p><strong>均匀设置过期时间：</strong> 可以在原有的失效时间基础上增加一个随机值，这样每个缓存的过期时间就不重复了，能够降低缓存集体失效的概率。</p></li><li><p><strong>互斥锁：</strong>处理请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求数据库来构建缓存</strong>，当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p></li><li><p><del><strong>设置缓存不过期：</strong> 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。(<strong>内存淘汰策略</strong>)</del></p><blockquote><p> 实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></blockquote></li></ul><blockquote><p><em>后台更新缓存</em></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p></blockquote><h3 id="如何避免缓存击穿"><a href="#如何避免缓存击穿" class="headerlink" title="如何避免缓存击穿"></a>如何避免缓存击穿</h3><p>数据库中会有一些数据被频繁地访问，称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量请求访问该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>。</p><p>缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩的一个子集。 可以采取下面两种方案：</p><ul><li><strong>互斥锁方案</strong>，保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li><strong>不给热点数据设置过期时间</strong>，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h3 id="如何避免缓存穿透"><a href="#如何避免缓存穿透" class="headerlink" title="如何避免缓存穿透"></a>如何避免缓存穿透</h3><p>缓存穿透就是用户访问的数据<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。如果<strong>有大量这样的请求</strong>，数据库的压力就会骤增。</p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li><strong>非法请求的限制</strong>：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li><li><strong>设置空值或者默认值</strong>：针对发生缓存穿透的数据，可以在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li><li><strong>使用布隆过滤器快速判断数据是否存在</strong>：向数据库写入数据时，使用布隆过滤器做个标记，用户请求可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，保证数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><blockquote><p> 布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul></blockquote><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><h3 id="动态缓存热点数据"><a href="#动态缓存热点数据" class="headerlink" title="动态缓存热点数据"></a>动态缓存热点数据</h3><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而<strong>只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p><p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p><p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p><ul><li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li><li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li><li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li></ul><p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>常见的缓存更新策略共有3种：</p><ul><li>Cache Aside（旁路缓存）策略；</li><li>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略；</li><li>Write Back（写回）策略；</li></ul><p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。</p><h4 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h4><p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。</p><img src="/./res\6e3db3ba2f829ddc14237f5c7c00e7ce.png" alt="img" style="zoom: 50%;"><p><strong>写策略的步骤：</strong></p><ul><li>先更新数据库中的数据，再删除缓存中的数据。</li></ul><p><strong>读策略的步骤：</strong></p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul><p>注意，写策略的步骤的顺序顺序不能倒过来，即<strong>不能先删除缓存再更新数据库</strong>，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。</p><blockquote><p><strong>为什么「先更新数据库再删除缓存」不会有数据不一致的问题？</strong></p><p>继续用「读 + 写」请求的并发的场景来分析。</p><p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p><p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。 从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p></blockquote><p><strong>Cache Aside 策略适合读多写少的场景，不适合写多的场景</strong>，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p><ul><li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li><li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li></ul><h4 id="Read-Write-Through（读穿-写穿）策略"><a href="#Read-Write-Through（读穿-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h4><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p><p><em><strong>1、Read Through 策略</strong></em></p><p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p><p><em><strong>2、Write Through 策略</strong></em></p><p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p><ul><li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li><li>如果缓存中数据不存在，直接更新数据库，然后返回；</li></ul><p>Read Through&#x2F;Write Through 策略的特点是由缓存节点而非应用程序来和数据库打交道，在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都不提供写入数据库和自动加载数据库中的数据的功能。而我们在使用本地缓存的时候可以考虑使用这种策略。</p><h4 id="Write-Back（写回）策略"><a href="#Write-Back（写回）策略" class="headerlink" title="Write Back（写回）策略"></a>Write Back（写回）策略</h4><p>Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p><p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p><p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p><p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p><p><strong>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险</strong>，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p><h2 id="缓存与数据库的一致性"><a href="#缓存与数据库的一致性" class="headerlink" title="缓存与数据库的一致性"></a>缓存与数据库的一致性</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>​当我们更新数据库中的数据时，需要同步Redis中缓存的数据，常用的两种方法是：先更新数据库再删除缓存、先删除缓存再更新数据库，无论是哪种方法在并发情况下都会出现<strong>缓存与数据库的数据不一致问题</strong>，举例如下：</p><ul><li>先更新数据库，再删除缓存：请求1进行更新操作，更新数据库后，还未来得及进行缓存清除，此时请求2查询同一条数据，会查到redis中缓存的旧数据</li><li>先删除缓存，再更新数据库：请求1进行更新操作，执行缓存删除后，还未更新数据库的数据，此时请求2查询同一条数据，由于缓存中没有对应数据，直接查到了数据库中的旧数据，并就其写入redis</li></ul><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h4><p>延迟双删的步骤如下：① 先删除缓存 ② 更新数据库 ③ 延迟一段时间再删除缓存</p><p>延迟时间怎么设置：</p><p>延迟时间应该大于一次读请求的时间，这么做的目的是确保其他的读请求结束，当前写请求可以删除读请求造成的缓存脏数据。</p><h4 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h4><p>​通过订阅binlog，使用消息队列将MySQL的增、删、改操作推送到Redis，Redis再根据binlog中的记录，对Redis进行更新，实现异步更新缓存。通常是采用canal+kafka来实现</p><h1 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h1><h2 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h2><h3 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h3><p>可以把消息队列看作是一个<strong>存放消息的容器</strong>，需要使用消息时，直接从容器中取出消息使用即可。</p><p>消息队列是分布式系统中重要的组件之一。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。</p><p>队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p><h3 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h3><p>消息队列能为我们的系统带来下面三点好处：</p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰&#x2F;限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol><h4 id="通过异步处理提高系统性能（减少响应所需时间）"><a href="#通过异步处理提高系统性能（减少响应所需时间）" class="headerlink" title="通过异步处理提高系统性能（减少响应所需时间）"></a>通过异步处理提高系统性能（减少响应所需时间）</h4><img src="/./res\Asynchronous-message-queue.png" alt="通过异步处理提高系统性能" style="zoom:67%;"><p>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。</p><p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>。</p><blockquote><p>比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p></blockquote><h4 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h4><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p><p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p><img src="/./res\削峰-消息队列.png" alt="削峰" style="zoom: 25%;"><h4 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h4><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p><img src="/./res\消息队列-解耦.png" alt="解耦" style="zoom:67%;"><p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p><p><strong>消息队列使用&#x3D;&#x3D;发布-订阅模式&#x3D;&#x3D;工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><h3 id="消息队列的问题"><a href="#消息队列的问题" class="headerlink" title="消息队列的问题"></a>消息队列的问题</h3><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后就需要考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h2 id="消息队列规范"><a href="#消息队列规范" class="headerlink" title="消息队列规范"></a>消息队列规范</h2><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>JMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p><strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p><h4 id="JMS消息模型"><a href="#JMS消息模型" class="headerlink" title="JMS消息模型"></a>JMS消息模型</h4><p><strong>① 点到点（P2P）模型</strong></p><img src="/./res\队列模型23.png" alt="队列模型" style="zoom:67%;"><p>使用<strong>队列（Queue）作为消息通信载体；满足生产者与消费者模式</strong>，支持多个消费者，但一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p><p><strong>② 发布&#x2F;订阅（Pub&#x2F;Sub）模型</strong></p><img src="/./res\发布订阅模型.png" alt="发布订阅模型" style="zoom:67%;"><p>发布订阅模型（Pub&#x2F;Sub） 使用 <strong>Topic 作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过 topic 传递给所有的订阅者，</strong>在一条消息广播之后才订阅的用户是收不到该条消息的。</p><h4 id="JMS消息正文模式"><a href="#JMS消息正文模式" class="headerlink" title="JMS消息正文模式"></a>JMS消息正文模式</h4><p>JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><ul><li>StreamMessage – Java 原始值的数据流</li><li>MapMessage–一套名称-值对</li><li>TextMessage–一个字符串对象</li><li>ObjectMessage–一个序列化的 Java 对象</li><li>BytesMessage–一个字节的数据流</li></ul><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。</p><p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th align="center">对比方向</th><th align="left">JMS</th><th align="left">AMQP</th></tr></thead><tbody><tr><td align="center">定义</td><td align="left">Java API</td><td align="left">协议</td></tr><tr><td align="center">跨语言</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="center">跨平台</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="center">支持消息类型</td><td align="left">提供两种消息模型：①Peer-2-Peer;②Pub&#x2F;sub</td><td align="left">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub&#x2F;sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td align="center">支持消息类型</td><td align="left">支持多种消息类型 ，我们在上面提到过</td><td align="left">byte[]（二进制）</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可<strong>序列化</strong>后发送）。</li><li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题&#x2F;订阅 方式两种。</li></ul><h2 id="常见消息队列对比"><a href="#常见消息队列对比" class="headerlink" title="常见消息队列对比"></a>常见消息队列对比</h2><p><img src="/.%5Cres%5Ccb7df4942684886ee759dbb10d4bd760.png" alt="img"></p><table><thead><tr><th>对比 方向</th><th>概要</th></tr></thead><tbody><tr><td>吞吐量</td><td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td></tr><tr><td>可用性</td><td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>时效性</td><td>RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td></tr><tr><td>功能支持</td><td>除了 Kafka，其他三个功能都较为完备。 <strong>Kafka 功能较为简单，主要支持简单的 MQ 功能</strong>，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td>消息丢失</td><td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的</li><li>Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有<strong>可能消息重复消费</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><h2 id="保证消息的消费顺序"><a href="#保证消息的消费顺序" class="headerlink" title="保证消息的消费顺序"></a>保证消息的消费顺序</h2><p>分区中的消息是有序的，不同分区之间的消息无法保证其有序性，因此要想严格保证消息的消费顺序，需要将消息放入同一个分区中</p><ul><li>一个topic一个partition，不推荐，背离了kafka设计的初衷</li><li>**发送消息的时候将消息的key设为相同(推荐)**。当producer发送数据的时候如果没有指定分区，则会根据key % (partition的数量)的方式来确定消息的分区，相同的key会被分配到相同的分区。</li></ul><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p><strong>LEO</strong>：每个副本中Log文件的最后一个offset</p><p><strong>HW：</strong>所有副本中最小的LEO</p><p><strong>ISR</strong>（In-Sync Replicas）：能够和 leader 保持同步的 follower + leader本身 组成的集合。</p><ul><li><p><strong>follower故障</strong></p><p>follower 发生故障后会被临时踢出 ISR（动态的同步副本集合 ），待该 follower 恢复后，follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 <strong>follower</strong> <strong>的</strong> <strong>LEO</strong> <strong>大于等于该</strong> <strong>Partition</strong> <strong>的</strong> <strong>HW</strong>，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</p></li><li><p><strong>leader故障</strong></p><p>leader 发生故障之后，会从 ISR 中选出一个新的 leader之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。</p></li></ul><h2 id="消息队列可能的问题"><a href="#消息队列可能的问题" class="headerlink" title="消息队列可能的问题"></a>消息队列可能的问题</h2><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p><strong>发生场景</strong></p><ul><li>topic 特性使得不在线的消费者上线后收不到之前的消息了，如果一段时间消费者都不在线，那消息就始终处于未被处理的状态。</li><li>服务器异常重启，导致内存中的数据丢失</li><li>消息设置了失效时间，过了时间就进入死信队列了</li><li>消费者自动回复 ack，但是 ack 之后处理消息的过程中出现故障或异常，导致消息被消费者接收单未处理</li></ul><p><strong>解决方法</strong></p><ul><li>可追溯消息，默认 topic 数据是不进行持久化的，可以设置可追溯策略，最近多少条、最近多长时间、最近多少字节。</li><li>做高可用，保证消息不因节点故障或网络故障丢失</li><li>死信队列，对死信队列的数据进行重新推送或重新消费</li><li>ack，消息被消费处理完成后再回复broker可以去清除该消息了</li><li>消息重投、重试机制</li><li>记录日志，将处理异常的或者可能丢失的筛选出来重新处理</li></ul><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p><strong>发生场景</strong></p><p>网络环境差等因素导致重复发送多条相同业务的消息、自动重试等，导致业务数据错乱。</p><p><strong>解决办法</strong></p><p>设计幂等，使得消息重试多少次得到的结果都是一样的。</p><h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><p><strong>发生场景</strong></p><ul><li>分组或者独占消费者（exclusive和selector），即设定消息只能有特定的消费者接收消费，或者消费者设定了只接收特定属性值的消息。</li><li>消费者的消费能力远小于生产者的生产能力（也许是存在短时间消息生产高峰或者消费者节点出现故障）</li></ul><p><strong>问题表现</strong></p><ul><li>内存占用越来越多，内存可能溢出；</li><li>如果设置了消息持久化，磁盘空间占用越来越大；</li><li>主要还是影响业务响应时间；</li><li>内存溢出或者磁盘占满还可能导致消息丢失。</li></ul><p><strong>解决办法</strong></p><ul><li>分组或独占消费者：定期检查发现追踪。</li><li>消费者能力不足：增加节点，多线程提升消费效率，优化IO模型与IO传递速度。</li><li>broker容量有限：增加容量，JVM参数配置，是否有不自动清除的垃圾数据、死信未处理、做高可用集群。</li><li>生产者短时间产生大量消息：检查产生的数据是否正常、程序是否有问题；事前做好压测和测试，预留处理能力。</li></ul><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ol><li>命名空间的方式有两种：一种使用全限定名，一种是段名称（全局唯一）</li><li>命名空间实现的是java代码与数据库语言的映射，而MyBatis实现的是JVM和数据库的连接</li><li>实现 SQL 和 java 代码映射的方式有两种，一种是xml映射，另外一种是直接在接口上添加注解</li><li>Mybatis 和 Springboot 搭配使用时，MyBatis-Spring-Boot-Starter已经默认处理：<ol><li>自动探测存在的datasource</li><li>自动创建一个以datasource为源的SqlSessionFactory实例</li><li>自动创建并注册一个SqlSessionTemplate实例</li><li>自动扫描Mapper（@mapper或者@Repository），将他们注册到Spring的context中，自动注入成bean</li></ol></li><li>使用MyBatis-Spring-Boot-Starter可以手动指定扫描（@MappperScan）</li><li>如果在Springboot中至少有两个SqlSessionFactoryBean，则需要手动指定（@Bean）</li><li>MyBatis实现分页两种方式：<ol><li>逻辑分页 （先一次性拿到所有的结果，然后分页获取，不适合较大的数据量）<ol><li>RowBounds</li></ol></li><li>物理分页<ol><li>SQL 语句，直接在select语句实现limit关键字</li><li>拦截器（Inteceptor），实现动态地拼接select</li></ol></li></ol></li><li>Mybatis缓存：MyBatis总共有两级缓存，一般先访问二级缓存再访问一级缓存<ol><li>一级缓存：一级缓存是sqlsession的本地缓存，它存在的时间受到当前的sqlsession影响</li><li>二级缓存：二级缓存是各个sqlsession之间的共享缓存，是一个全局的缓存<img src="/.%5Cres%5C1681108101364-3dfe0ee9-3cc3-403e-adf6-201938faa631.png" alt="image.png"></li></ol></li></ol><h2 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h2><ol><li>封装常用操作</li><li>提供常用的CRUD</li><li>提供高级功能，分页，逻辑删除</li><li>丰富插件管理</li><li>通过配置文件和注解配置简洁</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架 </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2024/10/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2024/10/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><code>注：下列排序默认数组均有很多元素（不考虑空数组等特例），升序排列</code><br></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>思路：<font color="red"><b> 两两相邻元素比较，较大往后排</b></font><br><br>场景：入门，学习排序思想</p></blockquote><blockquote><p>时间复杂度:<font color="#FF7D00"><b> 最坏和平均情况为O(n²)</b></font>，<font color="green"><b>最好情况为O(n)</b></font><br><br>稳定性：<font color="green"><b>稳定，相等元素的相对位置在排序后不会改变</b></font></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaoPaoSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">maoPaoSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j-<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span>arr[j-<span class="number">1</span>];</span><br><span class="line">                    arr[j-<span class="number">1</span>]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>思路：<font color="red"><b>从未排序的序列中找出最小的和指定顺序位置的元素互换，依次进行</b></font><br><br>场景：数据量小，对交换操作开销较大的情况</p></blockquote><blockquote><p>时间复杂度:<font color="#FF7D00"><b> 最坏和平均情况为O(n²)</b></font>，<font color="#FF7D00"><b>最好情况为O(n²)</b></font><br><br>稳定性：<font color="green"><b>不稳定，相等元素的相对位置在排序后可能改变</b></font></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;min)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[i];</span><br><span class="line">                    arr[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>思路：<font color="red"><b>外循环遍历元素，将每次遍历到的元素插入到已排序的序列的指定位置，内循环负责后移元素和插值。</b></font><br><br>场景：数据量小，几乎已排好序（待插入元素离目标位置很近）</p></blockquote><blockquote><p>时间复杂度:<font color="#FF7D00"><b> 最坏和平均情况为O(n²)</b></font>，<font color="#FF7D00"><b>最好情况为O(n)</b></font><br><br>稳定性：<font color="green"><b>稳定，相等元素的相对位置在排序后不会改变</b></font></p></blockquote><blockquote><p>难点：内循环元素后移和新元素插入点的下标</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//遍历新元素前面已排序的序列</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;key)&#123;<span class="comment">//后移已排序的元素</span></span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>]=key;<span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><blockquote><p>思路：<font color="red"><b>根据步长划分序列比较插入，依次减半步长再比较，直到步长为1，比较交换相邻元素即可。</b></font><br><br>场景：插入排序改进版</p></blockquote><blockquote><p>时间复杂度:<font color="#FF7D00"><b> 最坏O(n²)和平均情况为O(nlog²n)</b></font>，<font color="green"><b>最好情况为O(nlogn)</b></font><br><br>稳定性：<font color="#FF7D00"><b>不稳定，相等元素的相对位置在排序后会改变</b></font></p></blockquote><blockquote><p>难点：比较的是每隔一个步长的元素，下标对应<br><img src="https://pic.code-nav.cn/course_picture/1626574509983178753/P3ofXPvkATKEIYGZ.webp" alt="image.png">)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;<span class="comment">//外循环每次步长减半</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> d; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - d;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; key) &#123;<span class="comment">//每组步长下的序列为一组进行比较插入</span></span><br><span class="line">                    nums[j + d] = nums[j];</span><br><span class="line">                    j -= d;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + d] = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><blockquote><p>思路：<font color="red"><b>分治、递归。将序列两两向下分开成子序列，直到分成单个元素（认为已排序），两两再比较元素进行向上合并。</b></font><br><br>场景：需要稳定排序，数据量大</p></blockquote><blockquote><p>时间复杂度:<font color="green"><b>最差、平均、最好情况均为O(nlogn)</b></font><br><br>稳定性：<font color="green"><b>稳定，相等元素的相对位置在排序后不会改变</b></font></p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c9517428afa0244546c0e08a8e7c3fe.gif" alt="归并排序"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; nums[l] &#125;;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] leftArr = mergeSort(nums, l, mid); <span class="comment">//左有序数组</span></span><br><span class="line">        <span class="type">int</span>[] rightArr = mergeSort(nums, mid + <span class="number">1</span>, r); <span class="comment">//右有序数组</span></span><br><span class="line">        <span class="type">int</span>[] newNum = <span class="keyword">new</span> <span class="title class_">int</span>[leftArr.length + rightArr.length]; <span class="comment">//新有序数组</span></span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) &#123;<span class="comment">//那边小，则存那边的，存完后移一位</span></span><br><span class="line">            newNum[m++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; leftArr.length)&#123;<span class="comment">//左数组有多余</span></span><br><span class="line">            newNum[m++] = leftArr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; rightArr.length)&#123;<span class="comment">//右数字有多余</span></span><br><span class="line">            newNum[m++] = rightArr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span> &#125;;</span><br><span class="line">        <span class="type">int</span>[] newNums = mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : newNums) &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote><p>思路：<font color="red"><b>分治、递归。通过一次排序将待排序列分割成独立的两部分，一部分所有元素均小于基准，另一部分所有元素均大于基准，然后递归地对这两部分分别进行快速排序。</b></font><br><br>场景：需要快速排序，数据量大，Arrsys.sort库函数底层</p></blockquote><blockquote><p>时间复杂度:<font color="#FF7D00"><b>最差O(n²)</b></font>，<font color="green"><b>平均、最好情况均为O(nlogn)</b></font><br><br>稳定性：<font color="#FF7D00"><b>不稳定，相等元素的相对位置在排序后会改变</b></font></p></blockquote><blockquote><p>难点：根据基准元素将数组划分两个部分的过程，一部分小于，另一部分大于</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 获取分区点位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, l, r);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">            quickSort(arr, l, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最左侧元素作为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l+<span class="number">1</span>; j &lt;= r; j++) &#123;</span><br><span class="line">            <span class="comment">// 将小于基准的元素移到左侧</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 交换元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将基准放到指定位置</span></span><br><span class="line">        arr[l] = arr[i - <span class="number">1</span>];</span><br><span class="line">        arr[i - <span class="number">1</span>] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><blockquote><p>思路：<font color="red"><b>利用数组形式的堆结构，先将待排序的序列构造成一个最大堆（或最小堆），这样就能保证堆顶元素是序列中的最大值（或最小值）。之后将堆顶元素与堆的最后一个元素交换，减少堆的大小并重新构建堆，如此反复，直到堆的大小减小到1，排序完成。</b></font><br><br>场景：大规模数据，无需额外的空间</p></blockquote><blockquote><p>时间复杂度:<font color="green"><b>最差、平均、最好情况均为O(nlogn)</b></font><br><br>稳定性：<font color="#FF7D00"><b>不稳定</b></font></p></blockquote><p>堆（Heap）是一种特殊的完全二叉树结构，它的两个重要特性：</p><p>堆是一个完全二叉树，除了最底层外，其他层的节点都是满的，最底层的节点从左到右填充。<br>在最大堆中，每个节点的值都大于或等于其子节点的值；在最小堆中，每个节点的值都小于或等于其子节点的值。<br>堆的数组表示：</p><p>虽然堆是一种树结构，但是也可以用数组高效地表示，这是堆的一个重要特性。</p><p>对于数组中索引为 i 的节点：</p><p>其左子节点的索引为 2*i + 1</p><p>其右子节点的索引为 2*i + 2<br><img src="https://i-blog.csdnimg.cn/direct/a94c12bdf4fe4e03bfdf54a9a5aca3fe.gif#pic_center" alt="堆排序"></p><blockquote><p>构造大根堆的过程，len&#x2F;2-1是最后一个非叶子节点的索引，adjustHeap(arr, i, len)：调整以索引 i 为根节点的子树<br>构造大根堆循环的含义：从最后一个非叶子节点开始向上构造。当前父节点的左孩子开始，不断向下比较和调整，确保以当前父节点为根的子堆重新满足堆的规则。它会一直比较并调整，直到找到父节点在堆中的合适位置，或者到达堆的最底层（没有孩子节点）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 构建大根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出堆顶元素，放到已排序的序列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">//当前父节点 i 的左孩子在数组中的索引位置。每次循环，j 都会更新为下一个左孩子的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; j &lt; len; j = j * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; len &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                j++;<span class="comment">//判断是否有右孩子，有的话选最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                i = j;<span class="comment">//孩子换到父节点，父节点下移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//原来的值赋给调整过来的元素，没调整则不变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><blockquote><p>思路：<font color="red"><b>先找到最小值和最大值确定好数据范围，然后统计每个元素出现的次数放到范围索引数组，然后累加计数得到</b></font><br><br>场景：数据范围较小、重复计数较多的场景</p></blockquote><blockquote><p>时间复杂度:<font color="green"><b>最差、平均、最好情况均为O(n+k),k为数据范围</b></font><br><br>稳定性：<font color="green"><b>稳定</b></font></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>],min=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//找到最值</span></span><br><span class="line">            max = nums[i]&gt;max ?nums[i]:max;</span><br><span class="line">            min =nums[i]&lt;min ?nums[i]:min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> max-min+<span class="number">1</span>;<span class="comment">//确定数据范围</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            count[nums[i]-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;i&lt; len;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]==<span class="number">0</span>)&#123;<span class="comment">//当前索引没出现过，跳到下一个</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当前索引出现过几次就放到新数组中几次</span></span><br><span class="line">                <span class="keyword">while</span>(count[i]--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    arr[j++]=i+min;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//赋给原数组</span></span><br><span class="line">            nums[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注：Arras.copyOf得到的是一个新对象</code></p><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><blockquote><p>思路：<font color="red"><b>将数据分到不同范围的桶里，分别排序</b></font><br><br>场景：计数排序扩展版本，适合数据分布均匀的场景</p></blockquote><blockquote><p>时间复杂度:<font color="#FF7D00"><b>平均 O(n + n²&#x2F;k + k) | 最差 O(n²)</b></font>，<font color="green"><b>最佳 O(n)</b></font><br><br>稳定性：<font color="green"><b>稳定</b></font></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">double</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定桶的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建桶</span></span><br><span class="line">    List&lt;List&lt;Double&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出数组中的最大值和最小值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>], min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算每个桶的范围大小</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">range</span> <span class="operator">=</span> (max - min) / bucketCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素分配到对应的桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> item : arr) &#123;</span><br><span class="line">        <span class="comment">// 计算元素应该放入哪个桶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> (<span class="type">int</span>)((item - min) / range);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理最大值的边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (bucketIndex == bucketCount) &#123;</span><br><span class="line">            bucketIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buckets.get(bucketIndex).add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对每个桶中的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;Double&gt; bucket : buckets) &#123;</span><br><span class="line">        Collections.sort(bucket);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将桶中排序好的元素放回原数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Double&gt; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> item : bucket) &#123;</span><br><span class="line">            arr[index++] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><blockquote><p>思路：<font color="red"><b>按位数来排，从低到高</b></font><br><br>场景：整数或定长字符串</p></blockquote><blockquote><p>时间复杂度:<font color="green"><b>最差、平均、最好情况均为O(n*k),k为最大整数位数</b></font><br><br>稳定性：<font color="green"><b>稳定</b></font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie、Session以及登录鉴权</title>
      <link href="/2024/09/03/Cookie%E3%80%81Session%E3%80%81Token/"/>
      <url>/2024/09/03/Cookie%E3%80%81Session%E3%80%81Token/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="HTTP协议（应用层）无状态"><a href="#HTTP协议（应用层）无状态" class="headerlink" title="HTTP协议（应用层）无状态"></a>HTTP协议（应用层）无状态</h1><p>服务器不会记住客户端的任何请求历史，每次请求都是独立的，彼此之间没有关联。</p><ul><li>cookie、session和token机制是用来解决此问题的会话保持机制。</li><li>HTTP1.1 持久连接是一个TCP连接可以用来发送多个HTTP请求和响应，减少了创建和关闭连接的开销，这里也是无状态。<blockquote><p>http是传输协议，session id是传输的内容。这两个东西好比一端说话告诉另一端，http是传输介质好比空气，session id好比说的话，听到话的人无法通过空气来判断你是谁，但是可以通过你说的话来判断你是谁</p></blockquote></li></ul><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><ul><li>存储在<code>客户端</code>，但容易泄露敏感信息</li><li>应用：网页主题设置<br><img src="https://sns-webpic-qc.xhscdn.com/202505111653/8df39dceca7595968d339106e28d0733/spectrum/1040g0k031g0js501ni005pf9jhvh9d1mfrlgvt8!nd_dft_wgth_webp_3" alt="cookie"></li></ul><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><ul><li>存储在<code>服务端</code>，但占用服务器空间，<code>单体服务</code></li><li>应用：电商平台购物车信息</li><li>一般和cookie共同使用，如果浏览器禁用cookie功能，还有URL重写的方法，将sessionId放在url中<br><img src="https://sns-webpic-qc.xhscdn.com/202505111653/5fbb7fedc3351d402c2f30a09797edcc/spectrum/1040g34o31g0js6gjgc0g5pf9jhvh9d1moj3ged8!nd_dft_wgth_webp_3" alt="session"></li></ul><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><ul><li>包含用户身份信息和权限，经过加密或签名得到的字符串。</li><li>应用：验证身份<br><img src="https://sns-webpic-qc.xhscdn.com/202505111706/ad59d03d368b506a3d168bcaedd3b044/spectrum/1040g0k031g0js7vene005pf9jhvh9d1m4os0qfg!nd_dft_wgth_webp_3" alt="token"><blockquote><p>客户端（如Web应用或移动应用）接收到Token后，通常会将其存储在本地存储、sessionStorage或cookie中，以便在后续请求中使用。<br>在需要访问受保护资源的情况下，客户端会将Token附加到HTTP请求的Authorization头中</p></blockquote></li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><code>一种基于JSON的Token实现方式</code></p><blockquote><p>简单的字符串token容易被盗用、服务端也需要存储，每次请求需要查询；JWT签名部分确保了其完整性，如果攻击者篡改了 JWT 的内容，服务器在验证签名时会发现签名不匹配，从而拒绝该 JWT，使用对称加密算法的 JWT 可以直接通过密钥验证其有效性，无需查询数据库。</p></blockquote><p><img src="https://sns-webpic-qc.xhscdn.com/202505121153/d75b3777fbab9eb8e4f9a68f778a65d3/spectrum/1040g0k030sgk8vkijm004a50mt5fm5985637n50!nd_dft_wgth_webp_3" alt="JWT"></p><blockquote><p>组成</p></blockquote><ul><li>第一部分是头部分，一个是类型，一个是算法的名称</li><li>第二部分是载荷，这里存储的就是有效信息的地方</li><li>第三部分是签名<br><img src="https://sns-webpic-qc.xhscdn.com/202505111706/3373fc52ddb5cc11caa3a8e8835a93e6/spectrum/1040g0k031g0js9a37i005pf9jhvh9d1m6t4n2h0!nd_dft_wgth_webp_3" alt="JWT"><blockquote><p>Springboot实现，<a href="https://blog.csdn.net/m0_73641772/article/details/144253824?ops_request_misc=%257B%2522request%255Fid%2522%253A%252269280c2b0c04d14e467a7276ea95aeba%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=69280c2b0c04d14e467a7276ea95aeba&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-144253824-null-null.142%5Ev102%5Epc_search_result_base1&utm_term=jwt%E5%AE%9E%E7%8E%B0token%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81&spm=1018.2226.3001.4187">详细见此博客</a></p></blockquote></li><li>JWT令牌生成<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line">    <span class="comment">//定义密钥(也可以放在配置springboot配置文件中或服务器环境变量中)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHARK</span> <span class="operator">=</span> <span class="string">&quot;abcdefghigklmnopqrstuvwxyz123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">expire</span> <span class="operator">=</span> <span class="number">3600</span>;  <span class="comment">//设置过期时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(now.getTime() + <span class="number">1000</span> * expire);</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;stuId&quot;</span>, String.valueOf(user.getStuId()));</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, user.getName());</span><br><span class="line">        map.put(<span class="string">&quot;permission&quot;</span>, String.valueOf(user.getPermission()));</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject = objectMapper.writeValueAsString(map);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setSubject(subject)</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .setExpiration(expiration)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, SHARK)  <span class="comment">//采取SHA512加密算法</span></span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析token</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">getClaimsVyToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(SHARK)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>拦截器验证<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getMethod().equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || !token.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> objectMapper.writeValueAsString(ApiResponse.error(<span class="number">403</span>, <span class="string">&quot;令牌失效！&quot;</span>));</span><br><span class="line">            response.getWriter().write(jsonResponse);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        token = token.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsVyToken(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;claims = &quot;</span> + claims);</span><br><span class="line">            request.setAttribute(<span class="string">&quot;user&quot;</span>, claims.getSubject());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="单点登录SSO"><a href="#单点登录SSO" class="headerlink" title="单点登录SSO"></a>单点登录SSO</h2><p><img src="https://sns-webpic-qc.xhscdn.com/202505111706/3d549ec7f0e9e6d1bb5fe984047237bc/spectrum/1040g34o31g0jsaqfni0g5pf9jhvh9d1mrt2nbmg!nd_dft_wlteh_webp_3" alt="SSO"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 登录鉴权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2024/09/02/HTTP/"/>
      <url>/2024/09/02/HTTP/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h1><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则——<font color="red"><strong>协议（protocol）</strong></font>。<br><img src="https://i-blog.csdnimg.cn/direct/d4bc3ef1b69c4c059d0f4b75379e0725.png#pic_center" alt="在这里插入图片描述"></p><p><font color="red"><strong>像这样把与互联网相关联的协议族集合起来总称为 TCP&#x2F;IP（protocol）</strong></font>。也有说法认为，TCP&#x2F;IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP&#x2F;IP 是在 IP 协议的通信过程中，使用到的协议族的统称。<br>需要指出的是，TCP&#x2F;IP协议中应用层决定了向用户提供应用服务时通信的活动。在该层TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类<em>本文将总结的HTTP 协议（HyperText Transfer Protocol，超文本传输协议 ）也处于该层。</em></p><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><blockquote><p>URL（Uniform Resource Locator，统一资源定位符），它是<font color="red"><strong>用于访问互联网上资源的地址</strong></font>，常用于访问网页。</p></blockquote><p> <font color=" #FF00FF "><b> 常见格式：</b></font><code>protocol : // hostname[:port] / path / [;parameters][?query][#fragment]</code><br> <table><tr><td bgcolor="pink"><br>组成部分：协议，域名，端口，虚拟目录，文件名，查询字符串，片段标识符</td></tr></table></p><ul><li>协议：在Internet中可以使用多种协议，如HTTP，HTTPS，FTP等等，在协议后后面的“&#x2F;&#x2F;”为分隔符，用于分隔协议和域名。访问 mysql 时的协议类型为<code> jdbc:mysql</code>。省略默认http。</li><li>域名部分域名是访问网站的识别字符。一个URL中，也可以使用IP地址作为域名使用。<blockquote><p><strong>扩展1——域名等级：</strong><br>顶级域名又称一级域名，由<code>域名字符 + 域名后缀</code>组成，如<code>csdn.net</code>；<br>二级域名是由<code>字符. + 顶级域名</code>组成，如<code>blog.csdn.net</code><br>由于使用习惯，大家一般将 www. 开头的域名称之为顶级域名，并将不带 www. 的顶级域名和带 www. 的域名（二级域名）不加区别的直接使用，如<code>csdn.net</code>和<code>www.csdn.net</code>一样。</p></blockquote></li></ul><blockquote><p><strong>扩展2——常见的域名后缀：</strong><br>.<code>com </code>代表商业、<code>.net </code>代表网络、<code>.org</code> 代表组织和团体、<code>.gov</code> 代表政府部门、<code>.top </code>代表顶级机构等。<br>中国常见的域名就是<code>.com</code> 和 <code>.cn</code>，而 <code>.com</code> 是全球接受程度最高的域名类型，<code>.cn</code> 主要用于国内业务，但并不会影响全球网民访问网站。</p></blockquote><blockquote><p><strong>扩展3——子域名：</strong><br>子域名是主域名的下一级域名，通常是大型公司为了满足不同产品或业务需求在主域名基础上发展而来。子域名一般会根据不同用途在主域名前面加上不同的前缀构成。</p><ul><li>CSDN主页——<code>www.csdn.net</code></li><li>CSDN博客浏览页——<code>blog.csdn.net</code></li><li>CSDN博客编辑页——<code>editor.csdn.net</code></li></ul></blockquote><ul><li>端口用于标识在一台计算机上运行的不同程序。每个网络程序，都对应一个或多个特定的端口号。跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。<strong>端口不是一个URL必须的部分</strong>，如果省略端口部分，将采用协议的默认端口，例如HTTP程序的默认端口号为80，HTTPS程序的默认端口号为443。</li><li>虚拟目录：指定服务器上资源的具体位置。从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止是虚拟目录部分。</li><li>文件名：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。</li><li>查询字符串用于向服务器发送额外的信息或参数，这些参数可以用于数据库查询、用户身份验证、状态信息传递等。服务器可以根据这些参数来处理请求，并返回相应的结果。。从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。参数允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li><li>片段标识符：锚点用于指向资源内部的特定部分，主要用于页面内跳转。从“#”开始到最后，都是锚部分。锚也不是一个URL必须的部分。</li></ul><h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>关键词：<code>域名解析</code> 、<code>IP地址</code></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如<code>www.hackr.jp</code>。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了，因为计算机更擅长处理一长串数字。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了解决上述的问题，DNS（Domain Name System） 服务应运而生，它是和 HTTP 协议一样位于应用层的协议。 <font color=" #FF00FF "><b> DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</b></font><br><img src="https://i-blog.csdnimg.cn/direct/b59eb10460134d0094db125d57bfb89a.png#pic_center" alt="在这里插入图片描述"></p><h2 id="域名解析IP"><a href="#域名解析IP" class="headerlink" title="域名解析IP"></a>域名解析IP</h2><p>本地中以前解析过，有缓存，直接返回，没有的话，有两种解析的方式：</p><ul><li>递归解析——当用户向本地DNS服务器发起域名解析请求时，如果本地DNS服务器没有缓存该域名的IP地址，它会代表用户向根域名服务器、顶级域名服务器、权威域名服务器等逐级查询，直到获得最终的IP地址，然后将结果返回给用户（<strong>本地DNS服务器负责完成整个解析过程，用户只需等待结果</strong>）</li><li>迭代解析——当用户向本地DNS服务器发起域名解析请求时，如果本地DNS服务器没有缓存该域名的IP地址，它会向根域名服务器发起查询。根域名服务器会返回一个指向顶级域名服务器的地址，本地DNS服务器再向顶级域名服务器查询，依此类推，直到获得最终的IP地址（<strong>本地DNS服务器只负责部分解析过程，用户或应用程序需要多次与不同的DNS服务器交互，逐级向下</strong>）</li></ul><h2 id="HTTP协议与各协议之间的关系"><a href="#HTTP协议与各协议之间的关系" class="headerlink" title="HTTP协议与各协议之间的关系"></a><strong>HTTP协议与各协议之间的关系</strong></h2><p>HTTP是构建在TCP&#x2F;IP协议族之上的应用层协议。HTTP作为应用层协议，依赖于下层的传输层协议TCP来确保数据的可靠传输，同时也依赖于网络层的IP协议来处理数据包的寻址和路由。</p><ul><li><font color=" #FF7D00 "><b> IP协议</b></font> 为HTTP提供了必要的<font color=" #FF7D00 "><b> 网络层支持</b></font> ，使得数据能够在复杂的网络环境中从源点传输到目的地。</li><li><font color=" #FF7D00 "><b>TCP协议</b></font> 在传输层提供了数据的顺序传输、数据完整性和错误检测功能，这对于HTTP<font color=" #FF7D00 "><b>传输的数据可靠性</b></font> 尤为重要。</li><li><font color=" #FF7D00 "><b>DNS协议</b></font> 在HTTP通信中扮演着 <font color=" #FF7D00 "><b>域名解析</b></font>的角色，它将用户友好的域名转换为IP地址，使得用户无需记忆复杂的IP地址就能访问互联网资源。</li></ul><h1 id="HTTP版本介绍"><a href="#HTTP版本介绍" class="headerlink" title="HTTP版本介绍"></a>HTTP版本介绍</h1><blockquote><p>每个版本的HTTP都在性能、安全性和功能上有所改进，以适应互联网的发展和用户需求的变化。随着技术的进步，HTTP协议也在不断地更新和优化。</p><ul><li><strong>HTTP&#x2F;0.9（1991年）</strong><br>这是最早的HTTP版本，被称为“只有一个方法的协议”。<br>它只支持GET请求，没有状态码、没有HTTP头，只用于请求和接收HTML页面。</li><li><strong>HTTP&#x2F;1.0（1996年）</strong><br>引入了状态码、HTTP头和多种HTTP方法（如POST和HEAD）。<br>支持持续连接（Connection: keep-alive），允许在一个TCP连接上发送多个请求和响应，减少了建立和关闭连接的开销。<br>没有官方规范，直到1999年才由RFC 1945正式标准化。</li><li><strong>HTTP&#x2F;1.1（1999年）</strong><br>引入了持久连接（默认开启Connection: keep-alive，简单地说，<font color=" #FF7D00 "><b> <em>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭， 如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache、GlassFish）中设定这个时间</em></b></font>，支持管道化请求（Pipelining），允许在等待一个响应的同时发送多个请求。<br>引入了更多的缓存控制机制。<br>支持分块传输编码（chunked transfer encoding），允许服务器在知道整个响应大小之前就开始发送数据。<br>引入了虚拟主机的概念，允许一个IP地址托管多个域名。<br>由RFC 2616标准化，后来被RFC 7230-7235系列文档更新。</li><li><strong>HTTP&#x2F;2（2015年）</strong><br><font color=" #FF7D00 "><b> 引入了二进制协议，提高了解析效率。<br>支持头部压缩（HPACK），减少了请求和响应头部的大小。</b></font><br>引入了多路复用（Multiplexing），允许在同一个连接上并行交错发送多个请求和响应，解决了HTTP&#x2F;1.x中的队头阻塞问题。<br>支持服务器推送（Server Push），允许服务器主动向客户端发送资源。<br>由RFC 7540标准化。</li><li><strong>HTTP&#x2F;3（2019年）</strong><br><font color=" #FF7D00 "><b> 基于QUIC协议，运行在UDP之上，而不是TCP。</b></font><br>提供了更好的拥塞控制和连接迁移特性。<br>支持0-RTT（零往返时间）连接，减少了连接建立的时间。<br>支持前向保密（Forward Secrecy），增强了安全性。<br>由RFC 9114标准化。</li></ul></blockquote><h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><blockquote><p>HTTP报文是<font color="red"><strong>面向文本</strong></font>的，因此<font color="red"><strong>报文中的每一个字段都是一些ASCII码串</strong></font>，各个字段的长度是不确定的。<br>HTTP有两类报文：请求报文和响应报文。</p></blockquote><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><table><tr><td bgcolor="pink"> 组成部分：请求行、请求头部、空行、请求体</td></tr></table><p><img src="https://i-blog.csdnimg.cn/direct/9840063935d24b3ab77691dcb28dee2c.png#pic_center" alt="在这里插入图片描述"></p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行由<font color=" #FF7D00 "><b> 请求方法</b></font>字段、<font color=" #FF7D00 "><b> URL</b></font>字段和<font color=" #FF7D00 "><b> HTTP协议版本</b></font>字段3个字段组成，它们用空格分隔。</p><h3 id="常见的请求方法"><a href="#常见的请求方法" class="headerlink" title="常见的请求方法"></a>常见的请求方法</h3><blockquote><table><thead><tr><th>请求方法</th><th>用法</th><th>适用HTTP版本号</th></tr></thead><tbody><tr><td><font color="blue"><strong>GET</strong></font></td><td><font color="blue"><strong>请求读取由URL所标识的信息，参数是包含在URL中</strong></font></td><td>全部</td></tr><tr><td><font color="blue"><strong>POST</strong></font></td><td><font color="blue"><strong>给服务器发送数据(登录界面），参数是包含在请求体中</strong></font></td><td>全部</td></tr><tr><td>HEAD</td><td>获得报文首部</td><td>1.0及以后版本</td></tr><tr><td>PUT</td><td>传输文件,在指明的URL下存储一个文档</td><td>1.1及以后版本</td></tr><tr><td>DELETE</td><td>删除文件，删除指明的URL所标识的资源</td><td>1.1及以后版本</td></tr><tr><td>OPTIONS</td><td>访问支持的方法</td><td>1.1及以后版本</td></tr><tr><td>TRACE</td><td>追踪路径</td><td>1.1及以后版本</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td><td>1.1及以后版本</td></tr><tr><td>LINK</td><td>建立和资源之间的联系</td><td>1.1及以后版本</td></tr><tr><td>UNLINE</td><td>断开连接关系</td><td>1.1及以后版本</td></tr></tbody></table></blockquote><h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部由<font color=" #FF7D00 "><b> 键&#x2F;值对</b></font>组成，每行一对，键和值用英文冒号“:”分隔。负责通知服务器有关于客户端请求的信息。</p><h3 id="常见的请求头："><a href="#常见的请求头：" class="headerlink" title="常见的请求头："></a>常见的请求头：</h3><blockquote><table><thead><tr><th>请求头</th><th>用法</th></tr></thead><tbody><tr><td>User-Agent</td><td>产生请求的客户端类型、系统属性</td></tr><tr><td>Accept</td><td>指定客户端能够处理的媒体类型</td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td></tr><tr><td>Accept-Encoding</td><td>客户端使用的编码环境和编码方式</td></tr><tr><td>Accept-Language</td><td>客户端的语言环境</td></tr><tr><td>Authorization</td><td>授权信息，一般用于存放授权之后的信息</td></tr><tr><td>Connection</td><td>表示是否需要持久连接</td></tr><tr><td>Content-Length</td><td>表示请求数据正文的长度</td></tr><tr><td>Cookie</td><td>这个与服务器端做交互的，存储保持会话的重要信息（保持客户端的登录状态）</td></tr><tr><td>Referer</td><td>表示该次请求的来源，一般用于做防盗链</td></tr></tbody></table></blockquote><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a><strong>空行</strong></h3><p>最后一个请求头之后是一个空行，发送回车符和换行符通知服务器以下不再有请求头。</p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a><strong>请求体</strong></h3><p>请求数据不在<code>GET</code>方法中使用，而是在<code>POST</code>方法中使用。<code>POST</code>方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是<code>Content-Type</code>和<code>Content-Length</code>。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><table><tr><td bgcolor="pink"> 组成部分：状态行、响应头部、空行、响应体</td></tr></table><p><img src="https://i-blog.csdnimg.cn/direct/e744ef9b6a5c46e08503c72e2d538765.png#pic_center" alt="在这里插入图片描述"><br>这部分和请求报文类似，主要分析一下状态行。<br>状态行由<font color="green "><b> 协议版本信息</b></font>、<font color="green "><b> 状态码</b></font>以及<font color="green "><b> 状态码的短语描述</b></font>组成，之间用空格分隔。</p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>状态码（StatusCode）是一个三位数字用来表示请求的结果。状态码分为五类：</p><ul><li>1xx：信息性状态码，表示接收的请求正在处理。</li><li>2xx：成功状态码，表示请求已成功被接收、理解、接受。</li><li>3xx：重定向状态码，表示浏览器需要进一步操作以完成请求。</li><li>4xx：客户端错误状态码，表示客户达请求包含语法错误或无法完成请求。</li><li>5xx：服务器错误状态码，表示服务器在处理请求的过程中发生了错误。</li></ul><blockquote><p><strong>状态消息</strong>（Reason Phrase）是状态码的简短描述，提供了状态码的文本表示。</p><table><thead><tr><th>类别</th><th>状态码</th><th>状态消息</th><th>中文解释</th></tr></thead><tbody><tr><td>信息性</td><td>100</td><td>Continue</td><td>继续</td></tr><tr><td>信息性</td><td>101</td><td>Switching Protocols</td><td>切换协议</td></tr><tr><td>成功</td><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>成功</td><td>201</td><td>Created</td><td>创建成功</td></tr><tr><td>成功</td><td>202</td><td>Accepted</td><td>已接受</td></tr><tr><td>成功</td><td>204</td><td>No Content</td><td>无内容</td></tr><tr><td>重定向</td><td>301</td><td>Moved Permanently</td><td>永久移动</td></tr><tr><td>重定向</td><td>302</td><td>Found</td><td>临时移动</td></tr><tr><td>重定向</td><td>304</td><td>Not Modified</td><td>缓存内容未修改</td></tr><tr><td>客户端错误</td><td>400</td><td>Bad Request</td><td>错误请求</td></tr><tr><td>客户端错误</td><td>401</td><td>Unauthorized</td><td>未授权</td></tr><tr><td>客户端错误</td><td>403</td><td>Forbidden</td><td>禁止访问</td></tr><tr><td>客户端错误</td><td>404</td><td>Not Found</td><td>未找到</td></tr><tr><td>客户端错误</td><td>405</td><td>Method Not Allowed</td><td>方法不允许</td></tr><tr><td>服务器错误</td><td>500</td><td>Internal Server Error</td><td>内部服务器错误</td></tr><tr><td>服务器错误</td><td>502</td><td>Bad Gateway</td><td>网关错误</td></tr><tr><td>服务器错误</td><td>503</td><td>Service Unavailable</td><td>服务不可用</td></tr><tr><td>服务器错误</td><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr></tbody></table></blockquote><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><blockquote><p>HTTP中的重定向就是当客户端访问一个服务器不可用的资源后，服务器会返回一个响应包，响应包中带有另一个链接，然后浏览器会自动跳转到另一个链接，无需用户点击，是浏览器自动跳转的。</p></blockquote><ul><li>301永久重定向：搜索引擎或者浏览器会自动将书签、历史记录、搜索引擎对应的记录中旧链接更新为新链接。下次就访问新链接。</li><li>302临时重定向：原来的URL仍然有效，下次还访问旧链接。</li></ul><h1 id="HTTPS（HTTP-加密-认证-完整性保护）"><a href="#HTTPS（HTTP-加密-认证-完整性保护）" class="headerlink" title="HTTPS（HTTP +加密 + 认证 + 完整性保护）"></a>HTTPS（HTTP +加密 + 认证 + 完整性保护）</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><blockquote><p>由于互联网上的所有数据都需经过路由器的多次转发，最终到达目标主机。当黑客入侵了这些场所的路由器，就可以通过抓包工具获取所有经过该路由器转发的数据，因此当我们通过网络传输了某些比较敏感的数据（如账户名、密码、身份证、各类支付密码、家庭住址等）且数据是明文传输的，黑客就可以通过这些信息做出某些违法行为，进而造成不可挽回的损失。</p></blockquote><blockquote><p>HTTPS（Hyper Text Transfer Protocol Secure，安全的超文本传输协议）是一种基于 SSL&#x2F;TLS 协议的 HTTP 协议，它是 HTTP 协议的安全版本。HTTPS 协议通过加密通信内容和身份验证来保证数据传输的安全性和完整性，从而可以有效地防止数据在传输过程中被窃取或篡改。</p></blockquote><h2 id="SSL-TLS-协议"><a href="#SSL-TLS-协议" class="headerlink" title="SSL&#x2F;TLS 协议"></a>SSL&#x2F;TLS 协议</h2><p>SSL（Secure Sockets Layer）和TLS（Transport Layer Security）是两个主要的互联网安全协议，它们用于在计算机之间建立加密的通信连接，它们还提供了一种验证通信双方身份的方法，以防止中间人攻击。</p><blockquote><ul><li><strong>历史：</strong><br>SSL最初由网景公司（Netscape）在1994年开发，用于保护Web浏览器和服务器之间的通信。<br>TLS是SSL的后继者，由互联网工程任务组（IETF）标准化。TLS 1.0在1999年发布，随后有多个版本更新。</li><li><strong>工作流程：</strong><br><font color="blue "><b> 握手阶段</b></font>：在数据传输开始之前，客户端和服务器之间会进行一个握手过程，以协商加密算法、生成共享密钥，并验证彼此的身份。<br><font color="blue "><b> 加密通信</b></font>：一旦握手完成，客户端和服务器将使用协商的密钥和加密算法来加密和解密它们之间传输的数据。</li></ul></blockquote><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>在HTTPS中，证书是一种<font color="red "><b> 数字文档</b></font>，用于证明网站的身份，并用于在SSL&#x2F;TLS握手过程中安全地交换密钥。<br><img src="https://i-blog.csdnimg.cn/direct/ba1efd177726433f8466f8333481eeff.png#pic_center" alt="在这里插入图片描述"></p><p><strong>证书的组成：</strong></p><blockquote><ul><li>公钥：服务器的公钥，用于加密通信。</li><li>身份信息：包括服务器的域名、公司名称等。</li><li>证书颁发机构（CA）：证书由CA签发，CA是一个可信的第三方机构，负责验证服务器身份并签发证书。</li><li>有效期：证书的有效期限。</li><li>证书签名：CA用自己的私钥对证书内容进行签名，以确保证书的完整性和真实性。</li></ul></blockquote><p><strong>证书的作用：</strong></p><blockquote><ul><li><font color=" #FF7D00 "><b> 身份验证：确保用户连接到的是正确的服务器，而不是一个假冒的服务器。</b></font></li><li><font color=" #FF7D00 "><b> 密钥交换：证书中包含服务器的公钥，用于加密通信。</b></font></li><li>数据完整性：确保数据在传输过程中没有被篡改。</li></ul></blockquote><h2 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h2><p>HTTPS的加密过程涉及到几个关键步骤，主要使用了对称加密和非对称加密两种技术。</p><ul><li><strong>对称加密（共享密匙加密）</strong><br> <font color=" red "><b> 关键：</b></font><code>使用相同的密钥进行数据的加密和解密。</code><br><font color=" red "><b> 在HTTPS中的应用：</b></font>在SSL&#x2F;TLS握手过程中，客户端和服务器使用对称加密来保护实际传输的数据。一旦握手完成，双方会生成一个会话密钥（session key），这个密钥用于整个会话期间的数据加密和解密。<br><font color=" red "><b> 缺点：</b></font>以共享密钥方式加密时必须将密钥也发给对方在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</li></ul><p><img src="https://i-blog.csdnimg.cn/direct/16f74d23a87f4c77b299675faa71e573.png" alt="在这里插入图片描述"></p><ul><li><strong>非对称加密（公开密匙加密）</strong><br> <font color=" red "><b> 关键：</b></font><code>一个公钥和一个私钥。</code>数据可以用公钥加密，然后只有对应的私钥才能解密。公钥可以公开分享，而私钥必须保密。<br><font color=" red "><b> 在HTTPS中的应用：</b></font></li><li>密钥交换：客户端使用服务器的公钥加密预主密钥（pre-master secret），然后发送给服务器，服务器使用自己的私钥解密得到预主密钥。</li><li>证书验证：服务器的证书中包含了服务器的公钥。客户端使用这个公钥来验证服务器的身份，并确保证书的签名是有效的。<br><font color=" red "><b> 缺点：</b></font>加密和解速度慢，不适合大量数据的加密。</li></ul><p><img src="https://i-blog.csdnimg.cn/direct/a4efc85929c148c2860abff491f83793.png#pic_center" alt="在这里插入图片描述"></p><h2 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h2><blockquote><p>HTTPS 充分利用了两者各自的优势，采用共享密钥加密和公开密钥加密两者并用的混合加密机制。<br><font color=" red "><b> 先保证安全，再保证高效：</b></font></p><ul><li>在<font color=" #FF00FF "><b> 交换密钥环节</b></font>使用<font color=" #FF00FF "><b> 公开密钥加密方式；</b></font></li><li>在<font color="green"><b> 建立通信交换报文阶段</b></font>则使用<font color="green"><b> 共享密钥加密方式。</b></font></li></ul></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/a5259ab3a00c41c084ae0fb3145fa650.png#pic_center" alt="在这里插入图片描述"><br><strong>流程：</strong></p><blockquote><ol><li><strong>客户端发起HTTPS请求：</strong><br>用户在浏览器中输入一个以https:&#x2F;&#x2F;开头的网址，客户端（通常是浏览器）向服务器的443端口（HTTPS的默认端口）发起连接请求。</li><li><strong>服务器响应并发送证书：</strong><br>服务器响应客户端的请求，并发送其SSL&#x2F;TLS数字证书给客户端。这个证书包含了服务器的公钥、证书颁发机构（CA）信息、服务器身份信息以及证书的签名等信息。</li><li><strong>客户端验证服务器证书：</strong><br>客户端接收到服务器的证书后，会验证证书的合法性。这包括检查证书的颁发机构是否可信、证书是否在有效期内、以及证书的签名是否有效等。如果证书验证失败，客户端会发出警告或中断连接。</li><li><strong>密钥交换与生成：</strong><br>如果服务器证书验证通过，客户端会生成一个随机的预主密钥（pre-master secret），并使用服务器的公钥进行加密后发送给服务器。服务器使用自己的私钥解密得到预主密钥。然后，客户端和服务器都基于这个预主密钥和一些其他参数，生成一个会话密钥（session key）。这个会话密钥将用于后续的数据加密和解密。</li><li><strong>建立安全连接：</strong><br>客户端和服务器使用协商出的会话密钥对传输的数据进行加密，确保数据在传输过程中的安全。此后，客户端和服务器之间的所有通信都会使用这个会话密钥进行加密。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 接口测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议</title>
      <link href="/2024/08/09/TCP-IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/08/09/TCP-IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>为了使多种设备能通过网络通信和解决不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（OSI），但在实际应用上采用的是TCP&#x2F;IP这种四层模型。<br><img src="https://i-blog.csdnimg.cn/direct/816620753b894d26bc03640565b9f519.png" alt="网络模型"></p><blockquote><ul><li>应用层：处理并打包数据(HTTP)</li><li>传输层：在网络中的两个节点之间提供可靠的数据传输服务(TCP)</li><li>网络层：负责数据包从源到目的地的路由选择(IP)</li></ul></blockquote><h1 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>互联网的本质就是一系列的网络协议，处于互联网上的两台计算机如果要实现通信，就需要遵守这些协议，比如：网线的接口类型，寻址方式，数据如何发送等一系列协议。<br>网络通信是一个比较复杂的事情，需求场景复杂了，实现功能也会比较复杂。实际应用中是把这个大协议拆分成小协议(每个协议负责一部分功能)，将某些协议功能类似的小协议进一步的”分类”(“分层”)。</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网（Ethernet）是一种局域网（Local Area Network, LAN）技术，以太网技术本身包括了物理层和数据链路层的规范，这些规范定义了如何在局域网中传输数据帧。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址（Internet Protocol Address）是互联网协议地址的简称，是用于在互联网上标识和定位设备的唯一数字标签。IP地址由32位（IPv4）或128位（IPv6）的二进制数组成，通常用点分十进制表示（IPv4）或冒号分隔的十六进制表示（IPv6）。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>端口号的主要作用是表示一台计算机中的特定进程所提供的服务，即用来区分一个主机上的不同程序,因此也被称为程序地址。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC地址，全称为媒体访问控制地址（Media Access Control Address），是一种用于网络通信的唯一标识符。MAC地址通常由12位十六进制数字组成，分为6个字节，每个字节由两个十六进制数字表示，例如：00-1A-2B-3C-4D-5E。MAC地址具有全球唯一性，每个网络设备在生产时都会被分配一个唯一的MAC地址。这种唯一性确保了在网络中不会出现地址冲突，从而保证了网络通信的顺畅。MAC地址通常被烧录在网络设备的硬件上，如网卡、路由器、交换机等。<br>MAC地址与IP地址相互配合，共同完成网络通信。IP地址用于在互联网上标识设备的位置，而MAC地址则用于在局域网内标识设备。当数据在局域网内传输时，主要依赖MAC地址进行寻址；而当数据需要跨越不同网络时，IP地址则起到了关键作用。通过ARP（地址解析协议），可以将IP地址解析为MAC地址，从而实现不同网络之间的通信。</p><h1 id="应用层协议——HTTP"><a href="#应用层协议——HTTP" class="headerlink" title="应用层协议——HTTP"></a>应用层协议——HTTP</h1><p>这是基于TCP&#x2F;IP 的应用层协议，后面单独写一篇博文总结。<br><img src="https://i-blog.csdnimg.cn/direct/d086d114dc854f6a9eaf816849ab72c3.png#pic_center" alt="http报文传输过程"><br>数据在各层的叫法：</p><ul><li>链路层——数据帧frame</li><li>网络层——数据包packet</li><li>传输层——数据报(TCP叫segment&#x2F;UDP叫datagram)</li><li>每层数据封装好包含了将要发送的完整的数据信息后就是报文</li></ul><h1 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h1><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I&#x2F;O插入到网络中，并与网络中的其他应用程序进行通信。通过使用 Socket，可以在不同计算机之间建立连接，并进行数据的传输和交换。<br>Socket 可以用于实现各种网络应用，例如：</p><ol><li>客户端-服务器通信：通过 Socket，客户端可以与服务器建立连接并发送请求，服务器接收请求并返回响应。</li><li>网络聊天和即时通讯：通过 Socket，可以在多个用户之间实现实时的文字、音频或视频通信。</li><li>文件传输：在不同计算机之间传输文件。</li><li>远程控制：在远程计算机上执行指令或操作。</li><li>P2P（点对点）通信：Socket 提供了直接的点对点通信接口，允许两个或多个计算机直接进行数据交换。</li></ol><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的协议，这意味着&#x3D;&#x3D;在数据传输开始之前，必须在发送端和接收端之间建立一个连接。&#x3D;&#x3D;</p><ul><li><strong>可靠传输</strong>：TCP提供可靠的数据传输服务，确保数据包正确无误地到达目的地。&#x3D;&#x3D;如果数据包在传输过程中丢失或损坏，TCP会重新发送数据包，直到接收端正确接收到所有数据。&#x3D;&#x3D;</li><li><strong>数据顺序</strong>：TCP保证数据包的顺序，即使在网络中传输的路径不同，接收端也能按照发送端的顺序接收数据。</li><li><strong>流量控制和拥塞控制</strong>：TCP通过滑动窗口机制实现流量控制，并通过拥塞控制算法（如慢启动、拥塞避免、快速重传和快速恢复）来避免网络拥塞。</li><li><strong>全双工通信</strong>：TCP支持全双工通信，即数据可以在两个方向上同时传输。</li></ul><h3 id="帧头格式"><a href="#帧头格式" class="headerlink" title="帧头格式"></a>帧头格式</h3><p><img src="https://i-blog.csdnimg.cn/direct/44e7c0931ad242dfbdbbf5c3237d0b64.png#pic_center" alt="TCP帧头格式"></p><ul><li>ACK:确认接受标志位，ACK&#x3D;1为确认接受到</li><li>SYN:建立连接时的同步标志位，SYN&#x3D;1&#x2F;ACK&#x3D;0表是A请求与B建立连接；若B报文中SYN&#x3D;1&#x2F;ACK&#x3D;1表示B同意和A建立连接</li><li>FIN:请求断开连接标志位</li><li>seq:传输报文中的数据部分的每一个字节都有它的编号，建立连接时的为初始随机序号ISN</li><li>ack:响应端收到信息，并准备接受的下一个数据的序号（上一数据末尾序号+1）<br>:exclamation::exclamation::exclamation:在建立连接和正常通信两个阶段，seq的计算方法不同，<a href="https://blog.csdn.net/qq_35654659/article/details/130149239?ops_request_misc=%257B%2522request%255Fid%2522%253A%252242C325D7-C44F-4400-894E-4779E84677E4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=42C325D7-C44F-4400-894E-4779E84677E4&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-130149239-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=TCP%20seq&spm=1018.2226.3001.4187">具体参考博客——【转载】TCP的seq和ack号计算方法</a></li></ul><h3 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h3><ul><li><p>三次握手</p><blockquote><p>例子描述：A给B寄东西，B的看到消息要回复A收到了，如果B的回复A的没看到的话，会继续问B到底收到没有；A收到B的消息后，再嘱咐B一些东西细节，这样这个过程就建立完了<br><img src="https://i-blog.csdnimg.cn/direct/e27479d60fb44b4fbb273301a688dcda.png#pic_center" alt="三次握手"><br><font color="red">握手的过程实际上是在通知对方自己的初始化序号ISN，也就是上图中的x和y。</font>x和y会被当作之后传输数据的一个依据，以保证TCP报文在传输过程中不会混乱。</p></blockquote></li><li><p>四次挥手</p><blockquote><p>&#x3D;&#x3D;描述：<br>1.客户端主动请求关闭通信连接<br>2.服务端收到请求并确认，之后一段时间仍会发送未发送完的数据<br>3.数据全发完后，服务端请求可以关闭连接了<br>4.客户端收到并确认&#x3D;&#x3D;<br><img src="https://i-blog.csdnimg.cn/direct/82eb693473a44d4391d23474db0c04cd.png#pic_center" alt=" 四次挥手"><br>处于TIME_WAIT状态的主动断开方，在等待完成2MSL（Maximum Segment Lifetime，指的是一个TCP报文片段在网络中最大的存活时间，具体来说，2MSL对应于一次消息的来回（一个发送和一个回复）所需的最大时间）的时间后，才真正关闭连接通道，避免因网络不可靠的，被动断开方发送FIN+ACK报文后，其主动方的ACK响应报文丢失的情况，这时候的被动断开方处于LAST-ACK状态的，由于收不到ACK确认被动方一直不能正常的进入CLOSED状态。</p></blockquote></li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP（User Datagram Protocol，用户数据报协议用户数据报协议）是一种无连接的协议，&#x3D;&#x3D;不需要在发送端和接收端之间建立连接，可以直接发送数据。&#x3D;&#x3D;</p><ul><li><strong>不保证可靠性</strong>：UDP不保证数据的可靠传输，如果数据包在传输过程中丢失或损坏，UDP不会重新发送数据包。</li><li><strong>无数据顺序</strong>：UDP不保证数据包的顺序，接收端可能以不同于发送端的顺序接收数据。</li><li><strong>无流量控制和拥塞控制</strong>：UDP没有流量控制和拥塞控制机制，因此它不适合需要这些机制的应用。</li><li><strong>半双工或简单全双工通信</strong>：UDP通常支持半双工通信，但也可以支持全双工通信。</li><li><strong>开销较小</strong>：UDP不需要建立连接和维护连接状态，因此它的开销比TCP小，适用于对实时性要求高的应用，如视频会议、在线游戏等。</li><li></li></ul><h2 id="TCP的socket实现"><a href="#TCP的socket实现" class="headerlink" title="TCP的socket实现"></a>TCP的socket实现</h2><p><img src="https://i-blog.csdnimg.cn/direct/d31df6639f9a468e96c603756e715962.png#pic_center" alt="TCP_socket"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 三次握手 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
