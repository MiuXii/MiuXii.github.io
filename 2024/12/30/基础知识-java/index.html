<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>基础八股杂烩 | 知识小岛</title><meta name="author" content="Xu Wenjin"><meta name="copyright" content="Xu Wenjin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文杂烩了Java基础和计网等相关八股。">
<meta property="og:type" content="article">
<meta property="og:title" content="基础八股杂烩">
<meta property="og:url" content="http://example.com/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/index.html">
<meta property="og:site_name" content="知识小岛">
<meta property="og:description" content="本文杂烩了Java基础和计网等相关八股。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1.png">
<meta property="article:published_time" content="2024-12-30T13:05:37.000Z">
<meta property="article:modified_time" content="2025-05-08T03:53:45.604Z">
<meta property="article:author" content="Xu Wenjin">
<meta property="article:tag" content="八股">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基础八股杂烩",
  "url": "http://example.com/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/",
  "image": "http://example.com/img/cover/%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1.png",
  "datePublished": "2024-12-30T13:05:37.000Z",
  "dateModified": "2025-05-08T03:53:45.604Z",
  "author": [
    {
      "@type": "Person",
      "name": "Xu Wenjin",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":150,"languages":{"author":"Author: Xu Wenjin","link":"Link: ","source":"Source: 知识小岛","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基础八股杂烩',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fa fa-link"></i><span> 学习资源</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(img/cover/基础八股.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">知识小岛</span></a><a class="nav-page-title" href="/"><span class="site-name">基础八股杂烩</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fa fa-link"></i><span> 学习资源</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">基础八股杂烩</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-30T13:05:37.000Z" title="Created 2024-12-30 21:05:37">2024-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-08T03:53:45.604Z" title="Updated 2025-05-08 11:53:45">2025-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/">基础八股</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><meta name="referrer" content="no-referrer">

<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><h3 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h3><ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<img src="/./res\Kernel_Layout.png" alt="Kernel_Layout" style="zoom:67%;">

<h3 id="操作系统的管理对象"><a href="#操作系统的管理对象" class="headerlink" title="操作系统的管理对象"></a>操作系统的管理对象</h3><p>OS是计算机系统资源的管理者：对处理器，存储器，IO设备，文件进行管理</p>
<ol>
<li>CPU：分配，控制</li>
<li>存储器：分配，管理，回收</li>
<li>IO设备：分配，操作，回收</li>
<li>文件：存取，共享，保护</li>
</ol>
<h3 id="Kernel和CPU"><a href="#Kernel和CPU" class="headerlink" title="Kernel和CPU"></a>Kernel和CPU</h3><h4 id="内核（Kernel）"><a href="#内核（Kernel）" class="headerlink" title="内核（Kernel）"></a>内核（Kernel）</h4><ol>
<li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的<strong>内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</li>
<li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li>
</ol>
<h4 id="中央处理器（CPU，Central-Processing-Unit）"><a href="#中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="中央处理器（CPU，Central Processing Unit）"></a>中央处理器（CPU，Central Processing Unit）</h4><ol>
<li><strong>CPU 是一台计算机的运算核心（Core）+ 控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li>
<li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ol>
<h4 id="CPU-vs-Kernel-内核"><a href="#CPU-vs-Kernel-内核" class="headerlink" title="CPU vs Kernel(内核)"></a>CPU vs Kernel(内核)</h4><ol>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>
</ol>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<img src="/./res\L181kk2Eou-compress.jpg" alt="img" style="zoom:67%;">

<h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><ol>
<li>OS实现资源的抽象（抽象为对象，用户对计算机的使用大多集中在IO上），通过一定的抽象资源管理软件，将管理软件逐层覆盖再计算机硬件上，形成虚机器。虚机器是逐层系统软件覆盖再逻辑上而成的逻辑计算机</li>
</ol>
<blockquote>
<ul>
<li>第一层抽象：对IO设备的管理</li>
<li>第二层抽象：对文件的管理</li>
<li>第三层抽象：对图形操作的管理</li>
</ul>
</blockquote>
<ol start="2">
<li>操作系统定义：能有效组织和管理四大资源，合理对各类作业进行调度和控制，方便用户使用的软件</li>
<li>分时系统：在一台主机上连接多个配有显示器和键盘的终端并由此构成的系统。系统允许多个用户同时通过自己的终端，以交互的方式使用计算机，共享主机资源</li>
<li>多路卡（缓存区池）：即时接收多终端的用户输入，实现分时多路复用。主机以极快的速度周期性扫描中断，用于接收中断数据。中断输入通过多路卡进入主机内存，将来获得CPU资源的计算。</li>
</ol>
<img src="/./res\1683451419914-aea0fbad-a8d7-46b4-bf18-ff94d9db2344.png" alt="image.png" style="zoom: 33%;">

<ol start="6">
<li><p>时间片：每个作业每次运行的最长时间，如果作业运行时间超过此，系统会暂停作业的执行，自动调度下一个作业运行。</p>
</li>
<li><p>实时系统：能够及时响应外部事件的请求，并且再规定的时间内完成该事件的处理，并控制所有逝世人物协调一致的运行。</p>
<blockquote>
<ul>
<li>周期性实时任务和非周期性实时任务（又分为 开始截止时间任务（在什么时间必须开始），完成戒截止时间任务（再什么时间必须结束））</li>
<li>硬实时任务HRT（必须满足时间要求） 和 软实时任务 SRT（seldom可以不满足）</li>
</ul>
</blockquote>
</li>
<li><p>微机操作系统：（PC机）</p>
</li>
<li><p>网络操作系统：同微机操作，服务类型不同</p>
</li>
<li><p>云操作系统：一种管理海量的基础硬件和软件资源的云平台综合管理系统（VMWare的VSphere，浪潮的云海，阿里的AliOS）</p>
</li>
<li><p>dubbo中的虚拟化可以解决一致性hash算法产生的负载均衡雪崩问题和影响不一致问题，具体方法是进行虚拟化，</p>
</li>
</ol>
<img src="https://cdn.nlark.com/yuque/0/2023/png/29364962/1683453218743-e1266959-f43c-4581-bfe0-df97e999b378.png#averageHue=%23f8daa6&clientId=ubbabcf32-b7f1-4&from=paste&height=914&id=u411ed5e8&originHeight=1142&originWidth=1507&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=381745&status=done&style=none&taskId=ue5a0d8c9-584f-4530-986c-75b82a95735&title=&width=1205.6" alt="image.png" style="zoom:33%;">



<h2 id="操作系统特性"><a href="#操作系统特性" class="headerlink" title="操作系统特性"></a>操作系统特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a><strong>并发性</strong></h3><p>并发是指两个事件或者更多的事件在同一时间间隔发生，<strong>区别于并行，并行是在同一时刻运行多个任务，</strong>并发可以提高系统资源利用率，提高系统吞吐量。</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>并发的基本实现就是进程，进程是系统独立运行并作为资源分配的基本单位，由一组指令、数据和堆栈组成，是一个独立运行的活动实体。</p>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>共享依据对资源复用的方式分为：互斥共享，同时访问</p>
<h4 id="互斥共享"><a href="#互斥共享" class="headerlink" title="互斥共享"></a>互斥共享</h4><p>可供多个进程，但是同一时刻只能允许一个进程访问</p>
<h4 id="同时访问"><a href="#同时访问" class="headerlink" title="同时访问"></a>同时访问</h4><p>允许在一段时间内由多个进程同时访问，单处理机实质上是交替访问磁盘，多处理机就是真正的同时访问</p>
<h3 id="虚拟性"><a href="#虚拟性" class="headerlink" title="虚拟性"></a>虚拟性</h3><p>通过某种技术将一个物理实体变为若干个逻辑上的对应物，此为虚拟。虚拟技术分为：时分复用，空分复用</p>
<h4 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h4><p>某设备的空闲状态可以为其他用户提供服务</p>
<h4 id="空分复用"><a href="#空分复用" class="headerlink" title="空分复用"></a>空分复用</h4><h4 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h4><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>不可预知性，不确定性。对于内存中的进程，不确定何时获取到处理器运行，何时由于提出临界资源请求暂停，工作总共需要多少时间才能完成，都是不可预知的，不确定的。<br>一个程序运行多次结果可能不相同，如果OS配置有完善的进程同步机制，在运行环境相同下，运行的结果一定是相同的</p>
<h4 id="Zookepper-协调性"><a href="#Zookepper-协调性" class="headerlink" title="Zookepper 协调性"></a>Zookepper 协调性</h4><p>分布式协调服务器，实现分布式系统同步运行，实现系统功能的协调推进。实现集群管理，Master选举，分布式锁，分布式队列</p>
<h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p><strong>进程</strong>：是程序一次执行过程，是<strong>系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程。<strong>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位</strong>。</p>
<img src="/./res\20150603133335514" alt="在这里插入图片描述" style="zoom: 67%;">

<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><h5 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h5><img src="/./res\QQ截图20230510150756.png" style="zoom:67%;">

<ul>
<li><p>就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</p>
<blockquote>
<p>另外，<strong>就绪进程可以按多个优先级来划分队列</strong>。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。</p>
</blockquote>
</li>
<li><p>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</p>
</li>
<li><p>阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</p>
</li>
</ul>
<h5 id="五态模型"><a href="#五态模型" class="headerlink" title="五态模型"></a>五态模型</h5><img src="/./res\8-进程五个状态.jpg" alt="进程五种状态的变迁" style="zoom:67%;">

<ul>
<li><p><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</p>
</li>
<li><p><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</p>
<ul>
<li><strong>运行状态(running)</strong> ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
</ul>
</li>
<li><p><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</p>
</li>
<li><p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</p>
</li>
</ul>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ul>
<li><strong>匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程或者兄弟进程之间的通信。</li>
<li><strong>命名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了命名管道。命名管道严格遵循**先进先出(first in first out)**。命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（匿名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是<strong>最有用</strong>的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。<strong>套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元</strong>，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ul>
<h5 id="命名管道和匿名管道的区别"><a href="#命名管道和匿名管道的区别" class="headerlink" title="命名管道和匿名管道的区别"></a><strong>命名管道和匿名管道的区别</strong></h5><ul>
<li>匿名管道由pipe函数创建并打开</li>
<li>命名管道由mkfifo函数创建，打开用open</li>
</ul>
<p>匿名管道由于没有名字，只能用于亲缘关系的进程间通信。</p>
<p>命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<h4 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h4><p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>高响应比优先调度算法</strong>：调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>最高优先级调度算法</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
</ul>
<p><strong>抢占式和非抢占式</strong></p>
<p>非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该<strong>进程完成</strong>或<strong>发生某个事件而被阻塞</strong>时，才会把 CPU 让给其他进程。</p>
<p>而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p>
<h5 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h5><p>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（First Come First Severd, FCFS）算法</strong></p>
<p><strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<img src="/./res\24-先来先服务.jpg" alt="FCFS 调度算法" style="zoom:67%;">

<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p>
<p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<h5 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h5><p><strong>最短作业优先（Shortest Job First, SJF）调度算法</strong>，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<img src="/./res\25-最短作业优先算法.jpg" alt="SJF 调度算法" style="zoom:67%;">

<p>这显然对长作业不利，很容易造成一种极端现象。</p>
<p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>
<h5 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h5><p><strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</p>
<p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p>
<img src="/./res\26-响应比公式.jpg" alt="img" style="zoom:67%;">

<ul>
<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>
<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li>
</ul>
<h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>
<img src="/./res\27-时间片轮询.jpg" alt="RR 调度算法" style="zoom:67%;">

<p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li>
</ul>
<p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
<h5 id="最高优先级调度算法"><a href="#最高优先级调度算法" class="headerlink" title="最高优先级调度算法"></a>最高优先级调度算法</h5><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p>
<p>进程的优先级可以分为，静态优先级或动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
<h5 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h5><p><strong>多级反馈队列调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<p>顾名思义：</p>
<ul>
<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>
<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>
</ul>
<img src="/./res\28-多级队列.jpg" alt="多级反馈队列" style="zoom:67%;">

<p>来看看，它是如何工作的：</p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li>
<li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程</strong>：<strong>线程，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位</strong>。线程是比进程更小的执行单位。一个进程在其执行的过程中，可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈。<strong>详细线程解析在java板块中</strong></p>
<p><img src="/.%5Cres%5C133750_ldwM_1863332.jpg" alt="在这里插入图片描述"></p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651?ops_request_misc=%7B%22request_id%22:%22165753938316781647571786%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165753938316781647571786&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53860651-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81&spm=1018.2226.3001.4187">Java线程的6种状态及切换(透彻讲解)</a></p>
<ol>
<li>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。</li>
<li><strong>运行(RUNNABLE)<strong>：Java线程中将</strong>就绪（ready）</strong>和<strong>运行中（running）</strong>两种状态笼统的称为“运行”。</li>
<li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li>
<li>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>**终止(TERMINATED)**：表示该线程已经执行完毕。</li>
</ol>
<img src="/八股笔记.assets/20181120173640764.jpeg" alt="线程状态图" style="zoom: 67%;">

<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（就绪）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行中）</strong> 状态。</p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED_WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<p><strong>线程阻塞的三种情况</strong></p>
<ol>
<li><strong>等待阻塞</strong>（Object.wait -&gt; 等待队列）<br>RUNNING 状态的线程执行 Object.wait() 方法后，JVM 会将线程放入等待序列（waitting queue）；</li>
<li><strong>同步阻塞</strong>（lock -&gt; 锁池）<br>RUNNING 状态的线程在获取对象的同步锁时，若该 同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中；</li>
<li><strong>其他阻塞</strong>（sleep&#x2F;join）<br>RUNNING 状态的线程执行 Thread.sleep(long ms) 或 Thread.join() 方法，或发出 I&#x2F;O 请求时，<br>JVM 会将该线程置为阻塞状态。当 sleep() 状态超时， join() 等待线程终止或超时. 或者 I&#x2F;O 处理完<br>毕时，线程重新转入可运行状态（ RUNNABLE ）；</li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="死锁的引发"><a href="#死锁的引发" class="headerlink" title="死锁的引发"></a>死锁的引发</h5><p>系统中以下四个条件同时成立，那么就能引起死锁：</p>
<ol>
<li><strong>互斥条件</strong>：该资源任意时刻只由一个线程占用。</li>
<li><strong>请求与保持条件</strong>（持有并等待条件）：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不可剥夺条件</strong>（<strong>非抢占</strong>）：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件</strong>（环路等待条件）：若干线程之间形成一种头尾相接的循环等待资源关系。有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ol>
<p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p>
<ul>
<li><strong>预防</strong>是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li>
<li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li>
<li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li>
<li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<h5 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h5><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p>
<p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所有资源，会导致 <strong>资源利用率下降</strong>。</p>
<p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p>
<p><strong>静态分配策略</strong></p>
<p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指<strong>一个进程必须在执行前就申请到它所需要的全部资源</strong>，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在进程所占有的资源中，有些资源是在比较靠后的执行时间里才用到，甚至有些资源是在额外的情况下才使用，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p>
<p><strong>层次分配策略</strong></p>
<p><strong>层次分配策略破坏了产生死锁的第四个条件(循环等待)。</strong>在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一层的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p>
<h5 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h5><p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，在为申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p>
</blockquote>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，&#x3D;&#x3D;银行家算法&#x3D;&#x3D;用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<p>银行家算法详情可见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33414271/article/details/80245715">《一句话+一张图说清楚——银行家算法》open in new window</a> 。</p>
<p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p>
<h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁，等到真的死锁出现了再来解决，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<h6 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="进程-资源分配图"></a>进程-资源分配图</h6><p>操作系统中的每一刻时刻的<strong>系统状态</strong>都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p>
<p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p>
<p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p>
<img src="/./res\进程-资源分配图.31e353df.jpg" alt="进程-资源分配图" style="zoom: 25%;">

<h6 id="死锁检测步骤"><a href="#死锁检测步骤" class="headerlink" title="死锁检测步骤"></a>死锁检测步骤</h6><p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
<h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p>
<ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><strong>协程：</strong>是一种比线程更加轻量级的存在，<strong>协程不是被操作系统内核所管理，而完全是由程序所控制</strong>（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p><img src="/D:/笔记/八股笔记.assets/6765e36cc4604fba897976638af03524.jpeg" alt="在这里插入图片描述" style="zoom:50%;"> </p>
<p><strong>协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行</strong>。</p>
<h4 id="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"><a href="#协程的特点在于是一个线程执行，那和多线程比，协程有何优势？" class="headerlink" title="协程的特点在于是一个线程执行，那和多线程比，协程有何优势？"></a>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</h4><p><strong>极高的执行效率</strong>：因为子程序切换不是线程切换，而是由程序自身控制，因此，<strong>没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显；</p>
<p><strong>不需要多线程的锁机制</strong>：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<h3 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h3><ul>
<li><strong>根本区别</strong>：进程是操作系统<strong>资源分配</strong>的基本单位，而线程是处理器<strong>任务调度和执行</strong>的基本单位</li>
<li><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有<strong>较大的开销</strong>；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
<li><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li><strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li>
<li><strong>执行过程</strong>：每个独立的进程有程序运行的入口。顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。</li>
</ul>
<p>对于，线程相比进程能减少开销，体现在：</p>
<ul>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<p> <strong>总结：</strong> </p>
<ul>
<li><p>线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</p>
</li>
<li><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p>
</li>
<li><p>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
</li>
</ul>
<h3 id="并发和并行区别"><a href="#并发和并行区别" class="headerlink" title="并发和并行区别"></a>并发和并行区别</h3><p><strong>并发是指一个处理器同时处理多个任务。</strong><br><strong>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</strong></p>
<ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<p>当有多个线程在操作时,如果系统只有<strong>一个CPU</strong>,则它根本不可能真正同时进行一个以上的线程,它只能<strong>把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行,<strong>在一个时间段的线程代码运行时,其它线程处于挂起状态.这种方式我们称之为</strong>&#x3D;&#x3D;并发&#x3D;&#x3D;</strong>(Concurrent)。</p>
<p>当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时,另一个CPU可以执行另一个线程,<strong>两个线程互不抢占CPU资源</strong>,可以同时进行,这种方式我们称之为<strong>并行</strong>(Parallel)。</p>
<h3 id="同步和异步区别"><a href="#同步和异步区别" class="headerlink" title="同步和异步区别"></a>同步和异步区别</h3><ul>
<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<h3 id="线程安全和不安全"><a href="#线程安全和不安全" class="headerlink" title="线程安全和不安全"></a>线程安全和不安全</h3><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p>
<ul>
<li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li>
<li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)</a></p>
<h3 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h3><ul>
<li><p><strong>内存空间的分配与回收</strong></p>
<p>操作系统负责对内存空间的分配与回收，对于一个进程来讲，有很多位置可以放置，那么应该放在哪里？所以OS需要记住哪些内存区域已经被分配出去了，哪些还是空闲的，当进程运行结束之后，如何将进程占用的内存空间进行回收？这些都是操作系统对于内存空间的分配和回收功能需要考虑的问题。</p>
</li>
<li><p><strong>内存空间的扩充</strong></p>
<p>操作系统需要提供某种技术从逻辑上对于内存空间进行扩充。</p>
</li>
<li><p><strong>地址转换</strong></p>
<p>操作系统需要提供地址转换功能，负责将程序的逻辑地址与物理地址进行转换。</p>
</li>
<li><p><strong>存储保护</strong></p>
<p>操作系统需要提供内存保护的功能，保证各个进程在各自的存储空间内运行，互相不干扰。</p>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="定义与优点"><a href="#定义与优点" class="headerlink" title="定义与优点"></a>定义与优点</h4><ul>
<li><strong>定义：虚拟内存是操作系统为每个进程提供的一个连续的虚拟地址空间，并且把内存扩展到硬盘空间</strong>，它让每个进程觉得自己拥有一片连续的可用内存，但是实际上<strong>这片连续的内存空间由多个离散的物理内存页和部分存储在外部磁盘上的文件组成</strong>。因此，我们程序所使用的内存地址叫做虚拟内存地址，实际的内存地址叫做物理内存地址。</li>
<li><strong>优点</strong><ul>
<li><strong>隔离进程之间的地址空间</strong>：操作系统将不同进程的虚拟地址与不同的物理内存地址和磁盘文件映射起来，使得各个进程之间的物理内存地址不会发生冲突，当进程要访问内存中的数据时，由操作系统将虚拟内存地址转换为实际的物理内存地址。</li>
<li><strong>提高内存空间：</strong>虚拟内存将程序的部分数据存储在外部硬盘上，让程序可以拥有超过系统物理内存大小的内存空间，使得大型程序的编写变得更容易</li>
<li><strong>提高内存利用率：</strong>早期计算机在运行程序的时候将程序全部装入内存，但实际上程序只需要访问一部分内存数据即可正常运行，导致内存中会存在大量暂时用不到的数据，浪费了内存资源。</li>
</ul>
</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>定义</strong>：局部性原理是指程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。局部性原理表现在以下两个方面：</p>
<ul>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ul>
<p><strong>应用</strong>：</p>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。</p>
<h4 id="虚拟内存技术实现"><a href="#虚拟内存技术实现" class="headerlink" title="虚拟内存技术实现"></a>虚拟内存技术实现</h4><ul>
<li><p><strong>请求分页存储管理</strong></p>
<p>建立在分页管理的基础上，增加了请求调页功能和页面置换功能。在请求分页存储管理系统中，在作业开始运行之前，仅装入要执行的部分页面即可运行，将暂时不要的页面存在在外部磁盘中。假如在作业运行的过程中发现要访问的页面不在内存中，操作系统需要将对应的页面从磁盘调入内存中，如果内存中没有空间了，需要使用页面置换算法来将相应的页面调入内存。</p>
</li>
<li><p><strong>请求分段存储管理</strong></p>
</li>
<li><p><strong>请求段页式存储管理</strong></p>
</li>
</ul>
<h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>可以简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>分段式管理</strong>、<strong>分页式管理</strong> 和 <strong>段页式管理</strong>。</p>
<h4 id="分段式管理"><a href="#分段式管理" class="headerlink" title="分段式管理"></a>分段式管理</h4><p><strong>定义</strong>：按照程序自身的逻辑关系将地址空间划分为若干个段，每个段有一个段名，每段从0开始编址，每个段在内存中占据连续的地址空间，但是各段之间可以不相邻。</p>
<p><strong>逻辑地址结构</strong>：由段号(段名)和段内地址(段内偏移量)所组成。段号的位数决定了每个进程最多可以分为几个段，段内地址位数决定了每个段的最大长度。</p>
<p><strong>段表</strong>：为每个进程建立的一张段映射表，将逻辑地址与物理地址映射起来。</p>
<ul>
<li>每个段对应一个段表项，其中记录了该段在内存中的起始位置(基址)和段的长度(段长)。</li>
<li>各个段表项的长度是相同的。</li>
</ul>
<img src="/D:/笔记/八股笔记.assets/image-20220528195224834.png" alt="image-20220528195224834" style="zoom: 67%;">

<p><strong>地址转换</strong>：</p>
<ul>
<li>根据逻辑地址得到段号和段内地址</li>
<li>判断段号是否越界，即若段号大于等于每个进程的最大段数，则产生越界中断</li>
<li>如果没有越界，则查询段表，找到对应的段表项，得到该段对应的基址</li>
<li>检查段内地址是否大于段长，若大于则产生越界中断</li>
<li>如果没有越界，则物理地址&#x3D;段基址+段内地址</li>
</ul>
<h4 id="分页式管理"><a href="#分页式管理" class="headerlink" title="分页式管理"></a>分页式管理</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h5><p>把内存空间分为一个个大小相等的分区，每个分区叫做一个<strong>页框</strong>，每个页框有一个编号，即<strong>页框号</strong>，页框号从0开始。将用户进程的地址空间也分为与页框大小相等的一个个区域，每个区域称为<strong>页面</strong>，每个页面也有一个编号，即<strong>页面号</strong>，页面号也是从0开始。操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，换句话说就是进程的页面与内存的页框有着一一对应的关系，各个页面不必连续存放，也不必按照先后顺序存放，可以放到不相邻的各个页框中。</p>
<img src="/D:/笔记/八股笔记.assets/image-20220524161145410.png" alt="image-20220524161145410" style="zoom: 67%;">

<h5 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h5><p>物理地址&#x3D;逻辑地址所在页号对应的起始内存地址+页内偏移量</p>
<ul>
<li><p>如何计算页号和页内偏移量：</p>
<p>页号 &#x3D; 逻辑地址&#x2F;页面长度、页内偏移量 &#x3D; 逻辑地址%页面长度</p>
</li>
<li><p>如何找到页号对应的起始内存地址：</p>
<p>操作系统为每个进程建立了一张页表，进程的每一页对应一个页表项，每个页表项由<strong>页号</strong>和<strong>页框号</strong>组成，页表记录了每个进程中页面与实际存放的内存块之间的对应关系，由于每个页表项的长度是相同的，因此页表中页号是隐含的，即第一个页表项对应第0页，第二个页表项对应第1页，以此类推。</p>
</li>
<li><p><strong>地址转换过程</strong>：</p>
<p>在系统中设置一个页表寄存器(PTR)，用来存放页表在内存中的起始地址F和页面长度M。在进程未执行时，页表的起始地址和页面长度存放在进程控制块(PCB)中，当进程被调度时，操作系统会将他们放到PTR中，那么将逻辑地址转换为物理地址的过程如下：</p>
<p>a.根据逻辑地址计算出页号与页内偏移量。</p>
<p>b.根据PTR得到页表的起始地址和页面长度，判断页号是否越界，即页号是否大于等于页面长度，如果越界则产生越界中断。</p>
<p>c.如果未越界，则查询页表得到该页号对应的页表项，从而得到对应的页框号</p>
<p>d.通过页框号和页内偏移量得到物理地址</p>
</li>
</ul>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><ul>
<li><p>为什么需要多级页表：</p>
<p>因为单级页表会占用大量的内存空间。从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址，假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了，所以页表一定要覆盖全部虚拟地址空间，假设每个进程有4GB的虚拟地址空间，每个页面大小为4KB，则不分级的页表就需要1M个页表项来映射，每个页表项占4B，即每个进程的页表大小为4MB，由于<strong>操作系统可以同时运行非常多的进程，意味着内存中有大量的空间用来存储页表，造成了内存空间的浪费。使用多级页表可以压缩页表占用的内存，有效的节约了内存空间</strong>。<strong>多级页表属于时间换空间，解决了虚拟地址空间大导致的页表占用大量内存的问题</strong>。</p>
</li>
<li><p>二级分页：</p>
<p>假设虚拟地址空间为4GB，页面大小为4KB，将上述不分级的1M个页表项先使用一个一级页表进行再分页，分为1K个一级页表项，每个一级页表下面又分为了1K个二级页表，每个一级页表项中存储的是它对应的二级页表项的首地址。</p>
<img src="/D:/笔记/八股笔记.assets/image-20220531094738155.png" alt="image-20220531094738155" style="zoom: 67%;">
</li>
<li><p><strong>二级分页为什么能节约内存</strong>：</p>
<ul>
<li><p><strong>二级页表可以不存在</strong></p>
<p>​		一级页表覆盖了整个4GB虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。</p>
</li>
<li><p><strong>二级页表可以不在主存</strong></p>
<p>​		在请求分页存储管理中，根据局部性原理，当需要用到某个页面时，将此页面从磁盘调入到内存；当内存中页面满了时，将内存中的页面调出到磁盘，由于虚拟内存地址存在着局部性，因此所有的二级页表中只会有很少的一部分在某一时刻正在使用，我们就可以把其余的二级页表放入磁盘中，在需要时才调入内存。</p>
</li>
</ul>
</li>
</ul>
<h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><ul>
<li><p>为什么引入快表：</p>
<p>在使用多级页表之后虽然解决了内存空间上的问题，但是导致虚拟地址到物理地址的转换多了几道工序，降低了虚拟地址到物理地址的转换速度，因此引入快表来加速虚拟地址到物理地址的转换。</p>
</li>
<li><p>什么是快表：</p>
<p>可以把快表理解为一种高速缓存（Cache），其中存储的是程序最常访问的几个页表项。</p>
</li>
<li><p><strong>加入快表后的地址转换流程</strong>：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
</li>
</ul>
<h4 id="分段VS分页"><a href="#分段VS分页" class="headerlink" title="分段VS分页"></a>分段VS分页</h4><p><strong>共同点</strong></p>
<p>​		分段和分页都是离散的内存管理方式，目的都是为了提高内存利用率和减少内存碎片。</p>
<p><strong>区别</strong></p>
<ul>
<li>页是信息的物理单位，分页仅仅是为了满足操作系统内存管理的需求，完全是系统行为，对用户是不可见的；而段是信息的逻辑单位，一个段通常包含着一组属于一个逻辑模块的信息，分段对用户是可见的，用户编程时需要显示地给出段名。</li>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
</ul>
<h4 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h4><p><strong>定义</strong>：先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；地址结构由<strong>段号、段内页号和页内位移</strong>三部分组成。</p>
<p><strong>地址变换：</strong></p>
<ul>
<li><p>用于段页式地址变换的数据结构：</p>
<p>每个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号。</p>
</li>
<li><p>地址变换过程：</p>
<p>第一次访问段表，得到页表起始地址；第二次访问页表，得到物理页号；第三次将物理页号与页内位移组合得到物理地址。</p>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>​		在地址映射过程中，如果所要访问的页面不在内存中，就会发生<strong>缺页中断</strong>，此时需要操作系统将要访问的页面调入主存后再进行访问。如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h4 id="常见的页面置换算法"><a href="#常见的页面置换算法" class="headerlink" title="常见的页面置换算法"></a>常见的页面置换算法</h4><p><strong>最佳页面置换算法</strong></p>
<p>​		最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</p>
<p><strong>FIFO 页面置换算法</strong></p>
<p>​		选择在内存中驻留时间最久的页面进行淘汰。</p>
<p><strong>LRU 页面置换算法</strong></p>
<p>​		赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当必须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p>
<p><strong>LFU 页面置换算法</strong></p>
<p>​		选择在之前时期使用最少的页面作为淘汰页。</p>
<h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><h3 id="微内核的特征"><a href="#微内核的特征" class="headerlink" title="微内核的特征"></a>微内核的特征</h3><ol>
<li>提供基础核心功能（支持功能和资源管理功能）</li>
<li>基于C&#x2F;S模式 （消息传递机制实现信息交互，通过调用内核提供的系统调用实现）</li>
<li>机制与策略原理 （机制区别于策略，机制在底层，策略在高层）</li>
</ol>
<h3 id="内核提供的支撑功能"><a href="#内核提供的支撑功能" class="headerlink" title="内核提供的支撑功能"></a>内核提供的支撑功能</h3><p>内核提供给OS其他服务进程（服务器）的基本功能，是其他服务进程模块功能实现的支撑</p>
<p><strong>中断处理</strong></p>
<p>中断处理是内核最基本的功能，是整个OS工作的基础，没有中断处理就没有OS的并发，CPU的中断时短暂的，在经过短暂的中断后，CPU会转入到其他进程完成工作</p>
<p><strong>时钟管理</strong></p>
<p>时间片轮转调度中，当时间片用完，时钟会触发一个中断信号，调度程序会重新进行调度</p>
<p><strong>原语操作</strong></p>
<p>要么全做，要么全不做</p>
<h3 id="内核提供的资源管理功能"><a href="#内核提供的资源管理功能" class="headerlink" title="内核提供的资源管理功能"></a>内核提供的资源管理功能</h3><p><strong>进程管理</strong></p>
<p>OS可以实现对进程的基础化管理，基础化管理功能使用频率很高</p>
<p><strong>存储器管理</strong></p>
<p>OS存储器管理相关进程的运行平吕很高，放入内核中，可以提升存储器的运行效率，提高读写速度</p>
<p><strong>设备管理</strong></p>
<p>设备管理与计算机硬件紧密相关，大部分功能都是常驻内核的</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p>
<h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p><strong>inode 是 linux&#x2F;unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux&#x2F;Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<ul>
<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<h4 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h4><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p>
<ul>
<li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li>
<li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li>
<li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li>
<li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>
<li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<h3 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h3><p>Linux 命令在线速查手册：<a target="_blank" rel="noopener" href="https://www.w3xue.com/manual/linux/">https://www.w3xue.com/manual/linux/</a> </p>
<h4 id="查看系统性能"><a href="#查看系统性能" class="headerlink" title="查看系统性能"></a><strong>查看系统性能</strong></h4><h5 id="查看内存和CPU信息"><a href="#查看内存和CPU信息" class="headerlink" title="查看内存和CPU信息"></a><strong>查看内存和CPU信息</strong></h5><p>cpu信息   cat &#x2F;proc&#x2F;cpuinfo  </p>
<p>内存信息  cat &#x2F;proc&#x2F;meminfo |grep MemTotal </p>
<p>查看物理cpu个数：cat &#x2F;proc&#x2F;cpuinfo | grep ‘physical id’ | sort | uniq | wc -l</p>
<p>查看逻辑cpu个数：cat &#x2F;proc&#x2F;cpuinfo | grep ‘processor’ | wc -l</p>
<p>查看单cpu是几核：cat &#x2F;proc&#x2F;cpuinfo | grep ‘cores’ |uniq</p>
<p>查看cpu主频：   cat &#x2F;proc&#x2F;cpuinfo | grep ‘MHz’</p>
<p>查看cpu是32位还是64位： getconf LONG_BIT、echo $HOSTTYPE、uname -a</p>
<h5 id="查看主机运行时间和Linux系统负载"><a href="#查看主机运行时间和Linux系统负载" class="headerlink" title="查看主机运行时间和Linux系统负载"></a><strong>查看主机运行时间和Linux系统负载</strong></h5><p>uptime:</p>
<p><img src="/.%5Cres%5Cwps1.jpg" alt="img"> </p>
<p>10:19:04 &#x2F;&#x2F;系统当前时间</p>
<p>up 257 days, 18:56 &#x2F;&#x2F;主机已运行时间，时间越大，说明你的机器越稳定。</p>
<p>12 user &#x2F;&#x2F;用户连接数，是总连接数而不是用户数</p>
<p>load average &#x2F;&#x2F; 系统平均负载，统计最近1，5，15分钟的系统平均负载</p>
<p>信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。系统平均负载是指在特定时间间隔内运行队列中的平均进程数。在0.00-1.00之间正常</p>
<h5 id="实时监控cpu"><a href="#实时监控cpu" class="headerlink" title="实时监控cpu"></a>实时监控cpu</h5><p>①<strong>top</strong>命令是Linux下常用的<strong>性能分析工具</strong>，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p>
<img src="https://img-blog.csdnimg.cn/20210415155339881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ2NTM5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;">

<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234603901.png" alt="image-20240118234603901"></p>
<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234700032.png" alt="image-20240118234700032"></p>
<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234714597.png" alt="image-20240118234714597"></p>
<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234801672.png" alt="image-20240118234801672"></p>
<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240118234814306.png" alt="image-20240118234814306"></p>
<p>②Vmstat是最常见的Linux&#x2F;Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。</p>
<h5 id="实时监控内存"><a href="#实时监控内存" class="headerlink" title="实时监控内存"></a>实时监控内存</h5><p>free：显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存</p>
<p>查看内存实时情况</p>
<p>free –h （以G为单位）</p>
<p>free –m （以M为单位）</p>
<p>free （以K为单位）</p>
<p>free –s 10（间隔10s刷新一次）周期性查看内存使用情况</p>
<h4 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h4><p>cd usr： 切换到该目录下usr目录</p>
<p>cd ..（或cd..&#x2F;）： 切换到上一层目录</p>
<p>cd &#x2F;： 切换到系统根目录</p>
<p>cd ~： 切换到用户主目录</p>
<p>cd -： 切换到上一个操作所在目录</p>
<h4 id="目录的操作命令（增删改查）"><a href="#目录的操作命令（增删改查）" class="headerlink" title="目录的操作命令（增删改查）"></a>目录的操作命令（增删改查）</h4><p>①mkdir 目录名称： 增加目录</p>
<p>②ls或者ll（ll是ls -l的别名，ll命令可以看到该<strong>目录下的所有目录和文件的详细信息</strong>）：查看目录信息</p>
<p>③find 目录 参数：寻找目录（查）</p>
<p>④mv 目录名称 新目录名称：修改目录的名称（改）</p>
<p>注意： mv命令用来对文件或目录<strong>重新命名</strong>，或者将文件从一个目录<strong>移到</strong>另一个目录中。</p>
<p>mv 目录名称 目录的新位置：移动目录的位置—剪切（改）</p>
<p>注意：另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
<p>⑤cp -r 目录名称 目录拷贝的目标位置：拷贝目录（改），-r代表递归拷贝</p>
<p>注意：拷贝文件和压缩包时不用写-r递归</p>
<p>⑥rm [-rf] 目录: 删除目录（删）</p>
<p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录&#x2F;文件&#x2F;压缩包</p>
<h4 id="文件的操作命令（增删改查）"><a href="#文件的操作命令（增删改查）" class="headerlink" title="文件的操作命令（增删改查）"></a>文件的操作命令（增删改查）</h4><p>①touch 文件名称: 文件的创建（增）</p>
<p>②cat&#x2F;more&#x2F;less&#x2F;tail 文件名称: 文件的查看（查）</p>
<p>cat： 查看显示文件内容</p>
<p>more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</p>
<p>less： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</p>
<p>tail-10 ： 查看文件的后10行，Ctrl+C结束</p>
<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控文件的变化</p>
<p>③vim 文件： 修改文件的内容（改）</p>
<p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p>
<p>④rm -rf 文件：删除文件（删）</p>
<h4 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h4><p>①打包并压缩文件：</p>
<p>tar -zcvf 打包压缩后的文件名 要打包压缩的文件 其中：z：调用gzip压缩命令进行压缩；c：打包文件；v：显示运行过程；f：指定文件名；</p>
<p>②解压压缩包：</p>
<p>tar [-xvf] 压缩文件</p>
<p>x：代表解压</p>
<h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>1）pwd： 显示当前所在位置</p>
<p>2）sudo + 其他命令：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
<p>3）grep 要搜索的字符串 要搜索的文件 –color： 搜索命令，–color代表高亮显示</p>
<p>4）ps -ef&#x2F;ps -aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程），也可使用 pgrep redis -a。</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
<p>5）kill -9 进程的pid：杀死进程（-9 表示强制终止）</p>
<p>先用ps查找进程，然后用kill杀掉</p>
<p>6）查看当前系统的网卡信息：ifconfig</p>
<p>7）查看与某台机器的连接情况：ping</p>
<p>8）查看当前系统的端口使用：netstat -an</p>
<p>9）net-tools 和 iproute2 ： net-tools起源于BSD的TCP&#x2F;IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。</p>
<p>10）shutdown -h now： 指定现在立即关机；</p>
<p>11）shutdown +5 “System will shutdown after 5 minutes”：指定5分钟后关机，同时送出警告信息给登入用户。</p>
<p>12）reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）</p>
<p>13）&#x2F;proc：Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储了当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态</p>
<p>14）wc：命令用于计算字数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [-clw][--help][--version][文件...]</span><br></pre></td></tr></table></figure>

<ul>
<li>-c或–bytes或–chars 只显示Bytes数。</li>
<li>-l或–lines 显示行数。</li>
<li>-w或–words 只显示字数。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> testfile testfile_1 testfile_2  <span class="comment">#统计三个文件的信息</span></span>  </span><br><span class="line">3 92 598 testfile                    #第一个文件行数为3、单词数92、字节数598  </span><br><span class="line">9 18 78 testfile_1                   #第二个文件的行数为9、单词数18、字节数78  </span><br><span class="line">3 6 32 testfile_2                    #第三个文件的行数为3、单词数6、字节数32  </span><br><span class="line">15 116 708 总用量                    #三个文件总共的行数为15、单词数116、字节数708 </span><br></pre></td></tr></table></figure>



<h3 id="Linux-IO"><a href="#Linux-IO" class="headerlink" title="Linux IO"></a>Linux IO</h3><h4 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h4><ul>
<li>阻塞 IO: 在内核将数据准备好之前, 系统调用会一直等待。所有的套接字, 默认都是阻塞方式。</li>
<li>非阻塞 IO: 如果内核还未将数据准备好, 系统调用仍然会直接返回, 并且返回 EWOULDBLOCK 错误码.非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符, 这个过程称为轮询. 这对CPU来说是较大的浪费, 一般只有特定场景下才使用.</li>
<li>信号驱动 IO: 内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作。</li>
<li>IO 多路复用: 虽然从流程图上看起来和阻塞IO类似. 实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态.</li>
<li>异步 IO: 由内核在数据拷贝完成时, 通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据).</li>
</ul>
<h4 id="IO多路复用（select、poll、epoll）"><a href="#IO多路复用（select、poll、epoll）" class="headerlink" title="IO多路复用（select、poll、epoll）"></a>IO多路复用（select、poll、epoll）</h4><ul>
<li><p>select：时间复杂度 O(n)<br>select 仅仅<strong>知道有 I&#x2F;O 事件发生</strong>，<strong>但并不知道是哪几个流</strong>，所以只能<strong>无差别轮询所有流</strong>，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<ul>
<li>内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。<ul>
<li>每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大</li>
<li>同时，每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大</li>
<li>select支持的文件描述符数量太小，默认最大支持1024个</li>
<li>主动轮询效率很低</li>
</ul>
</li>
</ul>
</li>
<li><p>poll：时间复杂度 O(n)<br>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后<strong>查询每个 fd（文件描述符） 对应的设备状态</strong>， 但是它<strong>没有最大连接数的限制</strong>，原因是它是基于链表来存储的。</p>
<ul>
<li>无最大连接数限制，因其基于链表存储，缺点：<ul>
<li>大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</li>
<li>若报告了fd后，没有被处理，则下次poll时会再次报告该fd</li>
</ul>
</li>
</ul>
</li>
<li><p>epoll：时间复杂度 O(1)<br>epoll 模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以 epoll 模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p>
<p>epoll 可以理解为 event poll，epoll <strong>会把哪个流发生了怎样的 I&#x2F;O 事件通知我们</strong>。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。</p>
</li>
</ul>
<blockquote>
<p> select，poll，epoll 都是 IO 多路复用的机制。I&#x2F;O 多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O 的实现会负责把数据从内核拷贝到用户空间。</p>
</blockquote>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>计算机网络体系可以分为三种：<strong>OSI 七层模型</strong>、<strong>OSI 五层模型</strong>、<strong>TCP&#x2F;IP四层模型</strong></p>
<ul>
<li>OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li>
<li>OSI五层模型：将上三层合并为一层，做了一定的简化</li>
<li>TCP&#x2F;IP四层模型：从实际应用中总结出来，实质上TCP&#x2F;IP主要实现上三层，底层不涉及</li>
</ul>
<img src="/./res\网络模型.png" style="zoom: 67%;">



<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><img src="/./res\osi-7-model.png" style="zoom:67%;">



<p><strong>七层网络</strong>体系结构各层的主要功能：</p>
<ul>
<li>应用层：<strong>为应用程序提供交互服务</strong>。在互联网中的应用层协议很多，如域名系统 <strong>DNS</strong>，支持万维网应用的 <strong>HTTP</strong> 协议，支持电子邮件的 <strong>SMTP</strong> 协议等。</li>
<li>表示层：主要<strong>负责数据格式的转换</strong>，如加密解密、转换翻译、压缩解压缩等。格式有，JPEG、ASCll、DECOIC、加密格式等。</li>
<li>会话层：负责<strong>在网络中的两节点之间建立、维持和终止会话</strong>，如服务器验证用户登录便是由会话层完成的。</li>
<li>传输层：向主机进程<strong>提供通用的数据传输服务</strong>。该层主要有以下两种协议：<ul>
<li><strong>TCP</strong>：提供面向连接的、可靠的数据传输服务；</li>
<li><strong>UDP</strong>：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li>
</ul>
</li>
<li>网络层：进行<strong>逻辑地址寻址</strong>，<strong>实现不同网络之间的路径选择</strong>。选择合适的路由和交换结点，确保数据及时传送协议有：ICMP IGMP <strong>IP</strong>（IPV4 IPV6） ARP RARP。</li>
<li>数据链路层：<strong>建立逻辑连接、进行硬件地址寻址、差错校验等功能。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。</strong><ul>
<li>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li>
</ul>
</li>
<li>物理层 ：实现相邻节点间<strong>比特流的透明传输</strong>，尽可能屏蔽传输介质和通信手段的差异。</li>
</ul>
<p><strong>五层模型</strong>就是将<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>合并为<strong>应用层</strong>。</p>
<p><strong>缺点：</strong>OSI 的协议实现起来<strong>过分复杂</strong>，而且<strong>运行效率很低</strong>，<strong>层次划分不太合理</strong>，有些功能在多个层次中重复出现。</p>
<h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h2><img src="/./res\封装.png" style="zoom:50%;">

<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li><strong>功能</strong></li>
</ul>
<p>​		<strong>主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输</strong>。 把应用层交互的<strong>数据单元称为报文</strong>。</p>
<ul>
<li><strong>应用层协议</strong>：HTTP：超文本传输协议，SMTP：电子邮件传输协议，FTP：文件传输协议，DNS：域名服务，Telnet：远程终端协议， WebSocket：双工通信协议</li>
<li><strong>路由</strong>：<strong>数据格式到数据格式</strong></li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul>
<li><p><strong>功能</strong></p>
<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
</li>
</ul>
<p>​		为应用层提供网络支持，作为应用间数据传输的媒介，帮助实现应用到应用的通信，但是<strong>并没有实际的传输功能</strong>。传输层的<strong>数据单元为TCP报文段（UDP数据报）</strong></p>
<ul>
<li><strong>传输层协议</strong><ul>
<li><p>TCP</p>
<ol>
<li><p>TCP 叫做传输控制协议，大部分应用使用的都是 TCP 传输层协议，TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p>
</li>
<li><p>如果应用需要传输的数据包大于MSS(TCP最大报文段长度)，需要将数据包分段，即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包，把每个分块称为一个TCP段</p>
</li>
</ol>
</li>
<li><p>UDP：叫做用户数据包协议，只负责发送数据包，不保证数据包是否能抵达对方，但它<strong>实时性相对更好，传输效率也高</strong></p>
</li>
</ul>
</li>
<li><strong>路由</strong>：<strong>应用程序到应用程序</strong>，两个地址的<strong>端口之间</strong>的通信</li>
</ul>
<h3 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h3><ul>
<li><strong>功能</strong>：<strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，<strong>网络层把传输层产生的报文段或用户数据报封装成分组和包进行传送</strong>。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 <strong>IP 数据报</strong>，简称数据报，<strong>数据单元：IP数据报</strong>。</li>
<li><strong>网络层协议</strong>：<ul>
<li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP&#x2F;IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是<strong>网络层地址和链路层地址之间的转换问题</strong>，实际上是<strong>网络层和网络接口层之间的协议</strong>。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li><strong>NAT : 网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——<strong>网络地址转换，应用于内部网到外部网的地址转换过程中</strong>。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li>
</ul>
</li>
<li><strong>路由</strong>：<strong>网络地址到网络地址</strong>，信源到信宿，两个网络地址之间的通信</li>
</ul>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><ul>
<li><strong>功能</strong>：网络接口层负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。网络接口层的<strong>数据单元为以太网帧</strong>。</li>
<li><strong>MAC地址</strong>：网络层生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>在 IP 头部的前面加上 MAC 头部，并封装成<strong>数据帧（Data frame）</strong>发送到网络上。以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。</li>
<li><strong>路由</strong>：<strong>物理机到物理机</strong>，网络硬件设备使用的网络物理地址，路途上每个区间的起点和终点</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p><strong>IP的作用</strong>：网络层主要作用是实现主机与主机之间的通信，IP 的作用是在复杂的网络环境中将数据包发送给目的主机。</p>
</li>
<li><p><strong>网络层 (IP) 与网络接口层 (MAC) 的区别</strong>：MAC 的作用是实现「直连」的两个设备之间通信， IP 负责在「没有直连」的两个网络之间通信。即 MAC 只负责某一个区间之间的通信传输，而 IP 负责将数据包发送给最终的目的地址，<strong>源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。</strong></p>
<img src="/./res\image-20220812082433369.png" alt="image-20220812082433369" style="zoom: 33%;"></li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><pre><code>    IP地址(IPv4)由32位二进制来表示，为了方便记忆采用点分十进制的表示方式，将 32 位 IP 地址以每 8 位为组，共分为 `4` 组，每组以「`.`」隔开，再将每组转换成十进制。所以IP地址最大值为 2^32 = 4294967296
</code></pre>
<img src="/./res\image-20220812083108967.png" alt="image-20220812083108967" style="zoom: 33%;">



<h4 id="分类地址"><a href="#分类地址" class="headerlink" title="分类地址"></a>分类地址</h4><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><ul>
<li><strong>定义：</strong>ARP协议是Address Resolution Protocol的缩写，翻译过来也就是地址解析协议，它是根据IP地址获取物理地址(MAC)的一个TCP&#x2F;IP协议</li>
<li><strong>原理</strong><ul>
<li>在源IP地址向目的IP地址发送数据时，IP数据报总是需要知道下一跳（物理上的下一个目的地）该去往何处。所以要先根据主机的路由表确定数据下一个路由器的IP地址，然后通过ARP协议获取对应的MAC地址，ARP协议是借助ARP请求和ARP响应来确定MAC地址的</li>
<li>首先主机会通过广播发送ARP请求，这个包中包含了想要知道MAC地址的主机IP地址，当同个链路中的所有设备收到 ARP 请求时，如果其目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机。</li>
<li>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</li>
</ul>
</li>
<li><strong>安全性</strong><ul>
<li><strong>ARP欺骗</strong>：ARP协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。</li>
<li><strong>ARP泛洪攻击</strong>：如果攻击者发送大量伪造的 ARP 应答报文，造成主机 ARP 表项溢出，导致无法缓存正常的 ARP 表项，从而影响报文的正常转发，这就是大名鼎鼎的拒绝服务攻击（DDoS）或 ARP 泛洪攻击。会导致网络不稳定、断网、信息泄漏等</li>
<li><strong>解决方案：</strong>安装 ARP 防火墙或者自己手动绑定局域网 IP 和 MAC 的映射关系</li>
</ul>
</li>
</ul>
<h4 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h4><ul>
<li><p><strong>功能</strong>：ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>。在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能达到目标地址，那么这个具体的原因将<strong>由 ICMP 负责通知</strong>。其功能就是<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
</li>
<li><p><strong>ICMP包头格式</strong>：ICMP报文是封装在IP包里面，它工作在网络层</p>
<img src="/D:/笔记/八股笔记.assets/image-20220812091906508.png" alt="image-20220812091906508" style="zoom: 50%;">
</li>
<li><p><strong>ICMP类型</strong></p>
<ul>
<li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li>
<li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」</li>
</ul>
</li>
<li><p><strong>查询报文类型</strong>：查询消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息实现的。通过向目标主机发送回送请求消息，然后接收目标主机发回来的回送应答消息，可以判断发送主机与目标主机之间可否可达。</p>
<ul>
<li><strong>标识符：</strong>用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li>
<li><strong>序号：</strong>序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li>
<li><strong>选项数据：</strong><code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短</li>
</ul>
</li>
<li><p><strong>差错报文类型</strong></p>
</li>
</ul>
<h4 id="PING工作原理"><a href="#PING工作原理" class="headerlink" title="PING工作原理"></a>PING工作原理</h4><pre><code>    ping本质上使用了ICMP的查询报文来判断发送主机与目标主机之间可否可达。以局域网内两个主机A(192.168.1.1)和B(192.168.1.2)为例，其发送和接收过程如下：
</code></pre>
<ul>
<li>ping命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包，为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</li>
<li>由 ICMP 协议将这个<strong>数据包连同地址</strong> 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，再加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</li>
<li>通过ARP协议获取对应的MAC地址，由网络接口层构建成一个数据帧发送出去</li>
<li>目标主机接收到数据帧后，将 IP 数据包从帧中提取出来，交给本机的 IP 层。IP 层检查后，将有用的信息提取后交给 ICMP 协议。</li>
<li>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包再发送给主机 A。</li>
<li>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</li>
</ul>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="头部格式"><a href="#头部格式" class="headerlink" title="头部格式"></a>头部格式</h4><img src="/./res\image-20230412140211742.png" style="zoom:50%;">



<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><h5 id="1-三次握手详解"><a href="#1-三次握手详解" class="headerlink" title="1.  三次握手详解"></a>1.  三次握手详解</h5><img src="/./res\三次握手.png" style="zoom: 33%;">



<ul>
<li><p>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</p>
</li>
<li><p><strong>第一次握手：</strong>客户端会随机初始化序列号 <code>client_isn</code>，将此序列号置于 TCP 首部的「<strong>序列号</strong>」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> <strong>同步</strong>报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</p>
</li>
<li><p><strong>第二次握手：</strong>服务端收到客户端的 <code>SYN</code> 报文后，服务端也会随机初始化自己的序列号 <code>server_isn</code> ，并将此序列号填入 TCP 首部的「<strong>序列号</strong>」字段中，其次把 TCP 首部的「<strong>确认应答号</strong>」字段填入 <code>client_isn + 1</code>，接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</p>
</li>
<li><p><strong>第三次握手：</strong>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</p>
</li>
<li><p>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</p>
</li>
</ul>
<p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p>
<blockquote>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
</blockquote>
<h5 id="2-为什么是三次握手？"><a href="#2-为什么是三次握手？" class="headerlink" title="2. 为什么是三次握手？"></a>2. 为什么是三次握手？</h5><p>为什么选择三次：</p>
<ul>
<li>三次握手才可以<strong>阻止重复历史连接的初始化</strong>（主要原因）</li>
<li>三次握手才可以<strong>同步双方的初始序列号</strong></li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<p><strong>避免历史连接</strong>——客户端连续发送多次 SYN 建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li>
</ul>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，因为<strong>在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费</strong>。</p>
<p>服务端收到旧的SYN报文后就进入了<code>ESTABLISHED</code> 状态，说明此时服务端可以向客户端发送数据，直到客户端收到服务器回传的报文，发现这是个历史连接并中止此次连接。因此在两次握手的情况下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，并发送了无效数据。</p>
<p><strong>同步双方初始序列号</strong>——序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以<strong>去除重复</strong>的数据；</li>
<li>接收方可以根据数据包的序列号<strong>按序接收</strong>；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当<strong>服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应</strong>，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p><strong>避免资源浪费</strong></p>
<p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ；过了一段时间，客户端的<code>SYN</code> 请求到达了，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<blockquote>
<p>很多人问，两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？</p>
<p>我这里两次握手是假设「由于没有第三次握手，<strong>服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认报文</strong>，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接」这个场景。</p>
<p>当然你要实现成类似三次握手那样，根据上下文丢弃 syn 历史报文也是可以的，两次握手没有具体的实现，怎么假设都行。</p>
</blockquote>
<p><strong>为什么不是四次呢？</strong></p>
<p>因为<strong>三次握手已经可以确认双方的发送接收能力正常</strong>，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>
<ul>
<li><strong>第一次握手</strong>：服务端确认“自己收、客户端发”报文功能正常。</li>
<li><strong>第二次握手</strong>：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li>
<li><strong>第三次握手</strong>：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li>
</ul>
<h5 id="3-初始化的序列号"><a href="#3-初始化的序列号" class="headerlink" title="3. 初始化的序列号"></a>3. 初始化的序列号</h5><p><strong>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</strong></p>
<p>主要原因有两个方面：</p>
<ul>
<li><p><strong>为了防止历史报文被下一个相同四元组的连接接收</strong>（主要方面）；</p>
<ul>
<li>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的<strong>连接就消失</strong>了，于是在收到客户端的数据包的时候就会发送 <strong>RST 报文</strong>。</li>
<li>紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；</li>
<li>在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li>
</ul>
<p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，就有大概率因为历史报文的序列号「不在」对方接收窗口，从而<strong>很大程度</strong>上避免了历史报文</p>
</li>
<li><p>为了安全性，<strong>防止黑客伪造的相同序列号的 TCP 报文被对方接收</strong>；</p>
</li>
</ul>
<p><strong>初始序列号 ISN 是如何随机产生的？</strong></p>
<p>起始 <code>ISN</code> 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<h5 id="4-握手丢失会怎么样？"><a href="#4-握手丢失会怎么样？" class="headerlink" title="4. 握手丢失会怎么样？"></a>4. 握手丢失会怎么样？</h5><p>重传机制</p>
<ol>
<li><p>第一次握手：<strong>重传 SYN 报文</strong>,<code>tcp_syn_retires</code> 的参数来限制第一次握手的重传次数，<strong>默认为5次</strong>。</p>
<blockquote>
<p>当客户端想发送 SYN 报文，然后进入到 <code>SYN_SENT</code> 状，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发<strong>「超时重传」</strong>机制，重传 SYN 报文。</p>
<p><strong>超时时间</strong>：</p>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p><strong>重传次数</strong>：</p>
<blockquote>
<p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p>
</blockquote>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 &#x3D;&#x3D;<code>tcp_syn_retries</code>&#x3D;&#x3D;内核参数控制，这个参数是可以自定义的，<strong>默认值一般是 5</strong>。</p>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p>
</blockquote>
</li>
<li><p>第二次握手：<strong>客户端重传 SYN 报文</strong>，<strong>服务端重传 SYN-ACK 报文</strong>， tcp_synack_retires的参数来限制第二次握手（ack+syn包）的重传次数，<strong>默认为5次</strong>。</p>
<blockquote>
<p>当服务端收到客户端的第一次握手后，就会回 <code>SYN-ACK</code> 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<blockquote>
<p> 第二次握手的 <code>SYN-ACK</code> 报文其实有两个目的 </p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
</blockquote>
<ul>
<li><p><strong>客户端重传 SYN 报文</strong></p>
<p>第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
</li>
<li><p><strong>服务端重传 SYN-ACK 报文</strong></p>
<p>因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>第三次握手： <strong>服务端重传 SYN-ACK 报文</strong>，因为ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</p>
<blockquote>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<ul>
<li><p><strong>服务端重传 SYN-ACK 报文</strong></p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
</li>
</ul>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
</blockquote>
</li>
</ol>
<p><strong>tcp_retries2</strong> :<strong>客户端发送了数据包</strong>，一直没有收到服务端对该数据包的确认报文，则会一直重传该数据包，直到**重传次数超过 tcp_retries2 值（默认值 15 次）*<em>后，客户端就会*<em>断开 TCP 连接。</em></em></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h5 id="1-四次挥手详解"><a href="#1-四次挥手详解" class="headerlink" title="1. 四次挥手详解"></a>1. 四次挥手详解</h5><img src="/./res\四次挥手.png" style="zoom: 50%;">

<ul>
<li><strong>第一次挥手</strong>：客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li><strong>第二次挥手</strong>：服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li><strong>第三次挥手</strong>：等待服务端处理完数据后，就会向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li><strong>第四次挥手</strong>：客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态。服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code>（最长报文段寿命） 后，也进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<h5 id="2-为什么是四次挥手？"><a href="#2-为什么是四次挥手？" class="headerlink" title="2. 为什么是四次挥手？"></a>2. 为什么是四次挥手？</h5><p><strong>服务器在收到客户端的 FIN 报文段后，服务端可能还有数据需要处理和发送，</strong>所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<h5 id="3-挥手丢失会怎么样？"><a href="#3-挥手丢失会怎么样？" class="headerlink" title="3. 挥手丢失会怎么样？"></a>3. 挥手丢失会怎么样？</h5><ol>
<li><p>第一次挥手：<strong>客户端重传 FIN 报文</strong></p>
<blockquote>
<p><strong>客户端重传 FIN 报文</strong>：</p>
<p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code>状态。</p>
<p>如果第一次挥手丢失了，那么<strong>客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文</strong>，<strong>重发次数由 <code>tcp_orphan_retries</code> 参数控制</strong>。当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，直接进入到 <code>close</code> 状态。</p>
</blockquote>
</li>
<li><p>第二次挥手：<strong>客户端重传 FIN 报文</strong>：</p>
<blockquote>
<p><strong>客户端重传 FIN 报文</strong>：</p>
<p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，<strong>ACK 报文是不会重传的</strong>，所以如果<strong>服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文</strong>，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
</blockquote>
</li>
<li><p>第三次挥手：<strong>服务端重发 FIN 报文</strong>：</p>
<blockquote>
<p><strong>服务端重发 FIN 报文</strong>：</p>
<p>当服务端第二次挥手后处于 <code>CLOSE_WAIT</code> 状态，等待应用进程调用 close 函数关闭连接。</p>
<p>内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p>
<p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retrie</code>s 参数控制，这<strong>与客户端重发 FIN 报文的重传次数控制方式是一样的</strong>。</p>
</blockquote>
</li>
<li><p>第四次挥手：<strong>服务端重发 FIN 报文</strong>：</p>
<blockquote>
<p><strong>服务端重发 FIN 报文</strong>：</p>
<p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p>
<p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
</blockquote>
</li>
</ol>
<p><strong>重发次数由 <code>tcp_orphan_retries</code> 参数控制</strong>，默认是7。sysctl_tcp_orphan_retries 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成)。</p>
<h5 id="4-TCP-关闭连接的方式和区别"><a href="#4-TCP-关闭连接的方式和区别" class="headerlink" title="4. TCP 关闭连接的方式和区别"></a>4. TCP 关闭连接的方式和区别</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41950508/article/details/125829221?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125829221-blog-123183858.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-125829221-blog-123183858.pc_relevant_aa&utm_relevant_index=2">【网络编程】双向的TCP如何关闭？close ？shutdown？_</a></p>
<p>客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p>
<ul>
<li>对于 <strong>close 函数</strong>关闭的连接，由于<strong>无法再发送和接收数据</strong>，所以<code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。这意味着对于调用 close 关闭的连接，如果<strong>在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭</strong>。</li>
<li>如果主动关闭方使用 <strong>shutdown 函数</strong>关闭连接，指定了<strong>只关闭发送方向，而接收方向并没有关闭</strong>，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么<strong>主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态</strong>（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）</li>
</ul>
<p><strong>close关闭的是读和写两个方向的传送，当一方完成了数据传送，但是另一方仍然有数据需要传送的时候，需要使用shutdown来达到半关闭的状态,使得对方的数据能够正确到达。</strong></p>
<h5 id="5-TIME-WAIT-状态"><a href="#5-TIME-WAIT-状态" class="headerlink" title="5.  TIME-WAIT 状态"></a>5.  TIME-WAIT 状态</h5><p>主动关闭方在收到被动关闭方的 FIN 报文并返回 ACK 后，会进入 TIME_WAIT 状态，TIME_WAIT 状态又称 2MSL 状态，MSL 指最大报文段生存时间，在网络传输中超过这个时间的报文段将被丢弃。在 TIME_WAIT 状态停留 2MSL 时间，可以保证旧连接的四元组（客户端 IP 地址、端口号、服务器 IP 地址、端口号）从网络中消失，防止历史连接中的数据被后面相同四元组的连接错误接收。</p>
<p><strong>为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</strong></p>
<p>TIME-WAIT (2MSL 状态) 存在主要有两个原因：</p>
<ul>
<li><p><strong>防止历史连接中的数据，被后面相同四元组的连接错误的接收</strong></p>
<p>确保主动关闭方的最后的ACK可以达到对端。如果客户端直接CLOSED，然后又再向服务端发起一个新连接，假设新连接和已经关闭的老连接端口号是一样的，且前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达服务端，由于新连接和老连接的四元组是相同的，TCP协议会认为那些延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接需要TIME_WAIT状态且等待时间为2MSL，这样可以保证历史连接的所有数据都从网络中消失。</p>
</li>
<li><p><strong>保证「被动关闭连接」的一方，能被正确的关闭</strong><br>第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超<br>时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN 报文，然后客户端重传一<br>次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</p>
</li>
</ul>
<p>为什么要等待2MSL：</p>
<ul>
<li>一个<code>MSL</code>是确保主动关闭方最后的<code>ACK</code>能够到达对端。</li>
<li>一个<code>MSL</code>是确保被动关闭方重发的<code>FIN</code>能够被主动关闭方收到。</li>
</ul>
<p><strong>TIME-WAIT 状态过多会产生什么后果？怎样处理？</strong></p>
<p>危害：</p>
<ul>
<li><p>从<strong>服务器</strong>来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，<strong>会占用系统资源</strong>，比如文件描述符、内存资源、CPU 资源、线程资源等，此时部分客户端就会显示连接不上。<strong>但并不会导致端口资源受限，因为服务端只监听一个端口</strong>，会占用系统资源。</p>
</li>
<li><p>从<strong>客户端</strong>来讲，客户端TIME_WAIT过多，就会导致<strong>端口资源被占用</strong>，因为端口就65536个，被占满就会导致无法创建新的连接。</p>
</li>
</ul>
<p>解决办法：</p>
<ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
<p><strong>如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p>
<p>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</p>
<p><strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse <span class="operator">=</span> <span class="number">1</span> 表示开启重用。允许将<span class="type">TIME</span><span class="operator">-</span>WAIT sockets重新用于新的TCP连</span><br><span class="line">接，默认为<span class="number">0</span>，表示关闭；</span><br></pre></td></tr></table></figure>

<p><strong>说明：如果使用tcp_tw_reuse，请激活tcp_timestamps，否则无效。</strong>打开对 TCP 时间戳的支持，即</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=1（默认即为 1）</span><br></pre></td></tr></table></figure>

<p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<blockquote>
<p><strong>net.ipv4.tcp_tw_recycle</strong></p>
<p>net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<br>0，表示关闭。</p>
<p>net.ipv4.tcp_tw_recycle &#x3D; 0 （不要开启，现在互联网NAT结构很多，可能直接无法三次握手）</p>
</blockquote>
<p><strong>方式二：net.ipv4.tcp_max_tw_buckets</strong></p>
<p>这个值默认为 18000，<strong>当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置</strong>，这个方法比较暴力。</p>
<p><strong>方式三：程序中使用 SO_LINGER</strong></p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">so_linger</span>;</span></span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">0</span>;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="keyword">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure>

<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么<strong>调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭</strong>。</p>
<p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<p>linger  英&#x2F; ˈlɪŋɡə(r) 缓慢消失</p>
<h4 id="连接故障"><a href="#连接故障" class="headerlink" title="连接故障"></a>连接故障</h4><h5 id="客户端出现故障"><a href="#客户端出现故障" class="headerlink" title="客户端出现故障"></a>客户端出现故障</h5><p>TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒发送一个探测报文段，若一连发送 9个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75  </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure>

<ul>
<li>tcp_keepalive_time&#x3D;7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制；</li>
<li>tcp_keepalive_intvl&#x3D;75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes&#x3D;9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>
<img src="/./res\format,png" alt="img" style="zoom:50%;">



<p>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<ul>
<li>第一种，<strong>对端程序是正常工作的</strong>。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>第二种，<strong>对端程序崩溃并重启</strong>。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li>
<li>第三种，<strong>是对端程序崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
</ul>
<h5 id="服务端进程崩溃"><a href="#服务端进程崩溃" class="headerlink" title="服务端进程崩溃"></a>服务端进程崩溃</h5><ol>
<li>我自己做了个实验，使用 kill -9 来模拟<strong>进程崩溃</strong>的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。</li>
<li>服务器<strong>主机崩溃</strong><br>客户端在给服务器发送数据时，由于收不到服务器端回传的ACK确认报文，正常情况下，客户端TCP均会进行超时重传，<del>一般为重传12次大约9分钟后才放弃重传</del>，并关闭客户端TCP链接。</li>
<li>服务器<strong>主机崩溃后重启</strong><br>如果服务器主机在崩溃重启的这段时间里，客户端没有向服务器发送数据，即客户端没有因重传次数超过限制关闭TCP链接。则在服务器重启后，当客户端再向服务器发送TCP报文时，由于<strong>服务器中的TCP链接已经关闭，会直接向客户端回复RST报文</strong>，客户端在接收RST报文后关闭自己的TCP链接。</li>
</ol>
<h5 id="客户端拔掉网线"><a href="#客户端拔掉网线" class="headerlink" title="客户端拔掉网线"></a>客户端拔掉网线</h5><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。</p>
<p><strong>有数据传输</strong>的情况：</p>
<ul>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端<strong>重传次数没有达到最大值之前，客户端就插回了网线，</strong>那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。</li>
<li>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端<strong>重传次数达到了最大值时</strong>，<strong>服务端就会断开 TCP 连接</strong>。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 <strong>RST 报文</strong>，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。（<strong>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传</strong>。）</li>
</ul>
<p><strong>没有数据传输</strong>的情况：</p>
<ul>
<li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li>
<li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li>
</ul>
<p>除了客户端拔掉网线的场景，还有客户端「宕机和进程崩解」的两种场景。</p>
<ul>
<li><p><strong>客户端宕机：</strong>这件事跟拔掉网线是一样无法被服务端的感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</p>
</li>
<li><p><strong>客户端的进程崩解</strong>后，客户端的内核就会向服务端发送 FIN 报文，<strong>与服务端进行四次挥手</strong>。</p>
<p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
</li>
</ul>
<h4 id="TCP保证可靠传输"><a href="#TCP保证可靠传输" class="headerlink" title="TCP保证可靠传输"></a>TCP保证可靠传输</h4><p>TCP主要提供了检验和、序列号&#x2F;确认应答、超时重传、滑动窗口、拥塞控制、流量控制等方法实现可靠性传输。</p>
<ul>
<li><strong>序列号</strong>：序列号的作用不仅仅是应答，可以根据序列号对接收到的数据排序，并去掉序列号重复的数据。</li>
<li><strong>校验和</strong>：通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。<strong>发送方</strong>：在发送数据之前计算校验和，并进行校验和的填充。<strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。</li>
<li><strong>滑动窗口</strong>：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</li>
<li><strong>超时重传</strong>：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</li>
<li><strong>拥塞控制</strong>：在数据传输过程中，如果因为网络状态造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</li>
<li><strong>流量控制</strong>：<strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止包丢失。</strong>如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，<br>若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效<br>率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的<br>数据量。流量控制与TCP协议报头中的窗口大小有关。<strong>TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</strong></li>
<li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。自动重传请求（Automatic Repeat-reQuest）</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul>
<li><p><strong>提出背景</strong>：TCP 是每发送一个数据，都要进行一次确认应答。如果当上一个数据包收到了应答了， 再发送下一个，<strong>通信的效率比较低</strong>。</p>
</li>
<li><p><strong>窗口定义：</strong>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
</li>
<li><p><strong>窗口大小</strong>：窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。<strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong>通常窗口的大小是<strong>由接收方的窗口大小</strong>来决定的。</p>
</li>
<li><p><strong>累计确认（累计应答）：</strong>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
</li>
</ul>
<img src="/./res\15.jpg" alt="15" style="zoom:50%;">

<h5 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h5><ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
<img src="/./res\19.jpg" alt="SND.WND、SND.UN、SND.NXT" style="zoom: 67%;">

<ul>
<li><p><code>SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</p>
</li>
<li><p><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</p>
</li>
<li><p><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</p>
</li>
<li><p>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</p>
</li>
</ul>
<p>那么可用窗口大小的计算就可以是：</p>
<p><strong>可用窗口大 &#x3D; SND.WND -（SND.NXT - SND.UNA）</strong></p>
<h5 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h5><ul>
<li>#1 + #2 是<strong>已成功接收并确认</strong>的数据（等待应用进程读取）；</li>
<li>#3 是<strong>未收到数据但可以接收</strong>的数据；</li>
<li>#4 <strong>未收到数据并不可以接收</strong>的数据；</li>
</ul>
<img src="/D:/笔记/八股笔记.assets/20.jpg" alt="接收窗口" style="zoom: 67%;">

<p>其中三个接收部分，使用两个指针进行划分:</p>
<ul>
<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>
<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<h6 id="接受窗大小≈发送窗大小"><a href="#接受窗大小≈发送窗大小" class="headerlink" title="接受窗大小≈发送窗大小"></a>接受窗大小≈发送窗大小</h6><p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并<strong>不是一成不变的</strong>。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
<h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>①<strong>定义</strong>：在发送数据时，<strong>设定一个定时器</strong>，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p><strong>②发生条件：</strong>TCP 会在以下两种情况<strong>发生超时重传</strong>：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p>③<strong>超时重传时间：</strong></p>
<p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p>
<p><code>RTT</code>（Round-Trip Time 往返时延）：<strong>数据发送时刻到接收到确认的时刻的差值</strong>，也就是<strong>报文的往返时间</strong>。</p>
<p>超时重传时间 <code>RTO</code> （Retransmission Timeout 超时重传时间）：</p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，降低了网络传输效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>④<strong>超时重发的数据，再次超时</strong>：</p>
<p><strong>超时间隔加倍。</strong>也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔<strong>设为先前值的两倍</strong>。两次超时，就说明网络环境差，不宜频繁反复发送。</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p><strong>①定义</strong>：TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p><strong>②发生条件</strong>：<strong>发送方收到三个相同的ACK，就会触发重传机制。</strong></p>
<img src="/./res\10.jpg" alt="快速重传机制" style="zoom:50%;">

<p><strong>③问题：</strong>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p>
<p>举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p>
<ul>
<li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。</li>
<li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</li>
</ul>
<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<h5 id="SACK方法"><a href="#SACK方法" class="headerlink" title="SACK方法"></a>SACK方法</h5><p><code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p>
<p><strong>定义：</strong>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）</p>
<h5 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h5><p>为了更好的反应网络情况，RFC 2883在SACK选项的基础上提出了D-SACK（即Duplicate SACK）</p>
<p><strong>定义：</strong>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><ul>
<li><p><strong>背景</strong>：发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
</li>
<li><p><strong>定义</strong>：<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，TCP 利用滑动窗口实现流量控制</strong>。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
</li>
</ul>
<h5 id="减少缓存和收缩窗口"><a href="#减少缓存和收缩窗口" class="headerlink" title="减少缓存和收缩窗口"></a>减少缓存和收缩窗口</h5><p><strong>TCP 不允许减少缓存的同时收缩窗口，而是先收缩窗口，过段时间再减少缓存，这样可以避免丢包</strong></p>
<h5 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h5><p>定义：<strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<ul>
<li><strong>窗口关闭潜在的危险</strong>：</li>
</ul>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致<strong>发送方一直等待接收方的非 0 窗口通知</strong>，<strong>接收方也一直等待发送方的数据</strong>，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<ul>
<li><strong>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</strong></li>
</ul>
<p>TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <strong><code>RST</code> 报文</strong>来中断连接</p>
<h5 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h5><p><strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p>
<p>我们的 <code>TCP + IP</code> 头有 <code>40</code> 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p>
<p>糊涂窗口综合症的现象是可以发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>而发送方可以发送小数据</li>
</ul>
<p>要<strong>解决</strong>糊涂窗口综合症，：</p>
<ul>
<li><p>让接收方不通告小窗口给发送方</p>
<p>当「窗口大小」小于 min( MSS，缓存空间&#x2F;2 ) ，也就是小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 &gt;&#x3D; MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
</li>
<li><p>让发送方避免发送小数据</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才能可以发送数据：</p>
<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; <code>MSS</code> 和 数据大小 &gt;&#x3D; <code>MSS</code>；</li>
<li>条件二：收到之前发送数据的 <code>ack</code> 回包；</li>
</ul>
</li>
</ul>
<p><strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li><strong>背景</strong>：流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</li>
<li><strong>定义</strong>：避免「发送方」的数据填满整个网络。<strong>TCP 发送方</strong>会维持一个 <strong>拥塞窗口(cwnd)<strong>的状态变量，它会根据</strong>网络的拥塞程度动态变化</strong>的。加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</li>
</ul>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，那么就由小到大逐渐增大拥塞窗口，</p>
<p>cwnd 初始值为 1，<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1，</strong>每经过一个传播轮次就加倍，<strong>指数增长</strong>。同时有一个<strong>慢启动门限 <code>ssthresh</code></strong> （slow start threshold）状态变量，当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法；当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」</p>
<img src="/./res\27.jpg" alt="27" style="zoom: 50%;">

<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，每经过一个往返时间 RTT 就把发送方的cwnd 加 1。可以发现拥塞避免算法就是将原本慢启动算法的指数增长变成了<strong>线性增长</strong>，还是增长阶段，但是增长速度缓慢了一些。</p>
<img src="/./res\28.jpg" alt="28" style="zoom:50%;">

<h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：<strong>超时重传</strong>和<strong>快速重传</strong>。这两种使用的算法是不同的：</p>
<ul>
<li><strong>超时重传</strong>：<code>ssthresh</code> 设为 <code>cwnd/2</code>，<code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）。慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，<strong>会造成网络卡顿</strong>。</li>
</ul>
<img src="/./res\29.jpg" alt="29" style="zoom:50%;">

<ul>
<li><p><strong>快速重传</strong>：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分， <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：<code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;<code>ssthresh = cwnd</code>，并进入快速恢复算法</p>
</li>
</ul>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>快速重传和快速恢复算法一般同时使用，快速恢复算法认为还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<img src="/./res\拥塞发生-快速重传.drawio.png" alt="拥塞发生-快速重传.drawio" style="zoom:50%;">



<h4 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列；服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK；</li>
<li>全连接队列，也称 Accept 队列；服务端收到第三次握手的 ACK 后，<strong>内核会把半连接队列中的连接移除，并创建新的全连接添加到 accept 队列中，然后等待进程调用 accept 函数时把连接取出来。</strong></li>
</ul>
<p>半连接队列和全连接队列都有最大长度限制，超过限制时内核会直接丢弃，<strong>或返回 RST 包</strong>。</p>
<img src="/./res\3.jpg" alt="半连接队列与全连接队列" style="zoom: 33%;">

<h5 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h5><h6 id="队列大小"><a href="#队列大小" class="headerlink" title="队列大小"></a>队列大小</h6><p><strong>①TCP 全连接队列的最大值sk_max_ack_backlog 取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)</strong></p>
<ul>
<li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li>
<li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li>
</ul>
<p><strong>②怎么查看全连接队列大小</strong></p>
<p>在服务端可以使用 <code>ss</code> 命令，来查看 TCP 全连接队列的情况：</p>
<p>Recv-Q 表示 <strong>receive queue 中的 bytes 数量</strong>；Send-Q 表示 send queue 中的 bytes 数值。</p>
<ul>
<li><p>在「LISTEN 状态」时</p>
<ul>
<li>Recv-Q：当前全连接队列的大小，也就是当前已完成三次握手并等待服务端 <code>accept()</code> 的 TCP 连接</li>
<li>Send-Q：当前全连接最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务，最大全连接长度为 128</li>
</ul>
</li>
<li><p>「非 LISTEN 状态」时</p>
<ul>
<li>Recv-Q：已收到但未被应用进程读取的字节数；</li>
<li>Send-Q：已发送但未收到确认的字节数；</li>
</ul>
</li>
</ul>
<h6 id="队列已满的回应策略"><a href="#队列已满的回应策略" class="headerlink" title="队列已满的回应策略"></a>队列已满的回应策略</h6><p><strong>tcp_abort_on_overflow</strong> 共有两个值分别是 0 和 1，其分别表示：</p>
<ul>
<li><p>0(默认) ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；</p>
</li>
<li><p>1 ：如果全连接队列满了，server 发送一个 <code>reset</code> 包给 client，表示废掉这个握手过程和这个连接；</p>
</li>
<li><p>tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。</p>
<p>当 TCP 全连接队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次<strong>重发</strong>。如果服务器上的进程只是<strong>短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。</strong></p>
</li>
<li><p>如果要想知道<strong>客户端连接不上服务端</strong>，<strong>是不是服务端 TCP 全连接队列满的原因</strong>：</p>
<p>那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 <code>connection reset by peer</code> 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。</p>
</li>
</ul>
<h5 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h5><p><strong>①半连接队列大小</strong></p>
<h6 id="队列大小-1"><a href="#队列大小-1" class="headerlink" title="队列大小"></a>队列大小</h6><p>服务端处于 <code>SYN_RECV</code> 状态的 TCP 连接，就是 TCP 半连接队列。</p>
<ul>
<li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li>
<li>当 max_syn_backlog &lt;&#x3D; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li>
</ul>
<p>max_qlen_log 是<strong>理论</strong>半连接队列最大值，并不一定代表服务端处于 SYN_REVC 状态的最大个数。</p>
<p><strong>②如何查看半连接队列长度？</strong></p>
<img src="/./res\21.jpg" alt="img" style="zoom: 33%;">

<p>wc -l   显示行数。</p>
<p>netstat：显示网络状态</p>
<h6 id="TCP-第一次握手（收到-SYN-包）时会被丢弃的三种条件"><a href="#TCP-第一次握手（收到-SYN-包）时会被丢弃的三种条件" class="headerlink" title="TCP 第一次握手（收到 SYN 包）时会被丢弃的三种条件"></a>TCP 第一次握手（收到 SYN 包）时会被丢弃的三种条件</h6><ol>
<li><strong>如果半连接队列满了，并且没有开启 tcp_syncookies，则会丢弃；</strong></li>
<li><strong>若全连接队列满了，<del>且没有重传 SYN+ACK 包的连接请求多于 1 个</del>，则会丢弃；</strong></li>
<li><strong>如果没有开启 tcp_syncookies，并且 max_syn_backlog 减去 当前半连接队列长度小于 (max_syn_backlog &gt;&gt; 2)，则会丢弃；</strong></li>
</ol>
<p>假设条件 1 当前半连接队列的长度 「没有超过」理论的半连接队列最大值 max_qlen_log，那么如果条件 3 成立，则依然会丢弃 SYN 包，也就会使得服务端处于 SYN_REVC 状态的最大个数不会是理论值 max_qlen_log。</p>
<h6 id="syncookies"><a href="#syncookies" class="headerlink" title="syncookies"></a>syncookies</h6><ul>
<li><p><strong>如果 SYN 半连接队列已满，只能丢弃连接吗？</strong></p>
<p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</p>
</li>
<li><p><strong>实现：</strong>服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。</p>
</li>
</ul>
<img src="/./res\39.jpg" alt="开启 syncookies 功能" style="zoom:50%;">

<p>syncookies 参数主要有以下三个值：</p>
<ul>
<li>0 值，表示关闭该功能；</li>
<li>1 值，表示仅当 SYN 半连接队列放不下时，再启用它；</li>
<li>2 值，表示无条件开启功能；</li>
</ul>
<p>那么在应对 SYN 攻击时，只需要设置为 1 即可：</p>
<img src="/./res\40.jpg" alt="img" style="zoom: 33%;">

<h5 id="syn洪泛攻击"><a href="#syn洪泛攻击" class="headerlink" title="syn洪泛攻击"></a>syn洪泛攻击</h5><p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><ul>
<li>在三次握手过程中，服务器发送<code>[SYN/ACK]</code>包（第二个包）之后、收到客户端的 <code>[ACK] </code>包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 SYN_RECV （等待客户端响应）状态。如果接收到客户端的<code> [ACK]</code> ，则 TCP 连接成功，如果未接受到，则会不断重发请求直至成功。</li>
<li>SYN 攻击的攻击者在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复<code>[SYN/ACK]</code>包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li>
<li>这些伪造的 <code>[SYN] </code>包将长时间占用半连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li>
</ul>
<p><strong>检测：</strong>当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次SYN 攻击。</p>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><ul>
<li>通过防火墙、路由器等过滤网关防护。</li>
<li>增大半连接队列；</li>
<li>开启 tcp_syncookies 功能</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>
<h6 id="增大半连接队列"><a href="#增大半连接队列" class="headerlink" title="增大半连接队列"></a>增大半连接队列</h6><p><strong>要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列</strong>。否则，只单纯增大 tcp_max_syn_backlog 是无效的。</p>
<blockquote>
<h5 id="半连接队列大小"><a href="#半连接队列大小" class="headerlink" title="半连接队列大小"></a>半连接队列大小</h5><p>服务端处于 <code>SYN_RECV</code> 状态的 TCP 连接，就是 TCP 半连接队列。</p>
<ul>
<li>当 max_syn_backlog &gt; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; min(somaxconn, backlog) * 2;</li>
<li>当 max_syn_backlog &lt;&#x3D; min(somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log &#x3D; max_syn_backlog * 2;</li>
</ul>
<p>TCP 全连接队列的最大值sk_max_ack_backlog是 min(somaxconn, backlog)**</p>
<ul>
<li><code>somaxconn</code> 是 Linux 内核的参数，默认值是 128，可以通过 <code>/proc/sys/net/core/somaxconn</code> 来设置其值；</li>
<li><code>backlog</code> 是 <code>listen(int sockfd, int backlog)</code> 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li>
</ul>
</blockquote>
<p>增大 tcp_max_syn_backlog 和 somaxconn 的方法是修改 Linux 内核参数：</p>
<img src="/./res\41.jpg" alt="img" style="zoom: 25%;">

<p>增大 backlog 的方式，每个 Web 服务都不同，比如 Nginx 增大 backlog 的方法如下：</p>
<img src="/./res\42.jpg" alt="img" style="zoom: 25%;">

<p>最后，改变了如上这些参数后，要重启 Nginx 服务，因为半连接队列和全连接队列都是在 listen() 初始化的。</p>
<h6 id="开启-tcp-syncookies-功能"><a href="#开启-tcp-syncookies-功能" class="headerlink" title="开启 tcp_syncookies 功能"></a>开启 tcp_syncookies 功能</h6><p>如果不断受到 SYN 攻击，就会导致 SYN 队列（半连接队列）被占满，从而导致无法在建立新的连接。</p>
<p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure>

<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li>
<li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li>
<li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
<img src="/./res\43.jpg" alt="img" style="zoom: 25%;">

<h6 id="减少-SYN-ACK-重传次数"><a href="#减少-SYN-ACK-重传次数" class="headerlink" title="减少 SYN+ACK 重传次数"></a>减少 SYN+ACK 重传次数</h6><p>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。那么针对 SYN 攻击的场景，我们可以减少 SYN+ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</p>
<img src="/./res\44.jpg" alt="img" style="zoom:25%;">

<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><h5 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h5><h6 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a><strong>客户端优化</strong></h6><p>根据网络的稳定性和目标服务器的繁忙程度<strong>修改 SYN 的重传次数</strong>，调整客户端的三次握手时间上限。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。</p>
<ul>
<li><p>客户端作为主动发起连接方，首先它将发送 SYN 包，于是客户端的连接就会处于 <code>SYN_SENT</code> 状态。如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，默认是 5 次：</p>
</li>
<li><p>第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后……。<strong>每次超时的时间是上一次的 2 倍</strong>。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终止三次握手。所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p>
</li>
</ul>
<h6 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h6><p>见上面SYN洪泛攻击、全连接异常、半连接</p>
<h6 id="绕过三次握手"><a href="#绕过三次握手" class="headerlink" title="绕过三次握手"></a>绕过三次握手</h6><p><strong>问题</strong>：三次握手建立连接造成的后果就是，HTTP 请求必须在<strong>一个 RTT</strong>（从客户端到服务器一个往返的时间）后才能发送。</p>
<p><strong>解决</strong>：在 Linux 3.7 内核版本之后，提供了 <strong>TCP Fast Open</strong> 功能，这个功能可以减少 TCP 连接建立的时延。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><p>在客户端<strong>首次建立连接时</strong>的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>第一次发起 HTTP GET 请求的时候，还是需要正常的三次握手流程。</p>
</li>
<li><p>客户端<strong>再次向服务器建立连接</strong>时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含<strong>「数据」</strong>（对于非 TFO 的普通 TCP 握手过程，SYN 报文中不包含「数据」）以及此前记录的 <strong>Cookie</strong>；</li>
<li>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：<ul>
<li>如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；</li>
<li>如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</li>
</ul>
</li>
<li>如果服务器接受了 SYN 报文中的「数据」，服务器可在握手完成之前发送「数据」，<strong>这就减少了握手带来的 1 个 RTT 的时间消耗</strong>；</li>
<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报文中发送的「数据」没有被确认，则客户端将重新发送「数据」；</li>
<li>此后的 TCP 连接的数据传输过程和非 TFO 的正常情况一致。</li>
</ol>
</li>
</ul>
<img src="/./res\22.jpg" alt="开启 TCP Fast Open 功能" style="zoom:50%;">

<h5 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h5><h6 id="主动方优化"><a href="#主动方优化" class="headerlink" title="主动方优化"></a>主动方优化</h6><p>①关闭连接</p>
<p><strong>关闭连接的方式通常有两种</strong></p>
<ul>
<li><strong>RST 报文关闭：</strong>如果进程收到 RST 报文，就直接关闭连接了，不需要走四次挥手流程，是一个暴力关闭连接的方式。</li>
<li><strong>FIN 报文关闭：</strong>安全关闭连接的方式必须通过四次挥手，它由进程调用 <code>close</code> 和 <code>shutdown</code> 函数发起 FIN 报文（shutdown 参数须传入 SHUT_WR 或者 SHUT_RDWR 才会发送 FIN）</li>
</ul>
<p> <strong>close 函数和 shutdown 函数有什么区别？</strong></p>
<ul>
<li><p>调用了 close 函数意味着完全断开连接，<strong>完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接」，如果你用 netstat -p 命令，会发现连接对应的进程名为空。</strong></p>
</li>
<li><p>使用 close 函数关闭连接是不优雅的。于是，就出现了一种优雅关闭连接的 <code>shutdown</code> 函数，<strong>它可以控制只关闭一个方向的连接</strong>：</p>
</li>
</ul>
<p><strong><code>shutdown</code> 函数：</strong></p>
<img src="/./res\26.jpg" alt="img" style="zoom:67%;">

<p>第二个参数决定断开连接的方式，主要有以下三种方式：</p>
<ul>
<li>SHUT_RD(0)：<strong>关闭连接的「读」这个方向</strong>，如果接收缓冲区有已接收的数据，则将会被丢弃，并且后续再收到新的数据，会对数据进行 ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。</li>
<li>SHUT_WR(1)：<strong>关闭连接的「写」这个方向</strong>，这就是常被称为「半关闭」的连接。如果发送缓冲区还有未发送的数据，将被立即发送出去，并发送一个 FIN 报文给对端。</li>
<li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各一次，<strong>关闭套接字的读和写两个方向</strong>。</li>
</ul>
<p><strong>②FIN_WAIT1 状态的优化</strong></p>
<p><strong>内核会定时重发 FIN 报文，其中重发次数由 tcp_orphan_retries 参数控制</strong></p>
<h6 id="被动方优化"><a href="#被动方优化" class="headerlink" title="被动方优化"></a>被动方优化</h6><h4 id="连接个数"><a href="#连接个数" class="headerlink" title="连接个数"></a>连接个数</h4><p>源地址和<strong>目的地址的字段（32位）</strong>是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>源端口和<strong>目的端口的字段（16位）</strong>是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<blockquote>
<p>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</p>
</blockquote>
<p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:</p>
<img src="/./res\image-20220810182852935.png" alt="image-20220810182852935" style="zoom: 67%;">

<p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code> 次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p>
<h4 id="RST报文段"><a href="#RST报文段" class="headerlink" title="RST报文段"></a>RST报文段</h4><p>RST即复位字段。</p>
<p><strong>出现RST包的情况：</strong></p>
<ul>
<li><p>连接请求到达时，目的端口不存在。</p>
</li>
<li><p>向一个已经关闭的连接发送数据。</p>
</li>
<li><p>向一个已经崩溃的对端发送数据。</p>
</li>
<li><p>TCP收到了一个历史连接上的报文。超时。 接收端在接收数据超时时，会发送RST包。</p>
</li>
<li><p>关闭socket时，直接丢弃接收缓冲区未读取的数据，并给对方发一个RST。</p>
</li>
<li><p>处理半打开连接时。一方关闭了连接，另一方却由于网络故障等原因没有收到结束报文，还维持着原来的连接，这种状态就叫做半打开连接。此时另一方往处于半打开状态的连接写数据的话，对方就会回应RST。</p>
</li>
</ul>
<h4 id="MSS最大报文长度"><a href="#MSS最大报文长度" class="headerlink" title="MSS最大报文长度"></a>MSS最大报文长度</h4><ul>
<li><code>MTU</code>：（maximum transmission unit）<strong>最大传输单元</strong>，一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li>
<li><code>MSS</code>：（Maximum segment size）<strong>最大报文长度</strong>，除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
</ul>
<p><strong>IP层分片：如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p>
<p><strong>TCP层MSS</strong>：如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片。</p>
<p>达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p>
<p>![握手阶段协商 MSS](.\res\握手阶段协商 MSS.png)</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="UDP实现可靠传输"><a href="#UDP实现可靠传输" class="headerlink" title="UDP实现可靠传输"></a>UDP实现可靠传输</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c73a4585eba">UDP如何实现可靠传输 </a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38731735/article/details/121444828">UDP如何实现可靠传输</a></p>
<p>基于应用层的可靠传输，udp可靠设计需要根据具体的使用场景。</p>
<p>（1）丢包 ——–负荷、信号  —&gt; 重传 应答</p>
<p>（2）乱序  —————————&gt;  重排   加上序号</p>
<ul>
<li>一个是<strong>重传机制</strong>，丢包需要进行重传，可以添加 seq&#x2F;ack 机制，确保数据发送到对端的方式；</li>
<li>第二是<strong>重排机制</strong>，我们在收到乱序数据一定需要增加一个缓冲区进行数据重排；</li>
<li>第三是<strong>超时机制</strong>，长时间没收收到对方的回复需要进行重试；</li>
<li>第四，流量控制，在局域网内一般是不考虑这部分，实现起来比较复杂，收益不是那么大。</li>
</ul>
<h5 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协议设计：</span><br><span class="line">|同步字|总字节大小|分片数|分片编号|载荷大小|预留|荷载|</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct packet</span><br><span class="line">&#123;</span><br><span class="line">    int recv_pieces;								//当前已经接收的数量；</span><br><span class="line">    int total_size; 								//总数据大小</span><br><span class="line">    int left; 										//最后一片大小</span><br><span class="line">    int paiece_size; 								//分片大小</span><br><span class="line">    int recv_len;  									//接收数据长度</span><br><span class="line">    uint8_t *recv_buf;								//保存接收数据</span><br><span class="line">    uint8_t * send_pt; 								//指向发送数据buffer</span><br><span class="line">   	uint8_t piece_buf[PIECE_FIX_SIZE+HEAD_SIZE+1] ;	//单帧的buf</span><br><span class="line">   	circular_buffer_t *circular_buffer; 			//环形缓存</span><br><span class="line">&#125;packet;</span><br></pre></td></tr></table></figure>



<h4 id="最大传输长度"><a href="#最大传输长度" class="headerlink" title="最大传输长度"></a>最大传输长度</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luojian5900339/article/details/78472137">https://blog.csdn.net/luojian5900339/article/details/78472137</a></p>
<p>■ MTU：以太网（Ethernet）数据帧的长度必须在46-1500字节之间，这是由以太网 的物理特性决定的。这个1500字节被称为链路层的<strong>MTU（最大传输单元）</strong>。<code>MTU</code>：（maximum transmission unit）<strong>最大传输单元</strong></p>
<p>■单个UDP传输的最大内容1472（1500-20-8，如果有可选字节＞28）字节，但由于 不同的网络中转设备设置的MTU值并不相同。Internet上的标准MTU值为576 字节，建议在进行Internet的UDP编程时.最好将UDP的数据长度控件在548字节(576-8-20)以内.</p>
<p>ip报头 20字节 UDP报头 8字节</p>
<img src="/./res\image-20220815150754894.png" alt="  " style="zoom: 50%;">

<p><strong>当我们发送的UDP数据大于1472的时候会怎样呢？</strong></p>
<p>这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要**分片(fragmentation).**把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,<strong>当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报</strong>。</p>
<h4 id="UDP编程问题"><a href="#UDP编程问题" class="headerlink" title="UDP编程问题"></a>UDP编程问题</h4><ul>
<li><strong>UDP乱序问题：</strong>一般采用接收缓冲区进行排序</li>
<li><strong>发送包大小：</strong>sendto一次发送1400字节，需要小于最小的MTU，以太网数据帧一般是1500字节<br>经验值：1400 （实时通讯）500（游戏）主要是包比较小有一定的优先权</li>
<li><strong>接收数据</strong><ul>
<li>recvfrom一次需要完整读取报文</li>
<li>udp一次只能收一个包，没有边界问题（报文传输）</li>
<li>tcp一次可以收一部分数据，有粘包问题（流式传输）</li>
</ul>
</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h4><p>​		<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</strong></p>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><img src="/./res\image-20220510171751577.png" alt="image-20220510171751577" style="zoom:50%;">

<h5 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h5><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态。</p>
<h5 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h5><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求。</p>
<ul>
<li><strong>[200 OK]</strong>:表示一切正常，如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li><strong>[204 No Content]</strong>:与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li><strong>[206 Partial Content]</strong>:应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<h5 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h5><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong></p>
<ul>
<li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li>
</ul>
<p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
<ul>
<li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓存文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<h5 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h5><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<h5 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h5><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h4 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h4><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>Host字段在客户端发送请求时，用来指定服务器的域名</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure>

<h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p><code>Connection</code> 字段用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。这样就在客户端和服务器端建立起了一个可以复用的TCP连接，直到客户端或服务器主动关闭连接。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>

<h5 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h5><p><code>Accept</code> 字段声明客户端可以接受哪些数据格式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*		//表明客户端可以接受任何形式的数据</span><br></pre></td></tr></table></figure>

<h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p><code>Accept-Encoding</code> 字段说明客户端可以接受哪些压缩方法。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br></pre></td></tr></table></figure>

<h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p><code>Content-Type</code> 字段用于服务器回应时，指明本次数据的格式。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8		//服务器回传数据的格式为网页，字符编码为utf-8</span><br></pre></td></tr></table></figure>

<h5 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h5><p><code>Content-Encoding</code> 字段表示服务器返回的数据使用了什么压缩格式</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip		//服务器返回的数据采用了gzip方式压缩，告知客户端需要用此方式解压</span><br></pre></td></tr></table></figure>



<h4 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h4><ul>
<li><p>PUT：上传文件，向服务器添加数据，可以看作增</p>
</li>
<li><p>DELETE：删除文件</p>
</li>
<li><p>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</p>
</li>
<li><p>GET：获取资源，查询服务器资源</p>
</li>
</ul>
<h5 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h5><ul>
<li><p><strong>GET</strong></p>
<ul>
<li>GET请求是从服务器获取指定的资源，如文本、页面和图片等</li>
<li>GET请求的参数是写在URL中的，由于URL只支持ASCII，所以GET请求的参数只允许使用ASCII，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</li>
</ul>
</li>
<li><p><strong>POST</strong></p>
<ul>
<li>POST请求是根据报文中的body内容对指定的资源进行处理(如修改或提交数据)，具体的处理方式视资源类型而不同</li>
<li>POST 请求携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</li>
</ul>
</li>
<li><p><strong>安全与幂等</strong></p>
<ul>
<li><p><strong>安全</strong>是指请求方法不会<strong>破坏</strong>服务器上的资源</p>
</li>
<li><p><strong>幂等</strong>是指多次执行相同的操作，结果都是<strong>相同</strong>的。</p>
</li>
</ul>
</li>
<li><p><strong>GET方法是安全和幂等的</strong>：GET方法是<strong>只读</strong>操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p>
</li>
<li><p><strong>POST方法是不安全和不幂等的</strong>：POST方法是<strong>新增或提交数据</strong>的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p>
</li>
</ul>
<h4 id="HTTP长连接和短连接"><a href="#HTTP长连接和短连接" class="headerlink" title="HTTP长连接和短连接"></a>HTTP长连接和短连接</h4><ul>
<li><strong>在HTTP&#x2F;1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接</strong>。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话</li>
<li>从 <strong>HTTP&#x2F;1.1</strong>起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码： Connection:keep-alive。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</li>
<li><strong>HTTP</strong> 协议的长连接和短连接，实质上是 <strong>TCP</strong> 协议的长连接和短连接。</li>
</ul>
<h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><ul>
<li><p><strong>请求报文</strong></p>
<ol>
<li>请求行(请求方法+URI协议+版本)</li>
<li>请求头</li>
<li>空行</li>
<li>请求主体</li>
</ol>
<img src="/./res\image-20220811160939535.png" alt="image-20220811160939535" style="zoom:50%;">
</li>
<li><p><strong>响应报文</strong></p>
<ul>
<li>状态行(版本+状态码+原因短语)</li>
<li>响应首部</li>
<li>空行</li>
<li>响应主体</li>
</ul>
<img src="/./res\image-20220811161041748.png" alt="image-20220811161041748" style="zoom:50%;"></li>
</ul>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><h4 id="为什么要使用HTTP缓存"><a href="#为什么要使用HTTP缓存" class="headerlink" title="为什么要使用HTTP缓存"></a>为什么要使用HTTP缓存</h4><p>​		对于一些具有重复性的 HTTP 请求，如果每次请求得到的数据都一样的，就可以把<strong>请求-响应</strong>的数据都<strong>缓存在本地</strong>，下次就直接读取本地的数据，能大大提升HTTP的性能。避免发送 HTTP 请求的方法就是通过<strong>缓存技术</strong>，有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动权在浏览器 。</p>
<img src="/./res\image-20220511155626000.png" alt="image-20220511155626000" style="zoom:50%;">

<p>其中from disk cache就表明使用了强制缓存</p>
<p>相关HTTP字段</p>
<p>强制缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>， 是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p>
<p>实现流程</p>
<ul>
<li><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</p>
</li>
<li><p>浏览器再次请求访问服务器中的该资源时，会<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小来判断该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</p>
</li>
<li><p>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p>
</li>
</ul>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是浏览器与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p>
<img src="/./res\image-20220511164352086.png" alt="image-20220511164352086" style="zoom:50%;">

<p>如上图所示，当浏览器要访问的资源存在于缓存中，但是过期了，浏览器会向服务器发起请求来请求该过期资源，服务器端收到请求后判断该过期的缓存资源是否发生了修改，如果发生修改说明该缓存资源不可用，返回 200 状态码和修改后的新资源；如果未发生修改说明该过期的缓存资源仍可用，返回 304 状态码，浏览器收到 304 后就继续使用该过期的缓存资源。</p>
<p>实现流程</p>
<p>通过<code>If-Modified-Since</code> 字段和<code>Last-Modified</code> 字段实现</p>
<ul>
<li>浏览器第一次访问某个资源时，服务器的响应头部中会带上<code>Last-Modified</code> 字段，表示该资源的最后修改时间。</li>
<li>当浏览器第二次访问该资源，且该资源在缓存中过期时，浏览器在向服务器发送HTTP请求时，会在<code>If-Modified-Since</code> 字段上带上Last-Modified 的时间。</li>
<li>服务器收到请求后发现有 If-Modified-Since 字段，则与服务器中被请求资源的最后修改时间进行对比，如果最后修改时间较大，说明资源又被改过，则返回最新资源和HTTP 200 OK；如果最后修改时间较小，说明资源无新修改，返回HTTP 304，则浏览器直接使用缓存中的数据。</li>
</ul>
<p>通过<code>If-None-Match</code> 字段和<code>ETag</code> 字段实现</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的。</li>
<li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识。</li>
<li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较，<strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识。</li>
<li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li>
</ul>
<img src="/./res\image-20220511170730679.png" alt="image-20220511170730679" style="zoom:50%;">



<img src="/./res\QQ截图20230510135655.png" style="zoom: 67%;">

<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul>
<li><p><strong>新方法</strong>：<strong>PUT</strong>、DELETE、<strong>OPTIONS</strong>、<strong>PATCH</strong>等方法</p>
</li>
<li><p><strong>长连接</strong>：HTTP 1.1支持长连接（Persistent Connection），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启 Connection： keep-alive ，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
</li>
<li><p><strong>管道机制</strong>：它指的是在一个TCP连接内，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容（返回还是要顺序，已经没人用了）。</p>
</li>
<li><p><strong>并发连接</strong>：一个域名的请求允许分配多个长连接（缓解队头阻塞问题）</p>
</li>
<li><p><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的Cache-Control,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略(If-Modified-Since，<strong>If-None-Match</strong>)。</p>
</li>
<li><p><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持<strong>断点续传</strong>功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个<strong>错误状态响应码</strong>，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
</li>
</ul>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul>
<li><strong>新的二进制格式</strong>：<strong>HTTP1.1的解析是基于文本</strong>。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑<strong>HTTP2.0的协议解析决定采用二进制格式</strong>，实现方便且健壮。</li>
<li><strong>多路复用</strong>：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>头部压缩</strong>：HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</li>
<li><strong>数据流</strong>：由于HTTP&#x2F;2版本的数据包不是按照顺序发送的，同一个TCP连接里面相连的两个数据包可能是属于不同的响应，因此，必须要有一种方法来区分每一个数据包属于哪个响应。HTTP&#x2F;2版本中，每个请求或者响应的所有数据包，称为一个数据流（stream），并且每一个数据流都有一个唯一的编号ID，请求数据流的编号ID为奇数，响应数据流的编号ID为偶数。每个数据包在发送的时候带上对应数据流的编号ID，这样服务器和客户端就能分区是属于哪一个数据流。最后，客户端还能指定数据流的优先级，优先级越高，服务器会越快做出响应。</li>
</ul>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>HTTP&#x2F;3 现在还没正式推出，不过自 2017 年起， HTTP&#x2F;3 已经更新到 34 个草案了，基本的特性已经确定下来了，对于包格式可能后续会有变化。</p>
<h4 id="HTTP-2不足"><a href="#HTTP-2不足" class="headerlink" title="HTTP&#x2F;2不足"></a><strong>HTTP&#x2F;2不足</strong></h4><p>HTTP&#x2F;2 通过头部压缩、二进制编码、多路复用、服务器推送等新特性大幅度提升了 HTTP&#x2F;1.1 的性能，而美中不足的是 HTTP&#x2F;2 协议是基于 TCP 实现的，于是存在的<strong>缺陷有三个</strong>。</p>
<ul>
<li><strong>队头阻塞</strong>，HTTP&#x2F;2 多个请求跑在一个 TCP 连接中，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是多个请求被阻塞了；</li>
<li><strong>TCP 和 TLS 握手时延</strong>，TCP 三次握手和 TLS 四次握手，共有 3-RTT 的时延；</li>
<li><strong>连接迁移需要重新连接</strong>，移动设备从 4G 网络环境切换到 WIFI 时，由于 TCP 是基于四元组来确认一条 TCP 连接的，那么网络环境变化后，就会导致 IP 地址或端口变化，于是 TCP 只能断开连接，然后再重新建立连接，切换网络环境的成本高；</li>
</ul>
<p>这些问题都是 TCP 协议固有的问题，无论应用层的 HTTP&#x2F;2 在怎么设计都无法逃脱。要解决这个问题，就必须把<strong>传输层协议替换成 UDP</strong>，这个大胆的决定，HTTP&#x2F;3 做了！</p>
<h5 id="队头阻塞"><a href="#队头阻塞" class="headerlink" title="队头阻塞"></a><strong>队头阻塞</strong></h5><p>HTTP&#x2F;2 <strong>多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</strong></p>
<p>因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</p>
<p>比如下图中，Stream 2 有一个 TCP 报文丢失了，那么即使收到了 Stream 3 和 Stream 4 的 TCP 报文，应用层也是无法读取读取的，相当于阻塞了 Stream 3 和 Stream 4 请求。</p>
<img src=".\res\http2阻塞.jpeg" alt="img" style="zoom: 50%;">



<h5 id="TCP-与-TLS-的握手时延迟"><a href="#TCP-与-TLS-的握手时延迟" class="headerlink" title="TCP 与 TLS 的握手时延迟"></a><strong>TCP 与 TLS 的握手时延迟</strong></h5><p>发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。</p>
<p>另外， TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生”减速”效果。</p>
<img src="/./res\TCP+TLS.gif" alt="img" style="zoom: 67%;">

<h5 id="网络迁移需要重新连接"><a href="#网络迁移需要重新连接" class="headerlink" title="网络迁移需要重新连接"></a><strong>网络迁移需要重新连接</strong></h5><p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WIFI。</p>
<img src="/./res\27-HTTP3.png" alt="HTTP/1 ~ HTTP/3" style="zoom:80%;">



<h4 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h4><blockquote>
<p> 我们深知，UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。</p>
</blockquote>
<p><strong>HTTP&#x2F;3 就将传输层从 TCP 替换成了 UDP，并在 UDP 协议上开发了 QUIC 协议，来保证数据的可靠传输。</strong>它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p>
<p>QUIC 协议的<strong>特点</strong>：</p>
<ul>
<li><strong>无队头阻塞</strong>，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，也不会有底层协议限制，某个流发生丢包了，只会影响该流，其他流不受影响；</li>
<li><strong>建立连接速度快</strong>，因为 QUIC 内部包含 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li>
<li><strong>连接迁移</strong>，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本；</li>
</ul>
<h5 id="无队头阻塞"><a href="#无队头阻塞" class="headerlink" title="无队头阻塞"></a>无队头阻塞</h5><ul>
<li><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与<strong>多路复用</strong>的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>
</li>
<li><p>由于 QUIC 使用的<strong>传输协议是 UDP</strong>，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</p>
</li>
<li><p>不过 QUIC 协议<strong>会保证数据包的可靠性</strong>，每个数据包都有<strong>一个序号唯一标识</strong>。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP&#x2F;3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP&#x2F;3。<strong>而其他流的数据报文只要被完整接收，HTTP&#x2F;3 就可以读取到数据</strong>。这与 HTTP&#x2F;2 不同，<strong>HTTP&#x2F;2 只要某个流中的数据包丢失了，其他流也会因此受影响。</strong></p>
</li>
</ul>
<p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
<img src="/./res\quic无阻塞.jpeg" alt="img" style="zoom: 50%;">



<h5 id="更快的连接建立"><a href="#更快的连接建立" class="headerlink" title="更快的连接建立"></a>更快的连接建立</h5><ul>
<li>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</li>
<li>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程<strong>只需要 1 RTT</strong>，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</li>
<li>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong>。</li>
</ul>
<h5 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h5><ul>
<li>在前面我们提到，<strong>基于 TCP 传输协议的 HTTP 协议</strong>，由于是通过<strong>四元组</strong>（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的<strong>迁移成本是很高的</strong>。</li>
<li>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</li>
</ul>
<h4 id="HTTP3-协议"><a href="#HTTP3-协议" class="headerlink" title="HTTP3 协议"></a>HTTP3 协议</h4><ul>
<li><p>HTTP&#x2F;3 同 HTTP&#x2F;2 一样采用二进制帧的结构，不同的地方在于 HTTP&#x2F;2 的二进制帧里需要定义 Stream，而 HTTP&#x2F;3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP&#x2F;3 的帧的结构也变简单了。</p>
</li>
<li><p>HTTP&#x2F;3 帧头只有两个字段：<strong>类型和长度</strong>。根据帧类型的不同，大体上分为<strong>数据帧</strong>和<strong>控制帧</strong>两大类，HEADERS 帧（HTTP 头部）和 DATA 帧（HTTP 包体）属于数据帧。</p>
</li>
</ul>
<p><img src="/.%5Cres%5Chttp3frame.png" alt="img"></p>
<ul>
<li><strong>HTTP&#x2F;3 的 QPACK 通过两个特殊的单向流来同步双方的动态表，解决了 HTTP&#x2F;2 的 HPACK 队头阻塞问题。</strong>HTTP&#x2F;3 在头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP&#x2F;2 中的 HPACK 编码方式相似，HTTP&#x2F;3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。<ul>
<li>对于静态表的变化，HTTP&#x2F;2 中的 HPACK 的静态表只有 61 项，而 HTTP&#x2F;3 中的 QPACK 的静态表扩大到 91 项。</li>
<li>HTTP&#x2F;2 和 HTTP&#x2F;3 的 Huffman 编码并没有多大不同，但是动态表编解码方式不同。</li>
<li>所谓的动态表，在首次请求-响应后，双方会将未包含在静态表中的 Header 项更新各自的动态表，接着后续传输时仅用 1 个数字表示，然后对方可以根据这 1 个数字从动态表查到对应的数据，就不必每次都传输长长的数据，大大提升了编码效率。</li>
</ul>
</li>
</ul>
<p><strong>HTTP&#x2F;3 的 QPACK 解决了这一问题，那它是如何解决的呢？</strong></p>
<p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p>
<ul>
<li>一个叫 QPACK Encoder Stream， 用于将一个字典（key-value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li>
<li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li>
</ul>
<p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTP-1-1的优缺点"><a href="#HTTP-1-1的优缺点" class="headerlink" title="HTTP&#x2F;1.1的优缺点"></a>HTTP&#x2F;1.1的优缺点</h4><ul>
<li><strong>优点</strong><ul>
<li><strong>简单</strong>：HTTP 基本的报文格式就是 <code>header + body</code>，头部信息也是 <code>key-value</code> 简单文本的形式，<strong>易于理解</strong></li>
<li><strong>灵活和易于扩展</strong>：HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员<strong>自定义和扩充</strong></li>
<li><strong>应用广泛和跨平台</strong></li>
</ul>
</li>
<li><strong>缺点</strong>：<strong>不安全</strong><ul>
<li><strong>窃听风险</strong>：通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li>
<li><strong>冒充风险</strong>：不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li>
<li><strong>篡改风险</strong>：无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li>
</ul>
</li>
<li><strong>双刃剑</strong><ul>
<li><strong>无状态</strong><ul>
<li><p>优点：服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担</p>
</li>
<li><p>缺点：服务器没有记忆能力，在完成有关联性的操作时会非常麻烦。（如身份认证）</p>
</li>
<li><p>解决方案：Cookie、Session</p>
</li>
</ul>
</li>
<li><strong>明文传输</strong><ul>
<li>优点：通过浏览器控制台或抓包工具可以直接查看传输的信息，便于调试</li>
<li>缺点：HTTP传输的信息容易被窃取</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HTTPS的优缺点"><a href="#HTTPS的优缺点" class="headerlink" title="HTTPS的优缺点"></a>HTTPS的优缺点</h4><ul>
<li><p><strong>优点</strong>：<strong>安全性</strong></p>
<ul>
<li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
</li>
<li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
</li>
<li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</p>
</li>
<li><p>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</p>
</li>
<li><p>在现有的证书机制下，中间人攻击依然有可能发生。</p>
</li>
<li><p>HTTPS 需要更多的服务器资源，也会导致成本的升高。</p>
</li>
</ul>
</li>
</ul>
<h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><ul>
<li>HTTP 的端口号是 <strong>80</strong>，HTTPS 的端口号是 <strong>443</strong>。</li>
<li>HTTP 是明文传输，存在安全风险；HTTPS 是加密传输，在TCP和HTTP之间加入了<strong>SSL&#x2F;TLS安全协议</strong></li>
<li>HTTP在TCP三次握手之后便可进行HTTP的报文传输，而HTTPS在TCP三次握手之后还需要进行<strong>SSL&#x2F;TLS的握手过程</strong>，才可进行加密报文的传输</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请<strong>数字证书</strong>，来保证服务器的身份是可信的。</li>
</ul>
<h4 id="HTTPS如何解决HTTP的三大风险"><a href="#HTTPS如何解决HTTP的三大风险" class="headerlink" title="HTTPS如何解决HTTP的三大风险"></a>HTTPS如何解决HTTP的三大风险</h4><h5 id="信息加密"><a href="#信息加密" class="headerlink" title="信息加密"></a>信息加密</h5><p>使用<strong>混合加密</strong>(<strong>对称加密</strong>和<strong>非对称加密</strong>结合)的方式实现信息加密，解决了信息被窃听的风险</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」。</li>
<li>在通信过程中使用<strong>对称加密</strong>的「会话秘钥」来加密明文数据。</li>
</ul>
<img src="/./res\image-20220512144208892.png" alt="image-20220512144208892" style="zoom: 67%;">

<h5 id="校验机制"><a href="#校验机制" class="headerlink" title="校验机制"></a>校验机制</h5><p>使用<strong>摘要算法</strong>为数据生成独一无二的<strong>指纹</strong>，用于校验数据的完整性，解决了数据被篡改的风险</p>
<ul>
<li>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器</li>
<li>服务器解密后，用相同的摘要算法算出发送过来的明文的「指纹」，比较客户端携带的「指纹」和当前算出的「指纹」，若「指纹」相同，说明数据是完整的。</li>
</ul>
<img src="/./res\image-20220512144444136.png" alt="image-20220512144444136" style="zoom:67%;">

<h5 id="身份证书"><a href="#身份证书" class="headerlink" title="身份证书"></a>身份证书</h5><p>使用<strong>数字证书</strong>的方式保证服务器公钥的身份，解决冒充的风险</p>
<img src="/./res\image-20220512144835190.png" alt="image-20220512144835190" style="zoom: 67%;">

<h4 id="TSL握手过程"><a href="#TSL握手过程" class="headerlink" title="TSL握手过程"></a>TSL握手过程</h4><h5 id="TSL第一次握手"><a href="#TSL第一次握手" class="headerlink" title="TSL第一次握手"></a>TSL第一次握手</h5><ul>
<li>客户端首先会向服务器端发送一个「<strong>Client Hello</strong>」消息</li>
<li>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数</strong>(<strong>Client Random</strong>)，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</li>
</ul>
<img src="/./res\image-20220512153744665.png" alt="image-20220512153744665" style="zoom:50%;">



<h5 id="TSL第二次握手"><a href="#TSL第二次握手" class="headerlink" title="TSL第二次握手"></a>TSL第二次握手</h5><ul>
<li><p>服务端收到客户端的「<strong>Client Hello</strong>」消息后，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了<strong>随机数（Server Random）</strong>，然后从客户端的密码套件列表选择了一个合适的密码套件。</p>
<img src="/./res\image-20220512154535008.png" alt="image-20220512154535008" style="zoom: 50%;">

<p>服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。</p>
<p>基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」。</p>
<p>Server Random和Client Random作为后续生成「会话密钥」的条件。</p>
</li>
<li><p>服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p>
</li>
</ul>
<img src="/./res\image-20220512155412391.png" alt="image-20220512155412391" style="zoom: 67%;">

<ul>
<li>服务端发送「<strong>Server Hello Done</strong>」消息给客户端，本次握手完毕</li>
</ul>
<h5 id="TSL第三次握手"><a href="#TSL第三次握手" class="headerlink" title="TSL第三次握手"></a>TSL第三次握手</h5><ul>
<li>客户端首先验证服务器端的数字证书，如果可信则继续完成以下内容</li>
<li>客户端会生成一个新的<strong>随机数 (*pre-master*)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Change Cipher Key Exchange</strong>」消息传给服务端。</li>
</ul>
<img src="/./res\image-20220512160414534.png" alt="image-20220512160414534" style="zoom:67%;">

<ul>
<li>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。此时客户端和服务端都共享了三个随机数：Client Random、Server Random和pre-master，双方根据这三个随机数生成**会话密钥(Master Secret)**，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</li>
<li>生成完会话密钥后，客户端发一个「<strong>Change Cipher Spec</strong>」消息，告诉服务端开始使用加密方式发送消息。</li>
</ul>
<img src="/./res\image-20220512160739718.png" alt="image-20220512160739718" style="zoom:67%;">

<ul>
<li>最后，客户端再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</li>
</ul>
<img src="/./res\image-20220512160907522.png" alt="image-20220512160907522" style="zoom:67%;">

<h5 id="TSL第四次握手"><a href="#TSL第四次握手" class="headerlink" title="TSL第四次握手"></a>TSL第四次握手</h5><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成，后续就用「会话密钥」加解密 HTTP 请求和响应了。</p>
<h4 id="HTTPS如何优化"><a href="#HTTPS如何优化" class="headerlink" title="HTTPS如何优化"></a>HTTPS如何优化</h4><p>具体看这个连接<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36638788/article/details/124850298">(16条消息) 【HTTPS】HTTPS如何优化？_https优化_再夏的博客-CSDN博客</a></p>
<h5 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h5><p>HTTPS协议是极端密集型，而不是I&#x2F;O密集型，所以，应该提升CPU硬件。</p>
<p>一个好的CPU，可以提高计算性能，因为HTTPS连接过程中就由大量需要计算密钥的过程，所以这样可以加速TLS握手过程。</p>
<p>另外，如果可以，应该选择可以支持AES-NI特性的CPU，因为这种款式的CPU能在指令级别优化了AES算法，这样便可以加速数据的加解密传输过程。</p>
<p>如过我们的CPU支持AES_NI特性，那么对于对称加密的算法应该选择AES算法。否则可以选择ChaCha20对称加密算法，因为ChaCha20算法的运算指令相比AES换发会对CPU更友好一点。</p>
<h5 id="密钥交换算法优化"><a href="#密钥交换算法优化" class="headerlink" title="密钥交换算法优化"></a><strong>密钥交换算法优化</strong></h5><p>TLS1.2版本如果使用的是RSA密钥交换算法，那么需要4次握手，也就是要花费2RTT，才可以进行应用数据的传输，而且RSA密钥交换算法不具备前向安全性。总之使用RSA密钥交换算法的TLS握手过程，不仅慢，而且安全性也不高。</p>
<p>因此如果可以，尽量选用ECDHE密钥交换算法替换RSA算法，因为该算法支持False Start ，它是抢跑的意思，客户端可以在TLS协议的第三次握手后，第四次握手前，发送加密的应用数据，一次将TLS握手的消息往返由2RTT减少到1RTT，而且安全性也高，具备前向安全性。ECDHE算法是基于椭圆曲线实现的，不同的椭圆曲线性能也不高，应该尽量选择x25519曲线，该曲线是目前最快的椭圆曲线。</p>
<p>在对称加密算法方面，如果对安全性不是特别高的要求，可以选用AES_128_GCM,它比AES_256_GCM快一些，因为密钥的长度短一些。比如在Nginx上，可以使用ssl_ciphers指令配置想使用的非对称加密算法和对称加密算法，也就是密钥套件，而且把性能最快最安全的算法放在最前面。</p>
<h5 id="TLS升级"><a href="#TLS升级" class="headerlink" title="TLS升级"></a>TLS升级</h5><p>如果可以，直接把TLS1.2成绩成TLS1.3， TLS1.3大幅度简化了握手的步骤，完成TLS握手只要1RTT，而且安全性更高。</p>
<p>在TLS1.2的握手中，一般是需要4次握手，先要通过Client hello（第1次握手）和Server Hello（第2次握手）消息协商出后续使用的加密算法，在互相交换公钥（第3和第4次握手），然后计算出最终的会话密钥。</p>
<img src="/./res\58150e7d93bd6f541c3aeed691f5daf1.png" alt="58150e7d93bd6f541c3aeed691f5daf1" style="zoom: 33%;">

<p>可以发现TLS1.3把Hello和公钥交换这两个消息合并成了一个消息，于是这样就减少到主要1RTT就能完成TLS握手。具体的做法是，客户端在Client Hello消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p>
<p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这1个RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就快出进行应用数据的加密传输了。</p>
<p>而且，TLS1.3对密码太监进行“减肥”了，对于密钥交换算法，飞出了不支持前向安全性的RSA和DH算法，只支持ECDHE算法。</p>
<p>对于对称加密和签名算法，只支持目前最安全的几个密码套件，比如openssl中仅支持下面5中密码套件：</p>
<p>TLS_AES_256_GCM_SHA384<br>TLS_CHACHA20_POLY1305_SHA256<br>TLS_AES_128_GCM_SHA256<br>TLS_AES_128_CCM_8_SHA256<br>TLS_AES_128_CCM_SHA256<br>之所以TLS1.3仅支持这么少的密码套件，是因为TLS1.2由于支持各种古老不安全的密码套件，中间人可以利用降级攻击，伪造客户端的Client Hello消息，替换客户端支持的密码套件为一些不安全的密码套件，使得服务器被迫使用这个密码套件进行HTTPS连接，从而破解密文。</p>
<p><strong>证书优化</strong></p>
<p>为了验证服务器的身份，服务器会在TLS握手过程中，把自己的证书发给客户端，一次证明自己身份是可信的。</p>
<p>对于证书的优化，可以有两个方向：</p>
<ul>
<li><p>一个是证书传输</p>
</li>
<li><p>一个是证书验证</p>
</li>
</ul>
<p><strong>证书传输优化</strong><br>要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是RSA证书，因为在相同安全强度下，ECC密钥长度比RSA短的多。</p>
<p><strong>证书验证优化</strong><br>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要用CA公钥解密证书以及用签名算法验证证书的完整性，而且为了知道证书是否被CA吊销，客户端优势还会再去访问CA，下载CRL或者OCSP数据，以此确认证书的有效性。</p>
<p>这个访问过程是HTTP访问，因此又会产生一系列网络通信的开销，如DNS查询、建立连接、收发数据等。</p>
<h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>​		<strong>Cookie是在客户端记录信息来确定用户状态</strong>。Cookie实际上是一小段的文本信息，客户端请求服务器时如果服务器需要记录用户状态，就使用response向客户端浏览器发送一个Cookie，客户端浏览器会把Cookie保存起来；当客户端再次请求该网站时，浏览器会把请求的网址和Cookie一同提交给服务器。服务器会检查该Cookie来辨认用户状态。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​		<strong>Session是在服务器端记录客户端状态</strong>，使用上比Cookie简单一些，相应的也<strong>增加了服务器的存储压力</strong>。客户端浏览器访问服务器时，服务器会把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从Session中查找客户端状态就可以了。</p>
<h4 id="Cookie和Session配合使用"><a href="#Cookie和Session配合使用" class="headerlink" title="Cookie和Session配合使用"></a>Cookie和Session配合使用</h4><ul>
<li>用户第一次请求服务器时，服务器根据用户提交的信息创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，将此信息存入到 Cookie 中。同时，Cookie 会记录这个SessionID 属于哪个域名。</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在就自动将 Cookie 信息发送给服务端，服务端会从 Cookie 中获取 SessionID ，再根据 SessionID 查找对应的Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h4 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h4><p>如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li><p>客户端存储：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</p>
</li>
<li><p><strong>Nginx ip_hash</strong> 策略：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p>
</li>
<li><p><strong>Session</strong> 复制：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</p>
</li>
<li><p>将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</p>
</li>
</ul>
<p>建议采用<strong>共享Session</strong>的方案</p>
<h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h3 id="DDos攻击"><a href="#DDos攻击" class="headerlink" title="DDos攻击"></a>DDos攻击</h3><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul>
<li><p><strong>定义：</strong>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果程序忽略了检查，那么这些注入进去的 SQL 语句就会被误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。SQL注入有以下几种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlInject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Course&gt; <span class="title function_">orderList</span><span class="params">(String studentId)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,course_id,student_id,status from course where student_id = &quot;</span>+ studentId;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>(Course.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>恶意拼接查询</li>
<li>利用注释执行非法命令</li>
<li>传入非法参数</li>
<li>添加额外条件</li>
</ul>
</li>
<li><p><strong>防止SQL注入</strong></p>
<ul>
<li><h5 id="避免将用户输入直接放入SQL语句中"><a href="#避免将用户输入直接放入SQL语句中" class="headerlink" title="避免将用户输入直接放入SQL语句中"></a>避免将用户输入直接放入SQL语句中</h5></li>
<li><p>使用 <strong>PreparedStatement</strong> 进行 SQL 的预编译：sql 注入只在编译 sql 语句时有破坏作用，而 PreparedStatement 在执行阶段只是把输入作为数据处理, 不对 sql 语句进行解析, 因此避免了 sql 注入问题</p>
</li>
<li><p><strong>确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储</strong></p>
</li>
<li><p><strong>规定数据长度，能在一定程度上防止sql注入</strong></p>
</li>
<li><p><strong>严格限制数据库权限，能最大程度减少sql注入的危害</strong></p>
</li>
<li><p><strong>过滤参数中含有的一些数据库关键词</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程（ <del>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</del>）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<h3 id="JVM、JRE、JDK"><a href="#JVM、JRE、JDK" class="headerlink" title="JVM、JRE、JDK"></a>JVM、JRE、JDK</h3><p>JDK包含JRE，JRE包含JVM。</p>
<ul>
<li><p><strong>JDK是（Java Development Kit）</strong>的缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
</li>
<li><p><strong>JRE是Java Runtime Environment</strong>缩写，它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，<strong>它不能用于创建新程序。</strong></p>
</li>
</ul>
<p><img src="/.%5Cres%5Cimage-20220715093402677.png" alt="image-20220715093402677"></p>
<h3 id="字节码、编译和解释并存"><a href="#字节码、编译和解释并存" class="headerlink" title="字节码、编译和解释并存"></a>字节码、编译和解释并存</h3><p>在 Java 中，<strong>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件）</strong>，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
<p><strong>在Java中一般是用javac命令编译源代码为字节码文件</strong>，一个.java文件从编译到运行的示例如图所示。</p>
<p><img src="/.%5Cres%5Cjava%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png" alt="Java程序转变为机器代码的过程"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 <strong>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行</strong>，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT即时（just-in-time compilation） 编译器</strong>，而 JIT 属于<strong>运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong>。</p>
<h3 id="Oracle-JDK和Open-JDK"><a href="#Oracle-JDK和Open-JDK" class="headerlink" title="Oracle JDK和Open JDK"></a>Oracle JDK和Open JDK</h3><ul>
<li>Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；</li>
<li><strong>OpenJDK</strong> 是一个参考模型并且是<strong>完全开源</strong>的，而 <strong>Oracle JDK 是OpenJDK 的一个实现</strong>，并<strong>不是完全开源</strong>的；</li>
<li><strong>Oracle JDK 比 OpenJDK 更稳定</strong>。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，建议选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPLv2 许可获得许可。</li>
</ul>
<h3 id="Java和C"><a href="#Java和C" class="headerlink" title="Java和C++"></a>Java和C++</h3><p><strong>都是面向对象的语言，都支持封装、继承和多态</strong></p>
<ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是<strong>接口可以多继承</strong>。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要手动释放无用内存。</li>
<li>C ++支持方法重载和操作符重载，Java 只支持方法重载。</li>
</ul>
<h3 id="成员变量、局部变量"><a href="#成员变量、局部变量" class="headerlink" title="成员变量、局部变量"></a>成员变量、局部变量</h3><ul>
<li><strong>语法形式</strong> ：<ul>
<li><strong>成员变量是属于类的</strong>，而局部变量是在代码块或方法中定义的变量或参数；</li>
<li>成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，<strong>局部变量不能被访问控制修饰符及 <code>static</code> 所修饰</strong>；</li>
<li>但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
</ul>
</li>
<li><strong>存储方式</strong> ：<ul>
<li><strong>使用 <code>static</code> 修饰的成员变量</strong>是属于类的，<strong>存在于堆中</strong></li>
<li><strong>没有使用 <code>static</code> 修饰的成员变量</strong>是属于<strong>实例对象</strong>的，<strong>存在于堆内存</strong></li>
<li><strong>局部变量则存在于栈内存</strong>。</li>
</ul>
</li>
<li><strong>生存时间</strong> ：从变量在内存中的生存时间上看<ul>
<li>成员变量是对象的一部分，<strong>随着对象的创建而存在</strong></li>
<li>局部变量随着方法的调用而生成，<strong>随着方法的结束而消亡</strong>。</li>
</ul>
</li>
<li><strong>默认值</strong> ：从变量是否有默认值来看<ul>
<li><strong>成员变量</strong>如果没有初值，<strong>会自动以类型的默认值赋值</strong>（一种情况例外：<strong>被 <code>final</code> 修饰的成员变量必须显式地赋值</strong>），</li>
<li><strong>局部变量则不会自动赋值</strong>。</li>
</ul>
</li>
</ul>
<h4 id="何为成员变量"><a href="#何为成员变量" class="headerlink" title="何为成员变量"></a>何为成员变量</h4><ul>
<li>成员变量就是定义在<strong>类里</strong>、<strong>方法外</strong>的变量，也叫全局变量。</li>
<li>成员变量又分为：<strong>实例变量</strong>(没有 static )和<strong>类变量</strong>(有 static 修饰)。</li>
</ul>
<p><strong>实例变量</strong>存放在<strong>堆</strong>中，栈中放指向堆的引用地址</p>
<p><strong>类变量</strong>存放在<strong>堆</strong>中</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="final、finally、finalize"><a href="#final、finally、finalize" class="headerlink" title="final、finally、finalize"></a>final、finally、finalize</h4><h5 id="final："><a href="#final：" class="headerlink" title="final："></a>final：</h5><ul>
<li>被 <code>final</code> 关键字修饰的类不能被继承</li>
<li>修饰的方法不能被重写</li>
<li>修饰的变量是基本数据类型则值不能改变，</li>
<li>修饰的变量是引用类型则不能再指向其他对象。</li>
</ul>
<p>final修饰的实例变量一般添加：static，变为静态，称为常量。常量名全部大写，单词之间用下划线衔接。</p>
<h5 id="finally："><a href="#finally：" class="headerlink" title="finally："></a><strong>finally：</strong></h5><ul>
<li><p>作为异常处理的一部分，只能用于 try-catch-finally 结构中，<strong>无论是否捕获或处理异常，finally块里的语句都会被执行</strong>；</p>
</li>
<li><p>当 try 块或 catch 块中有 return 语句时，finally 语句块将在方法返回之前被执行，经常被用在需要释放资源的情况下。</p>
</li>
</ul>
<p>在以下4种特殊情况下，finally 块不会被执行：</p>
<ul>
<li>在 finally 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit() </code>退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<p><strong>finalize：</strong> </p>
<p>finalize 是 Object 类里定义的方法，每个对象都存在该方法，这个方法会在对象被回收时调用。<strong>一个对象的 finalize 方法只会被调用一次</strong>，finalize 被调用不一定会立即回收该对象，有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此<strong>不推荐使用 finalize 方法</strong>。</p>
<blockquote>
<p> 可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行</p>
<p> 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
</blockquote>
<h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><ul>
<li>可以修饰类和方法，<strong>不能修饰属性和构造方法</strong></li>
<li>abstract 修饰的类是抽象类，需要被继承；修饰的方法是抽象方法，需要被重写</li>
<li><strong>抽象类不一定非要有抽象方法</strong></li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li><p>static 可以修饰<strong>类、方法、变量和代码块</strong></p>
</li>
<li><p>static 修饰的类是静态内部类、修饰的方法是静态方法、修饰的变量是类变量、修饰的代码块是静态代码块</p>
</li>
<li><p><strong>static 不能用来修饰构造方法，因为 static 修饰的是与对象无关的内容，而构造确实生成对象的五大方法之一</strong></p>
</li>
</ul>
<p><strong>为什么要用 static 关键字？</strong></p>
<ul>
<li>通常来说，用 new 创建类的对象时，数据存储空间才被分配。但有时我们只想<strong>为特定域分配单一存储空间</strong>，不考虑要创建多少对象或者说根本就不创建任何对象。</li>
<li>再就是我们想<strong>在没有创建对象的情况下调用方法</strong>。在这两种情况下，static关键字，满足了我们的需求。</li>
</ul>
<p><strong>static关键字是什么意思？</strong>Java 中是否可以<strong>重写</strong>一个 private 或者是 static 的方法？</p>
<ul>
<li>static 关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</li>
<li>Java中static方法<strong>不能被重写</strong>，因为方法<strong>重写是运行时动态绑定的</strong>，而<strong>static方法是编译时静态绑定</strong>的。static方法跟类的任何实例都不相关，所以概念上不适用。</li>
</ul>
<p><strong>是否可以在 static 环境中访问非 static 资源？</strong></p>
<p><strong>不可以</strong>，当类被 Java 虚拟机载入时就会对 static 资源进行初始化，此时非 static 资源还没有被 new 创建出来，无法被 static 资源访问到。</p>
<h4 id="switch-关键字"><a href="#switch-关键字" class="headerlink" title="switch 关键字"></a>switch 关键字</h4><p>1、switch 后的变量可以是 <strong>byte</strong>、<strong>short</strong>、<strong>int</strong>、<strong>char</strong>、<strong>String</strong>、<strong>枚举类型</strong></p>
<p>2、case 之后的值必须和 switch 变量的<strong>类型一致</strong>；</p>
<p>3、default 是在没有 case 语句的值和变量值相等的时候执行。 default 不是必须的，可以不写。</p>
<p>版本迭代</p>
<ul>
<li>Java 5之前，switch(expr)中expr只能是byte、short、int、char</li>
<li>Java 5引入了枚举类型，即expr也可以是enum类型</li>
<li>Java 7开始expr还可以是String，<strong>但不支持long类型</strong></li>
<li>Java 17开始可以使用模式匹配 case … -&gt;</li>
</ul>
<h3 id="访问修饰符-public、protected、private、default"><a href="#访问修饰符-public、protected、private、default" class="headerlink" title="访问修饰符(public、protected、private、default)"></a>访问修饰符(public、protected、private、default)</h3><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>
<ul>
<li><strong>public</strong> : 对<strong>所有类</strong>可见。使用对象：类、接口、变量、方法</li>
<li><strong>protected</strong> : 对<strong>同一包下的类和所有子类</strong>可见。使用对象：变量、方法。注意：不能修饰类（外部类）。</li>
<li><strong>default</strong>: <strong>同一包内可见</strong>，不使用任何修饰符。使用对象：类、接口、变<br>量、方法。</li>
<li><strong>private</strong> : 在<strong>同一类</strong>内可见。使用对象：变量、方法。注意：<strong>不能修饰类</strong>（外部类）</li>
</ul>
<img src="/./res\image-20220819205455466.png" alt="image-20220819205455466" style="zoom:67%;">

<h3 id="重载（Overload）和重写（Override）"><a href="#重载（Overload）和重写（Override）" class="headerlink" title="重载（Overload）和重写（Override）"></a>重载（Overload）和重写（Override）</h3><img src="/./res\image-20220718094147831.png" alt="image-20220718094147831" style="zoom: 67%;">

<p>重载就是<strong>同一个类中多个同名方法根据不同的传参</strong>来执行不同的逻辑处理。</p>
<p><strong>方法的重写要遵循“两同两小一大”</strong></p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是<strong>子类方法的访问权限应比父类方法的访问权限更大</strong>或相等。</li>
</ul>
<p>关于 <strong>重写的返回值类型</strong> ：如果方法的返回类型是 void 和基本数据类型，重写时返回值不可修改。如果方法的返回值是引用类型，重写时可以返回该引用类型的子类。</p>
<h3 id="静态方法和静态变量"><a href="#静态方法和静态变量" class="headerlink" title="静态方法和静态变量"></a>静态方法和静态变量</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p><strong>类变量（静态变量）</strong>存放在<strong>堆</strong>中</p>
<p>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，都共享同一份静态变量。</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>类方法是属于类的</p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，</p>
<p>而实例方法只有<code>对象.方法名</code>这种方式。也就是说，<strong>调用静态方法可以不创建对象</strong> 。</p>
<blockquote>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
</blockquote>
<h4 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h4><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li><p><strong>静态方法是属于类的</strong>，在类加载的时候就会分配内存，可以通过<strong>类名直接访问</strong>。</p>
<p>而<strong>非静态成员属于实例对象</strong>，只有在对象实例化之后才存在，需要通过<strong>类的实例对象去访问</strong>。</p>
</li>
<li><p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ol>
<h4 id="静态变量、代码块、和静态方法的执行顺序"><a href="#静态变量、代码块、和静态方法的执行顺序" class="headerlink" title="静态变量、代码块、和静态方法的执行顺序"></a><strong>静态变量、代码块、和静态方法的执行顺序</strong></h4><p>基本上代码块分为三种：Static静态代码块、构造代码块、普通代码块</p>
<p>代码块执行顺序<strong>静态代码块——&gt; 构造代码块 ——&gt; 构造函数——&gt; 普通代码块</strong></p>
<p>继承中代码块执行顺序：<strong>父类静态变量和静态代码块（先声明的先执行）——&gt;子类静态变量和静态代码块（先声明的先执行）——&gt;父类的变量和代码块（先声明的先执行）——&gt;父类构造器——&gt;子类的变量和代码块（先声明的先执行）——&gt;子类构造器</strong></p>
<h2 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java 中有 8 种基本数据类型，分别为：</p>
<ul>
<li>6 种数字类型：<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li>1 种字符类型：<code>char</code></li>
<li>1 种布尔型：<code>boolean</code></li>
</ul>
<p><img src="/.%5Cres%5CQQ%E6%88%AA%E5%9B%BE20230524155004.png"></p>
<p>另外，对于<code>boolean</code>，官方文档未明确定义，它依赖于JVM厂商的具体实现。逻辑上理解是占用1位，但是实际中会考虑计算机高效存储因素。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/bAOPBU/">面试官竟然问我这么简单的题目：Java 中 boolean 占多少字节？我脱出而出…… - 力扣（LeetCode）</a></p>
<blockquote>
<p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）</p>
</blockquote>
<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><h4 id="基本类型和包装类型的区别"><a href="#基本类型和包装类型的区别" class="headerlink" title="基本类型和包装类型的区别"></a>基本类型和包装类型的区别</h4><p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<ul>
<li><strong>用途</strong>：除了定义一些常量和局部变量之外，在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li>
<li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>
<li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p>注意：<strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>大部分包装类都实现<strong>类常量池缓存技术</strong>，**<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code>** 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>，两种浮点数类型的包装类 <code>Float</code>，<code>Double</code> 并没有实现缓存机制。</p>
<ul>
<li><p><strong>如果要创建的数值在缓存范围内，直接从缓存中取出相应对象即可，如果超出范围需要去创建新的对象。</strong></p>
</li>
<li><p><strong>如果是通过 new 关键字来创建对象，则不管在不在缓存范围内都是一个新对象。</strong></p>
</li>
</ul>
<p>由于缓存机制，对于<strong>在 -128 到 127 之间的 Integer 可以使用 &#x3D;&#x3D; 来进行比较</strong>，但是在这个区间之外会创建新的对象，这个时候需要使用 equals 方法进行判断，因此<strong>包装类型推荐使用 equals 方法进行判断</strong>。</p>
<h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><ul>
<li><strong>装箱</strong>：将基本数据类型用它们对应的包装类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><p>这个和计算机保存浮点数的机制有很大关系。我们知道<strong>计算机是二进制的</strong>，而且计算机在表示一个数字时，宽度是有限的，<strong>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况</strong>。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>如何解决</strong></p>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>

<h3 id="超过Long的数据表示"><a href="#超过Long的数据表示" class="headerlink" title="超过Long的数据表示"></a>超过Long的数据表示</h3><p><strong><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</strong>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低</p>
<p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​	封装是指<strong>把一个对象的属性隐藏在对象内部，不允许外部直接访问</strong>，但是可以提供一些可以被外部访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p><strong>定义：继承是使用已存在的类的定义作为基础建立新类的技术</strong>，新类可以增加新的数据或方法，也可以用父类的方法，但<strong>不能选择性地继承父类</strong>。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
</li>
<li><p><strong>关于继承如下 3 点请记住：</strong></p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是<strong>父类中的私有属性和方法子类是无法访问的</strong>，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul>
<li><p><strong>定义</strong>：表示一个对象具有多种状态，具体表现为<strong>父类的引用指向子类的实例</strong>。</p>
</li>
<li><p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量调用的方法到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类的方法，如果子类没有重写父类的方法，执行的是父类的方法。</li>
</ul>
</li>
<li><p><strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：<strong>Parent p &#x3D; new Child();</strong></li>
</ul>
</li>
<li><p><strong>多态的实现方式</strong></p>
<ul>
<li><p><strong>方式一：重写：</strong></p>
</li>
<li><p><strong>方式二：接口</strong></p>
<p>1、生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</p>
<p>2、java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-interfaces.html">java接口</a> 这一章节的内容。</p>
</li>
<li><p><strong>方式三：抽象类和抽象方法</strong></p>
<p>详情请看 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-abstraction.html">Java抽象类</a> 章节。</p>
</li>
</ul>
</li>
<li><p><strong>多态的优点</strong></p>
<p>可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<ul>
<li>提高了程序的扩展性</li>
<li>降低了代码之间的耦合</li>
</ul>
</li>
</ul>
<p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法</strong>，<strong>如果没有，则编译错误；如果有，再去调用子类的同名方法</strong>。</p>
<h3 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h3><ul>
<li>面向过程把解决问题的过程<strong>拆成一个个方法</strong>，通过一个个方法的执行解决问题。</li>
<li>面向对象会先<strong>抽象出对象</strong>，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>面向对象开发的程序一般<strong>更易维护、易复用、易扩展。</strong></p>
<blockquote>
<p><strong>面向过程 ：面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发。</p>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，<strong>而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机器码。</strong></p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。</p>
</blockquote>
<h3 id="对象相等和引用相等"><a href="#对象相等和引用相等" class="headerlink" title="对象相等和引用相等"></a>对象相等和引用相等</h3><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）</p>
<ul>
<li>对象相等一般比较的是内存中存放的<strong>内容</strong>是否相等。</li>
<li>引用相等一般比较的是他们指向的<strong>内存地址</strong>是否相等。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><strong>类的构造方法的作用是什么?</strong></p>
<ul>
<li>构造方法是一种特殊的方法，主要作用是<strong>完成对象的初始化工作</strong>。</li>
</ul>
</li>
<li><p><strong>如果一个类没有声明构造方法，该程序能正确执行吗?</strong></p>
<ul>
<li>如果一个类没有声明构造方法，<strong>会有默认的不带参数的构造方法</strong>。</li>
<li>如果我们<strong>自己添加了类的构造方法</strong>（无论是否有参），<strong>Java 就不会再添加默认的无参数的构造方法</strong>。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</li>
</ul>
</li>
<li><p><strong>构造方法有哪些特点？</strong></p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
</li>
<li><p><strong>构造方法不能被 override（重写）</strong>，但是可以 <strong>overload（重载）</strong>，<strong>一个类中可以有多个构造函数</strong>。</p>
</li>
</ul>
<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>定义：抽象方法和常量值的集合(所有的方法都是抽象方法)。它是**一种特殊的抽象类(会生成一个 xxx.class 文件，编译器会自动在 interface 关键字前加上 abstract)**。</p>
<p>特点：</p>
<ul>
<li><p>接口中定义的方法，默认加 **public abstract ** (如果是什么都不写，编译器会自动帮你写上)</p>
</li>
<li><p>接口中可以定义 default 方法</p>
</li>
<li><p>接口中定义的变量，全部为全局常量，默认加 <strong>public static final</strong> (如果什么都不写，<strong>编译器会自动帮你写上</strong>)</p>
</li>
<li><p>接口可以用 extends 继承已有的接口。</p>
</li>
<li><p>类可以用 implements 实现<strong>一个或多个接口</strong>中的<strong>所有</strong>方法(包括这个接口的<strong>父接口中的方法</strong>)</p>
</li>
<li><p>抽象类可以用 implements 实现接口中的<strong>部分方法</strong></p>
</li>
<li><p>类可以 extends 一个父类的同时 implements 多个接口，但是 extends 关键字必须在 implements 关键字之前。</p>
</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>定义：抽象类是它所有子类的公共属性的集合</p>
<p>特点：</p>
<ul>
<li>抽象类，其修饰符必须为 public 或者 protected，不能是 private，因为创建抽象类，就是要被其他类继承，用 private 修饰了，则不能被子类继承，子类便无法实现该方法。</li>
<li>抽象类可以有抽象方法，但是不一定非要有抽象方法</li>
<li>抽象类不能用来创建对象，即抽象类不能被直接实例化，要通过其普通子类进行实例化。</li>
<li>如果一个普通子类继承一个抽象父类，子类一定要重写父类的抽象方法。如果该子类仍然是一个抽象类，这也是允许的，就不必重写实现该父类的抽象方法，但必须用abstract修饰。</li>
<li>抽象级别：抽象类是对整体类的抽象，包含属性和方法。</li>
<li>实现类的范围不同：抽象类，其实是从子类中提取共性部分，然后抽象出来，反之，子类继承该父类就可以了，也就是说里面的抽象方法一般来自同一个类别。</li>
<li>设计方式不同：抽象类是要先有子类，然后才抽象出父类，是一种从下往上的构建法则。</li>
</ul>
<h4 id="共同点和区别"><a href="#共同点和区别" class="headerlink" title="共同点和区别"></a>共同点和区别</h4><p><strong>共同点</strong> ：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li><strong>都可以有默认实现的方法</strong>（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong> ：</p>
<ul>
<li>接口主要用于<strong>约束类的行为，实现了某个接口就有了对应的行为</strong>。抽象类是对一种事物的抽象，<strong>主要用于代码复用，强调的是所属关系</strong>。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的<strong>成员变量</strong>只能是 <code>public static final</code> 类型的，<strong>不能被修改且必须有初始值</strong>，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法</li>
</ul>
<h3 id="深拷贝、浅拷贝、引用拷贝"><a href="#深拷贝、浅拷贝、引用拷贝" class="headerlink" title="深拷贝、浅拷贝、引用拷贝"></a>深拷贝、浅拷贝、引用拷贝</h3><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象，如果原对象的属性是引用类型，浅拷贝会直接复制原对象属性的引用地址。Object 类的clone() 方法采用的是浅拷贝。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，在内存中生成一个新的对象。</li>
<li><strong>引用拷贝</strong> ：引用拷贝就是两个不同的引用指向同一个对象。</li>
</ul>
<img src="/./res\shallow&deep-copy.8d5a2e45.png" alt="img" style="zoom:50%;">

<h4 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h4><p>实现了 <code>Cloneable</code> 接口，并重写 <code>clone()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (A) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h4><p>（不推荐）递归实现所有对象的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">A</span> <span class="variable">clone</span> <span class="operator">=</span> (A) <span class="built_in">super</span>.clone();</span><br><span class="line">            clone.b = <span class="built_in">this</span>.b.clone();</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（推荐）通过序列化(Serializable)的方法，将对象写到流里，然后再从流中读取出来，实现深拷贝。可以直接使用序列化工具进行序列化和反序列化，例如JSON。</p>
<h2 id="重要的类（Object、String）"><a href="#重要的类（Object、String）" class="headerlink" title="重要的类（Object、String）"></a>重要的类（Object、String）</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">// native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">// naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">// 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">// native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">// native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">// native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>



<h4 id><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h4><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code> 方法存在于 <code>Object</code> 类中，而 <code>Object</code> 类是所有类的直接或间接父类，因此所有的类都有 <code>equals()</code> 方法。</p>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象的属性是否相等；若它们的属性相等，则返回 true</li>
</ul>
<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有对象的值和要创建的对象的值相同，如果有就把这个对象赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode()"></a>hashcode()</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><img src="/.%5Cres%5Cjava-hashcode-method.png" alt="hashCode() 方法"></p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>
<p><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进 <code>HashSet</code> 的过程）！</p>
<p>我们在前面也提到了添加元素进 <code>HashSet</code> 的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的 <code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象返回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p><strong>总结下来就是：</strong></p>
<ul>
<li>如果两个对象的 <code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的 <code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，才认为这两个对象相等。</li>
<li>如果两个对象的 <code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<p><strong>为什么重写 equals() 时必须重写 hashCode() 方法？</strong></p>
<p>因为两个相等的对象的 <code>hashCode</code> 必须相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 却不相等。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><p><strong>作用</strong></p>
<ul>
<li>使当前的线程进行等待</li>
<li>释放当前的锁；</li>
<li>被唤醒时，重新尝试获取这个锁</li>
</ul>
<p><strong>用法</strong></p>
<p>需要和 <strong>synchronized</strong> 配合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>过程分析</strong></p>
<ol>
<li>线程获取被 synchronized 修饰的 object 的锁（monitor）</li>
<li>线程调用 object.wait() 方法</li>
<li>线程释放 object 的锁，并立即进入</li>
</ol>
<p><strong>结束条件</strong></p>
<p><strong>wait结束等待的条件 :</strong></p>
<ul>
<li>其他线程（也可以不是线程）调用了该对象的 notify 或 notifyAll 方法</li>
<li>其他线程（也可以不是线程）调用该等待线程的 interrupted 方法</li>
<li>等待时间超时：wait（有参）</li>
</ul>
<p>注意:wait(0)表示的是无限等待</p>
<h4 id="notifiy"><a href="#notifiy" class="headerlink" title="notifiy()"></a>notifiy()</h4><p><strong>作用</strong></p>
<ul>
<li>notify()： 唤醒一个与该锁对象关联的在等待队列中的线程，一次唤醒一个，而且是任意的。</li>
<li>notifyAll()：唤醒全部：可以将线程池中的所有 wait() 线程都唤醒。</li>
</ul>
<p><strong>用法</strong></p>
<p>需要和 <strong>synchronized</strong> 配合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object object=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        object.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p><strong>wait 结束等待的条件 :</strong></p>
<ul>
<li>1.其他线程（也可以不是线程）调用了该对象的notify或notifyAll方法</li>
<li>2.其他线程（也可以不是线程）调用该等待线程的interrupted方法</li>
<li>3.等待时间超时：wait（有参）</li>
</ul>
<p>注意:wait(0)表示的是无限等待</p>
<h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。<strong>JDK1.7 字符串常量池被从方法区拿到了堆中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aa&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>使用 new 关键字创建一个字符串对象时，Java 虚拟机会<strong>先在字符串常量池中查找有没有值为 “aa” 的字符串对象</strong>。</p>
<ul>
<li><strong>如果没有</strong>，<strong>先在字符串常量池中创建一个 ‘aa’ 的字符串对象，然后再在堆中创建一个 ‘aa’ 的字符串对象</strong>，然后将堆中 ‘aa’ 字符串对象的地址赋值给变量 s。</li>
<li><strong>如果有</strong>，就<strong>不会在字符串常量池中创建 ‘aa’ 对象，直接在堆中创建 ‘aa’ 的字符串对象</strong>，然后将堆中 ‘aa’ 对象的地址赋值给变量s。</li>
</ul>
<p>通常情况下会<strong>采用双引号的方式</strong>来创建字符串对象，而不是通过 new 关键字的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 String s &#x3D; “bb” 时，会先在字符串常量池中查找有没有 “bb” 这个字符串对象。<br><strong>如果有，不创建任何对象，直接返回字符串常量池中 “bb” 对象的地址</strong>，赋给变量 s；<br><strong>如果没有，在字符串常量池中创建“bb”对象，然后将其地址返回</strong>，赋给变量 s。</li>
<li>有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了。</li>
<li><strong>new 的方式始终会在堆中创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。</strong></li>
</ul>
<h4 id="String-的-equals"><a href="#String-的-equals" class="headerlink" title="String 的 equals()"></a>String 的 equals()</h4><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h4 id="String-的-intern"><a href="#String-的-intern" class="headerlink" title="String 的 intern()"></a>String 的 intern()</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是<strong>将指定的字符串对象的引用保存在字符串常量池中</strong>，可以简单分为两种情况：</p>
<ul>
<li>如果<strong>字符串常量池中保存了</strong>对应的字符串对象的引用，就<strong>直接返回该引用</strong>。</li>
<li>如果<strong>字符串常量池中没有保存</strong>了对应的字符串对象的引用，那就在常量池中<strong>创建</strong>一个指向该字符串对象的<strong>引用并返回</strong>。</li>
</ul>
<h4 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h4><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（底层是 final 修饰的 char[]）</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[]; </span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p><code>String</code> 对象是不可变的，线程安全。</p>
<p><code>StringBuffer</code> 对方法加了同步锁，是<strong>线程安全</strong>的。</p>
<p><code>StringBuilder</code> 没有对方法加同步锁，是<strong>非线程安全</strong>的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型的变量进行修改，都会生成一个新的 <code>String</code> 对象，然后将新的 <code>String</code> 对象的地址赋值给变量。</p>
<p><code>StringBuffer</code> 每次都是对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象。</p>
<p>相同情况下使用 <code>StringBuilder</code> 比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h4 id="、"><a href="#、" class="headerlink" title="+、+&#x3D;"></a>+、+&#x3D;</h4><p>Java 语言本身并不支持运算符重载，“+” 和 “+&#x3D;” 是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<p><strong>字符串对象通过 “+” 的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</strong></p>
<p><strong>在循环内使用 “+” 进行字符串的拼接</strong>的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac  编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Exception-和-Error"><a href="#Exception-和-Error" class="headerlink" title="Exception 和 Error"></a>Exception 和 Error</h3><p>在 Java 中，<strong>所有的异常</strong>都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类：</p>
<ul>
<li><strong><code>Exception</code></strong> ：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception </code> 又可以分为<strong>运行时异常</strong>(<strong>RuntimeException</strong>, 又叫<strong>非受检查异常</strong>，可以不处理)和<strong>非运行时异常</strong>(又叫<strong>受检查异常</strong>，必须处理) 。<ul>
<li><strong>运行时异常</strong>：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。<code>NullPointerException</code><strong>(空指针异常)<strong>，<code>IndexOutOfBoundsException</code><strong>（数组越界异常）</strong>，<code>ClassCastException</code>（</strong>类型转换异常</strong>），<code>NumberFormatException</code>（<strong>字符串转换为数字格式异常）</strong>等。</li>
<li><strong>非运行时异常</strong>：除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</li>
<li><strong>区别</strong>：<strong>受检查异常</strong>没有被 <code>catch</code> 或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<strong>非受检查异常</strong> ，Java 代码在编译过程中 ，我们即使<strong>不处理非受检查异常也可以正常通过编译</strong>。</li>
</ul>
</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，不建议通过 <code>catch</code> 捕获 。例如 Java 虚拟机运行错误（<code>Virtual Machine Error</code>）、虚拟机内存不足错误 (<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>），<code>StackOverflowError</code> 堆栈溢出错误等 。这些异常发生时，Java 虚拟机一般会选择线程终止。</li>
</ul>
<blockquote>
<p>为什么不该捕获 Error 呢？<strong>Error 是指不应该被捕获的严重错误</strong>，出现 Error 会导致程序无法运行，捕获了也没有任何意义。</p>
</blockquote>
<h3 id="运行时异常和一般异常"><a href="#运行时异常和一般异常" class="headerlink" title="运行时异常和一般异常"></a>运行时异常和一般异常</h3><p>Checked Exception 和 Unchecked Exception 有什么区别？</p>
<ul>
<li><p><strong>非受检查异常（运行时异常）</strong>：包括 <code>RuntimeException</code> 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>
<ul>
<li><code>NullPointerException</code><strong>(空指针异常)</strong></li>
<li><code>IllegalArgumentException</code>(参数异常，比如方法传入参类型异常)</li>
<li><code>NumberFormatException</code>（<strong>字符串转换为数字格式错误</strong>，<code>IllegalArgumentException</code>的子类）</li>
<li><code>IndexOutOfBoundsException</code><strong>（数组越界异常）</strong></li>
<li><code>ClassCastException</code>（<strong>类型转换异常</strong>）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li>ArrayStoreException (<strong>数据存储异常</strong>，操作数组时类型不一致)</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
</li>
<li><p><strong>受检查异常（一般异常）</strong>：除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>等。</p>
</li>
<li><p><strong>区别</strong>：<strong>受检查异常</strong>没有被 <code>catch </code>或者 <code>throws</code> 关键字处理的话，就没办法通过编译。<strong>非受检查异常</strong> ，Java 代码编译过程中 ，即使<strong>不处理非受检查异常也可以正常通过编译</strong>。</p>
</li>
</ul>
<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><strong>出现异常时将异常捕获，并自定义相应的处理方法。</strong></p>
<ul>
<li><code>try</code> 块 ：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code> 块 ：用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块 ：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中有 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>注意：不要在 finally 语句块中使用 return</strong>！当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<p><strong>catch 可以省略</strong>。更为严格的说法其实是：<strong>try <strong>只适合处理</strong>运行时异常</strong>，<strong>try + catch <strong>适合处理</strong>运行时异常+普通异常</strong>。也就是说，如果你只用 try 去处理普通异常却不加以 catch 处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用 catch 显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以 catch 可以省略，加上 catch 编译器也觉得无可厚非。</p>
<h4 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h4><p>遇到问题不进行具体处理，而是继续抛给调用者。</p>
<p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以<strong>通过 <code>throws</code>关键字在方法上声明该方法要拋出的异常</strong>，或者<strong>在方法内部通过<code> throw</code> 拋出异常对象</strong>。</p>
<ul>
<li><strong>throw</strong> 关键字用<strong>在方法内部</strong>，只能抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>
<li><strong>throws</strong> 关键字用<strong>在方法声明上</strong>，<strong>可以抛出多个异常</strong>，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>
</ul>
<h4 id="异常使用时需要注意的点"><a href="#异常使用时需要注意的点" class="headerlink" title="异常使用时需要注意的点"></a>异常使用时需要注意的点</h4><ul>
<li><p>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</p>
<p>怎么理解  <strong>异常定义为静态变量，会导致异常栈信息错乱</strong></p>
<p>类似于定义一个Exceptions类来汇总所有的异常，把异常存放在静态字段中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exceptions</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">BusinessException</span> <span class="variable">ORDEREXISTS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;订单已经存在&quot;</span>, <span class="number">3001</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把异常定义为静态变量<strong>会导致异常信息固化</strong>，这就和异常的栈一定是需要根据当前调用来动态获取相矛盾。</p>
</li>
<li><p>抛出的异常信息一定要有意义。</p>
</li>
<li><p>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</p>
</li>
<li><p>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</p>
</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>定义</strong>：泛型是 JDK1.5 的一个新特性，本质是指<strong>类型参数化，在编译时才确定具体的参数。</strong>可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>
<p><strong>泛型的作用</strong>:</p>
<ul>
<li>使用泛型可在编译期间进行类型检测。</li>
<li>使用 object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li>
<li>泛型可以使用自限定类型如 T extends Comparable</li>
</ul>
<blockquote>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Persion&gt; persons = new ArrayList&lt;Persion&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Persion</code> 对象，如果传入其他类型的对象就会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
</blockquote>
<h3 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h3><p><strong>泛型类</strong>：在类名后面添加类型参数声明部分，可以包含一个或多个类型参数，参数间用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型接口</strong> ：实现泛型接口，可以选择指定或者不指定类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型方法</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p><strong>Java 的泛型是伪泛型，在编译期间，会擦除所有的泛型信息，也就是通常所说类型擦除。</strong>编译器在编译期间会动态地将泛型 <code>T</code> 擦除为 <code>0bject</code> 或将 <code>T extends xxx</code> 擦除为限定类型 <code>xxx</code>。</p>
<p>类型擦除的目的是<strong>通过擦除将泛型类转化为一般类，保证引入泛型机制的同时不创建新的类型，减少虚拟机的运行开销。</strong></p>
<p><strong>既然编译器要把泛型擦除，那为什么还要用泛型呢？用 Object 代替不行吗?</strong><br>这个问题其实在变相考察<strong>泛型的作用</strong>:</p>
<ul>
<li>使用泛型可在编译期间进行类型检测。</li>
<li>使用 Object 类型需要手动添加强制类型转换，降低代码可读性，提高出错概率。</li>
<li>泛型可以使用自限定类型如 T extends Comparable</li>
</ul>
<h3 id="泛型的限制"><a href="#泛型的限制" class="headerlink" title="泛型的限制"></a>泛型的限制</h3><p>泛型的限制一般是由泛型擦除机制导致的。擦除为 Object 后无法进行类型判断</p>
<ul>
<li>只能声明不能实例化T类型变量。</li>
<li><strong>泛型参数不能是基本类型</strong>。因为基本类型不是Object子类，应该用基本类型对应的<strong>引用类型</strong>代替。</li>
<li>不能实例化泛型参数的数组。擦除后为Object后无法进行类型判断。</li>
<li>不能实例化泛型数组。</li>
<li>泛型无法使用 Instance of 和 getclass() 进行类型判断。</li>
<li>不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突</li>
<li><strong>不能使用 static 修饰泛型变量</strong></li>
</ul>
<blockquote>
<p><strong>关于静态方法为什么不能使用类的泛型</strong>？</p>
<p>泛型只是一个占位符，必须传递类型后才能使用。而<strong>类实例化时才能真正的的传递类型参数</strong>，但是<strong>静态方法的加载先于类的实例化</strong></p>
</blockquote>
<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>泛型类型是固定的，某些场景下使用起来不太灵活，于是，通配符就来了。通配符可以允许类型参数变化，用来解决泛型无法协变的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制类型为 Person 的子类</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// 限制类型为 Manager 的父类</span></span><br><span class="line">&lt;? <span class="built_in">super</span> Manager&gt;</span><br></pre></td></tr></table></figure>

<h4 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h4><ul>
<li><p><strong>限定通配符</strong>：对类型进行了限制。有两种限定通配符，</p>
<ul>
<li><strong>上边界通配符</strong>：&lt;? extends T&gt;它通过<strong>确保类型必须是T的子类来设定类型的上界</strong>，</li>
<li><strong>下边界通配符</strong>：&lt;? super T&gt;它通过<strong>确保类型必须是T的父类来设定类型的下界</strong>。</li>
<li>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</li>
</ul>
</li>
<li><p><strong>非限定通配符 ？</strong>:可以用任意类型来替代。如List&lt;?&gt; 的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A> ，也可以是List<B> ,或者List<C> 等等。</C></B></A></p>
</li>
</ul>
<h4 id="通配符-和常用的泛型-T-之间有什么区别"><a href="#通配符-和常用的泛型-T-之间有什么区别" class="headerlink" title="通配符 ? 和常用的泛型 T 之间有什么区别?"></a>通配符 <code>?</code> 和常用的泛型 T 之间有什么区别?</h4><ul>
<li>T 可以用于声明变量或常量而 <code>?</code> 不行。</li>
<li>T 一般用于声明泛型类或方法，通配符 <code>?</code> 一般用于泛型方法的调用代码和形参。</li>
<li>T 在编译期会被擦除为限定类型或 0bject，通配符用于捕获具体类型。</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射赋予了我们<strong>在运行时分析类以及执行类中方法的能力</strong>。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>
<h3 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h3><p><strong>优点</strong> ： 可以让<strong>代码更加灵活</strong>、为各种框架提供开箱即用的功能。</p>
<p><strong>缺点</strong> ：让我们<strong>在运行时有了分析操作类的能力</strong>，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<h3 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h3><p>[Java获取反射的四种方法](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/firecode7/p/13268311.html#:~:text=Java%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95">https://www.cnblogs.com/firecode7/p/13268311.html#:~:text=Java获取反射的四种方法</a> 1. 通过new对象实现反射机制（ 对象.getClass (),） 2. 通过路径实现反射机制（ Class.forName (“包名.类名”) ）)</p>
<ol>
<li><p>通过new对象实现反射机制（对象.getClass() ）</p>
</li>
<li><p>通过路径实现反射机制（Class.forName(“包名.类名”) ）</p>
</li>
<li><p>通过类名实现反射机制 （类名.Class）</p>
</li>
<li><p>通过类加载器 <code>xxxClassLoader.loadClass()</code>传入类路径获取：通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p>
</li>
</ol>
<h3 id="反射使用的步骤"><a href="#反射使用的步骤" class="headerlink" title="反射使用的步骤"></a>反射使用的步骤</h3><ol>
<li>反射的核心就是获取想要操作的类的 Class 对象，通过 Class 对象可以调用类中任意方法。</li>
<li>调用 Class 类中的方法，就是反射的使用阶段。</li>
<li>使用反射 API 来操作这些信息。</li>
</ol>
<p>一般情况下我们使用反射获取一个对象的步骤：</p>
<ol>
<li><p>获取类的 Class 对象实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.zhenai.api.Apple&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 Class 对象实例获取 Constructor 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">appleConstructor</span> <span class="operator">=</span> clz.getConstructor();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Constructor 对象的 newInstance() 方法获取反射类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">appleObj</span> <span class="operator">=</span> appleConstructor.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 Class 对象获取方法的 Method 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">setPriceMethod</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 invoke() 方法调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setPriceMethod.invoke(appleObj, <span class="number">14</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="反射机制的原理"><a href="#反射机制的原理" class="headerlink" title="反射机制的原理"></a>反射机制的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class actionClass=Class.forName(“MyClass”); </span><br><span class="line">Object action=actionClass.newInstance(); </span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> actionClass.getMethod(“myMethod”,<span class="literal">null</span>); </span><br><span class="line">method.invoke(action,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Class.forName()</code>：获取对应类的 Class 对象，如果类还没有加载则由 JVM 先进行类的加载</li>
<li><code>actionClass.newInstance()</code>： 主要做了三件事<ul>
<li>权限检测，如果不通过直接抛出异常；</li>
<li>查找无参构造器，并将其缓存起来；</li>
<li>调用具体方法的无参构造方法，生成实例并返回。</li>
</ul>
</li>
<li><code>actionClass.getMethod(“myMethod”,null)</code>：<strong>获取 Method 对象</strong>，JVM 为每个类管理一个独一无二的 Class 对象，Class 对象里维护了该类的所有 Method，Field，Constructor 的 cache，这份 cache 也可以被称作根对象。每次 getMethod 获取到的Method对象都持有对根对象的引用，所有代表<strong>同一个方法的Method对象都共享着根对象的 MethodAccessor</strong>，每一次创建都会调用根对象的copy方法复制一份</li>
<li><code>method.invoke(action,null)</code>：调用Method.invoke之后，会直接去调MethodAccessor.invoke。MethodAccessor就是上面提到的所有同名method共享的一个实例，由ReflectionFactory创建。</li>
</ul>
<img src="/./res\image-20220818144823351.png" alt="image-20220818144823351" style="zoom:67%;">

<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<ul>
<li>反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。</li>
<li>反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。</li>
<li>测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。</li>
</ul>
<p><strong>实例1 JDBC数据库连接</strong></p>
<p>在JDBC 的操作中，如果要想进行数据库的连接</p>
<ol>
<li><strong>通过<code>Class.forName()</code>加载数据库的驱动程序 （通过反射加载</strong>，前提是引入相关了Jar包）；</li>
<li>通过<code>DriverManager</code>类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码；</li>
<li>通过Connection 接口接收连接。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionJDBC</span> &#123;</span><br><span class="line">    <span class="comment">//驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBDRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="comment">//连接地址是由各个数据库生产商单独提供的，所以需要单独记住</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBURL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    <span class="comment">//连接数据库的用户名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBUSER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="comment">//连接数据库的密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DBPASS</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//表示数据库的连接对象</span></span><br><span class="line">        Class.forName(DBDRIVER); <span class="comment">//1、使用CLASS 类加载驱动程序 ,反射机制的体现</span></span><br><span class="line">        con = DriverManager.getConnection(DBURL, DBUSER, DBPASS); <span class="comment">//2、连接数据库</span></span><br><span class="line">        System.out.println(con);</span><br><span class="line">        con.close(); <span class="comment">// 3、关闭数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例2 JDK动态代理</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理类中的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。获取到注解之后，就可以做进一步的处理。</p>
<p><strong>实例3 Spring 框架的使用</strong></p>
<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>
<ol>
<li>将程序内所有 XML 或 Properties 配置文件加载到内存中；</li>
<li>解析 xml 或 properties 里面的内容，得到对应实体类的字节码字符串及相关属性信息；</li>
<li><strong>利用反射机制，根据字节码字符串获得类的 Class 实例；</strong></li>
<li>动态配置 Class 实例的属性。</li>
</ol>
<p>Spring这样做的好处是：</p>
<ul>
<li>不用每一次都要在代码里面去new或者做其他的事情；</li>
<li>以后要改的话直接改配置文件，代码维护起来就很方便了；</li>
<li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annotation</code> 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量</p>
<p>注解本质<strong>是一个继承了 <code>Annotation</code> 的特殊接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以<strong>自定义注解</strong></p>
<h3 id="注解的类型"><a href="#注解的类型" class="headerlink" title="注解的类型"></a>注解的类型</h3><p>Java注解分类的话，大致可以分为三类，分别是标准注解，元注解与自定义注解。</p>
<h4 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h4><p>标准注解就是 java 内置的注解，主要有 @Override，@Deprecated，@SuppressWarnings，@FunctionalInterface</p>
<ul>
<li><p><strong>@Override：</strong>检查该注解标注的方法是否是重写方法，如果不是重写方法的话编译会不通过会报错。</p>
</li>
<li><p><strong>@Deprecated：</strong>标记该方法可能要废弃了，使用的话会报个警告。</p>
</li>
<li><p><strong>@SuppressWarnings：</strong>告诉编译器忽视一些警告。其常见的参数有：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">deprecation</td>
<td align="center">使用了不赞成使用的类或方法的警告</td>
</tr>
<tr>
<td align="center">unchecked</td>
<td align="center">执行了未检查的转换时的警告，例如使用集合时没有用泛型来指定集合保存的类型</td>
</tr>
<tr>
<td align="center">fallthrough</td>
<td align="center">当switch程序块两个case之间没有break时</td>
</tr>
<tr>
<td align="center">path</td>
<td align="center">在类路径，源文件路径中有不存在的路径时的警告</td>
</tr>
<tr>
<td align="center">serial</td>
<td align="center">在可序列化的类上缺少serialVersionUID定义时的警告</td>
</tr>
<tr>
<td align="center">all</td>
<td align="center">所有的警告</td>
</tr>
</tbody></table>
</li>
<li><p><strong>@FunctionalInterface:</strong> 用于指示被修饰的接口是函数式接口，在 jdk8 被引入</p>
</li>
</ul>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>主要有 @Retention，@Documented，@Target，@Inherited，@Repeatable</p>
<ul>
<li><p><strong>@Retention：</strong>用来定义注解的生命周期，一个注解只能定义一个级别。具体有三个级别：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE</td>
<td>在编译时被丢弃，不包含在类文件中，既不参与编译也不能在运行时被获取到</td>
</tr>
<tr>
<td>CLASS</td>
<td>JVM 加载时被丢弃，包含在类文件中，但是不能在运行时被获取到，默认值</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>由 JVM 加载并包含在类文件中，能在运行时被获取到，一般开发自定义注解使用该级别</td>
</tr>
</tbody></table>
<p>三者是包含关系 source（javac编译时丢弃），class（.class被加载前丢弃），runtime（jvm会将其加载在类文件里）</p>
</li>
<li><p><strong>@Documented：</strong>被该元注解修饰的注解能出现在 javadoc 中，如果没有被该元注解修饰，则不会出现在 javadoc 中</p>
</li>
<li><p><strong>@Target：</strong>用来表示该注解的适用范围，一个注解可以有多个适用范围，每个使用范围之间在大括号内用逗号隔开。如：<br><code>@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</code><br>使用范围的值总共有十个：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TYPE</td>
<td align="center">应用于类、接口(包括注解类型)或枚举</td>
</tr>
<tr>
<td align="center">FIELD</td>
<td align="center">应用于字段(包括枚举常量)</td>
</tr>
<tr>
<td align="center">METHOD</td>
<td align="center">应用于方法</td>
</tr>
<tr>
<td align="center">PARAMETER</td>
<td align="center">应用于方法的参数</td>
</tr>
<tr>
<td align="center">CONSTRUCTOR</td>
<td align="center">应用于构造函数</td>
</tr>
<tr>
<td align="center">LOCAL_VARIABLE</td>
<td align="center">应用于局部变量</td>
</tr>
<tr>
<td align="center">ANNOTATION_TYPE</td>
<td align="center">应用于注解</td>
</tr>
<tr>
<td align="center">PACKAGE</td>
<td align="center">应用于包</td>
</tr>
<tr>
<td align="center">TYPE_PARAMETER</td>
<td align="center">应用于类型参数，JDK1.8引入</td>
</tr>
<tr>
<td align="center">TYPE_USE</td>
<td align="center">应用于任何类型，JDK1.8引入</td>
</tr>
</tbody></table>
</li>
<li><p><strong>@Inherited：</strong>该注解说明子类可以继承父类的注解，被该元注解修饰的注解，能够在子类继承父类的时候把注解也继承过去。但是，被该元注解修饰的注解只有应用在类上的时候才能够被继承过去，应用在方法或其他地方时是没有的。</p>
</li>
<li><p><strong>@Repeatable：</strong>被该元注解修饰的注解能够重复使用，也就是可以在一个方法上使用多次该注解，可以说将该注解用一个数组容器包了起来。</p>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>自定义注解大致可以分为三步：1.定义注解，2.配置注解，3.解析注解</p>
<p><strong>定义注解 也就是声明一个注解，创建一个注解对象</strong></p>
<p>注解与方法、变量、枚举等声明方式相似，唯一不同的是其关键字为@interface，也就是只要是声明时使用了该关键字，底层在实现的时候都会继承java.lang.annotation.Annotation接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注解的方法体里面只能写一个东西：注解类型元素，也就是注解的属性。其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 数据类型 属性名() default 默认值;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中修饰符必须是public，所以可以直接不写，其默认值即是public</li>
<li>其中可以写的数据类型有：八种基本类型(int，short，long，double，byte，char，boolean，float)，String，Class，注解类型，枚举类以及上面任一种类型的数组形式。</li>
<li>其中的属性名是自定义的</li>
<li>其中的()并不是定义参数的地方，只是一种语法而已</li>
</ul>
<p>default表示该属性的默认值，其默认值与前面的数据类型一致，有个要注意的点是如果没有设置默认值，则该注解在使用的时候一定要赋值。如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">@interface</span> LogAnnotation &#123;</span><br><span class="line">    <span class="comment">// 值描述</span></span><br><span class="line">    String <span class="built_in">value</span>() default &quot;&quot;;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    String <span class="built_in">name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置注解-也就是对上面定义的注解配置其作用范围及生命周期</strong></p>
<p>配置注解则是利用上面记录的几种元注解对自定义的注解进行修饰，来描述自定义注解的生命周期与作用范围。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line">    <span class="comment">// 值描述</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析注解-也就是在程序运行时检测注解，并进行一系列操作</strong></p>
<p>注解的解析主要是通过java的反射来实现的，可以通过反射来获取相应的类、方法或字段，通过获取的类、方法、字段来判断其上是否使用了该注解，使用的话则获取该注解与该注解内各个元素的值。例子如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mcj.music.<span class="keyword">annotation</span>;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAnnotation</span> &#123;</span><br><span class="line">    <span class="meta">@LogAnnotation(name = <span class="string">&quot;mcj&quot;</span>, value = <span class="string">&quot;10.09测试&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> void printString() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;输出一个字符串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;TestAnnotation&gt; testAnnotationClass = TestAnnotation.<span class="keyword">class</span>;</span><br><span class="line">        Method[] methods = testAnnotationClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(LogAnnotation.<span class="keyword">class</span>)) &#123;</span><br><span class="line">                LogAnnotation <span class="keyword">annotation</span> = method.getAnnotation(LogAnnotation.<span class="keyword">class</span>);</span><br><span class="line">                String name = <span class="keyword">annotation</span>.name();</span><br><span class="line">                String value = <span class="keyword">annotation</span>.value();</span><br><span class="line">                System.<span class="keyword">out</span>.println(String.format(<span class="string">&quot;方法%s用了LogAnnotation注解，注解值name为：%s，value为：%s&quot;</span>, method.getName(), name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解的解析方法"><a href="#注解的解析方法" class="headerlink" title="注解的解析方法"></a>注解的解析方法</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用 <code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者网络传输 Java 对象，都需要用到序列化。</p>
<ul>
<li><strong>序列化</strong>： 序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。</li>
<li><strong>反序列化</strong>：将在序列化过程中生成的二进制字节流转换成对象的过程</li>
</ul>
<p>核心作用是<strong>对象状态的保存与重建</strong>。Java对象保存在 JVM 堆内存中，如果 JVM 堆不存在了，对象也就跟着消失了。</p>
<h3 id="Java-IO流分类"><a href="#Java-IO流分类" class="headerlink" title="Java IO流分类"></a>Java IO流分类</h3><ul>
<li><p>按照流的方向：输入流（inputStream）和输出流（outputStream）；</p>
</li>
<li><p>按照处理数据的单位： <strong>字节流和字符流</strong>。</p>
</li>
<li><p>按照实现功能分：<strong>节点流</strong>（可以从或向一个特定的地方读写数据，如 FileReader）和<strong>处理流</strong>（是对一个已存在的流的连接和封装，通过封装的流的功能实现读写， 如BufferedReader，<strong>处理流的构造方法总是要带一个其他的流对象做参数</strong>。一个流对象经过其他流的多次包装，称为流的链接。）</p>
</li>
</ul>
<p>Java IO 流的 40 多个类都是从如下 <strong>4 个抽象类基类</strong>中派生出来的。</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是<strong>字节输入流</strong>，后者是<strong>字符输入流</strong>。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是<strong>字节输出流</strong>，后者是<strong>字符输出流</strong>。</li>
</ul>
<h4 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h4><ul>
<li><p><strong>字节流</strong>：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节</strong></p>
</li>
<li><p><strong>字符流</strong>：如果我们不知道编码类型的话，使用字节流很容易出现乱码问题，所以就需要字符流。但是<strong>字符流</strong>是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>字节</strong>流操作的基本单位是<strong>字节</strong>，<strong>字符流</strong>操作的基本单位是<strong>字符</strong>(2个字节)</li>
<li><strong>字节流</strong>通常用于<strong>处理二进制数据</strong>，<strong>字符流</strong>通常<strong>处理文本数据</strong>。</li>
<li><strong>字符流处理文本</strong>要比字节流处理文本<strong>要方便</strong>。</li>
<li>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择<strong>字符流</strong>。只是读写文件，和文件内容无关时，一般选择<strong>字节流</strong>。</li>
</ul>
<p><strong>转换方式：</strong></p>
<ul>
<li>字节输入流转字符输入流通过<code>InputStreamReader</code> 实现，该类的构造函数可以传入 <code>InputStream</code> 对象。</li>
<li>字节输出流转字符输出流通过 <code>OutputStreamWriter</code> 实现，该类的构造函数可以传入 <code>OutputStream</code> 对象。</li>
</ul>
<h3 id="Java-IO的设计模式"><a href="#Java-IO的设计模式" class="headerlink" title="Java IO的设计模式"></a>Java IO的设计模式</h3><p><strong>装饰器模式</strong>：在不改变原有对象的情况下拓展其功能，比如使用 <code> BufferedInputStream</code> (字节缓冲输入流) 来增强 <code>FileInputStream </code>。</p>
<p><strong>适配器模式</strong>：用于接口互不兼容的类的协调工作，比如 <code>InputStreamReader</code> 和 <code>InputStream</code>。IO 流中的字符流和字节流的接口不同，它们之间的协调工作就是基于适配器模式的。通过适配器，可以将字节流对象适配成一个字符流对象。</p>
<h3 id="Java-IO分类"><a href="#Java-IO分类" class="headerlink" title="Java IO分类"></a>Java IO分类</h3><img src="/./res\33b193457c928ae02217480f994814b6.png" alt="img" style="zoom: 50%;">

<h4 id="BIO（Blocking-IO）"><a href="#BIO（Blocking-IO）" class="headerlink" title="BIO（Blocking IO）"></a>BIO（Blocking IO）</h4><p><strong>BIO 属于同步阻塞 IO 模型</strong>。<code>InputStream</code>&#x2F;<code>Reader</code> 和 <code>OutputStream</code>&#x2F;<code>Writer</code> 都属于 BIO。</p>
<p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。在客户端连接数量不高的情况下是没问题的。但是面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</p>
<h4 id="NIO（Non-Blocking-IO）"><a href="#NIO（Non-Blocking-IO）" class="headerlink" title="NIO（Non-Blocking IO）"></a>NIO（Non-Blocking IO）</h4><p>NIO 是面向缓冲的，基于通道的 I&#x2F;O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I&#x2F;O 多路复用模型</strong>。</p>
<h4 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h4><p>AIO 是 NIO 的改进版，是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，应用操作之后会直接返回，不会堵塞。当后台处理完成后，操作系统会通知相应的线程进行后续操作。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code> 接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p>
<p>对于 <code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<ul>
<li><code>List</code>: 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>: 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>: 存储键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值</li>
</ul>
<h3 id="底层数据结构总结"><a href="#底层数据结构总结" class="headerlink" title="底层数据结构总结"></a>底层数据结构总结</h3><p><code>Collection</code> 接口下面的集合</p>
<p><strong>List</strong></p>
<ul>
<li><code>ArrayList</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<p><strong>Set</strong></p>
<ul>
<li><code>HashSet</code>: 基于 <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，内部基于 <code>LinkedHashMap</code> 实现。</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<p><strong>Queue</strong></p>
<ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现<strong>二叉堆</strong></li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p><code>Map</code> 接口下面的集合。</p>
<p><strong>Map</strong></p>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组 + 链表组成的，数组是 <code>HashMap</code> 的主体，链表是为了解决哈希冲突问题。JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，会将链表转化为红黑树，以减少搜索时间</strong>。链表在转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，它的底层也是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表是为了解决哈希冲突问题。</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><code>ArrayList</code> 的底层是数组队列，相当于<strong>动态数组</strong>。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，可以使用 <code>ensureCapacity</code> 操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code> 继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个接口的 List 集合是支持<strong>快速随机访问</strong>的，即可以通过元素的序号快速获取元素对象。</li>
<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。(<strong>浅拷贝</strong>)</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输。</li>
</ul>
<h5 id="ArrayList-构造函数"><a href="#ArrayList-构造函数" class="headerlink" title="ArrayList 构造函数"></a>ArrayList 构造函数</h5><ul>
<li><strong>空参构造器：</strong>初始化一个空数组</li>
<li><strong>指定容量：</strong>如果容量大于 0，则初始化一个指定容量的对象数组，如果为 0 则初始化一个空数组，如果小于 0 则抛出异常</li>
<li><strong>指定 Collection</strong>：将指定 Collection 中的元素按照迭代器的顺序转为对象数组，并赋给原数组</li>
</ul>
<h5 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ruoli-0/p/13714389.html">浅谈 ArrayList 及其扩容机制 (cnblogs.com)</a></p>
<p><strong>第一种情况，当 ArrayList 的容量为 0 时，此时添加元素的话，需要扩容，三种构造方法创建的 ArrayList 在扩容时略有不同：</strong></p>
<p>​	1.<strong>无参构造</strong>，创建 ArrayList 后容量为 0，添加第一个元素后，容量变为 10，此后若需要扩容，则正常扩容。</p>
<p>​	2.<strong>传容量构造</strong>，当参数为 0 时，创建 ArrayList 后容量为 0，添加第一个元素后，容量为 1，此时 ArrayList 是满的，下次添加元素时需正常扩容。</p>
<p>​	3.<strong>传 Collection 构造</strong>，当 Collection 为空时，创建 ArrayList 后容量为 0，添加第一个元素后，容量为 1，此时 ArrayList 是满的，下次添加元素时需正常扩容。</p>
<p><strong>第二种情况，当 ArrayList 的容量大于 0，且 ArrayList 已满，此时添加元素的话，进行正常扩容，每次扩容到原来的 1.5 倍。</strong></p>
<h5 id="ArrayList-的序列化"><a href="#ArrayList-的序列化" class="headerlink" title="ArrayList 的序列化"></a>ArrayList 的序列化</h5><p>序列化一个对象时，被 <strong>transient</strong> 关键字修饰的变量(的值)不会被序列化。</p>
<p><strong>ArrayList 的序列化机制：</strong></p>
<ol>
<li><p>ArrayList 实现了 java.io.Serializable 接口。</p>
</li>
<li><p>ArrayList 中存放集合元素的 Object 数组被关键字 transient 修饰。代码：transient Object[] elementData;</p>
</li>
<li><p>ArrayList 序列化集合元素的机制：</p>
</li>
</ol>
<ul>
<li>ArrayList 在序列化时会调用 <code>writeObject(ObjectOutputStream s)</code> 方法，将 size 和 element 写入 <code>ObjectOutputStream</code> 中；</li>
<li>ArrayList 在反序列化时调用 <code>readObject(ObjectInputStream s)</code> 方法，从 <code>ObjectInputStream</code> 中获取到 size 和 element，再恢复到存储集合元素的 Object 数组中。</li>
</ul>
<p><strong>与直接序列化 Object 数组相比，这样的机制有什么优点呢？</strong></p>
<p>Object 数组通常会预留一些容量，有些空间 (elementData[size] ~ elementData[elementData.length-1]) 并没有存储元素(存的是 null)；</p>
<p>ArrayList 的序列化机制<strong>只序列化实际存储的集合元素，而不是实例化整个 Object 数组，可以节省空间和时间。</strong></p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<h5 id="LinkedList-和-ArrayList-的区别"><a href="#LinkedList-和-ArrayList-的区别" class="headerlink" title="LinkedList 和 ArrayList 的区别"></a>LinkedList 和 ArrayList 的区别</h5><ul>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong>（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以插入和删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(i))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持，而 <strong><code>ArrayList</code> 支持</strong>。快速随机访问就是通过元素的序号快速获取元素对象。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空间浪费主要体现在 Object 数组会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[]</code>存储</p>
<p>随着 Java 并发编程的发展，<code>Vector</code> 已经被淘汰，推荐使用并发集合类如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等或者手动实现线程安全。</p>
<h5 id="Vector-和-ArrayList-的区别"><a href="#Vector-和-ArrayList-的区别" class="headerlink" title="Vector 和 ArrayList 的区别"></a>Vector 和 ArrayList 的区别</h5><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，线程不安全 。</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p><strong>底层数据结构</strong>：哈希表（基于 <code>HashMap</code> 实现）</p>
<p><strong>元素：</strong>无序的，不重复的，无索引的</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p><strong>底层数据结构</strong>：链表和哈希表。元素的插入和取出顺序满足 FIFO。LinkedHashSet 继承于 HashSet，其所有的方法都与 HashSet 相同</p>
<p><strong>元素：</strong>无序的，不重复，无索引的</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p><strong>底层数据结构</strong>：二叉树（红黑树）, TreeSet 中的数据是自动排好序的，不允许放入 null 值。</p>
<p><strong>元素：</strong>有序的，不重复，无索引的</p>
<h4 id="无序性和不可重复性"><a href="#无序性和不可重复性" class="headerlink" title="无序性和不可重复性"></a>无序性和不可重复性</h4><ul>
<li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li>
<li>不可重复性是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法。</li>
</ul>
<h4 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于需要保证元素的插入和取出顺序的场景，<code>TreeSet</code> 用于需要对元素排序的场景。</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，<strong>因为容量问题导致操作失败后有两种处理方式</strong> : 一种会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<p><code>Deque</code> 的实现类有 <code>LinkedList</code> 和<code>ArrayDeque</code> </p>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而 <code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code>（阻塞队列）是一个接口，继承自 <code>Queue</code>。当队列没有元素时 <code>BlockingQueue</code> 会一直阻塞，直到有元素；如果队列已满，会等到队列可以放入元素时再放入。</p>
<p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p>
<p>Java 中常用的阻塞队列实现类有以下几种：</p>
<ol>
<li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，支持公平锁和非公平锁两种访问机制。</li>
<li><code>LinkedBlockingQueue</code>：使用单向链表实现的阻塞队列。在创建时可以指定容量大小，如果不指定则默认为 <code>Integer.MAX_VALUE</code>。也支持公平锁和非公平锁两种访问机制。</li>
<li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现 <code>Comparable</code> 接口或者在构造函数中传入 <code>Comparator</code> 对象，且不能插入 null 元素。</li>
<li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code> 通常用于线程之间的直接传递数据。</li>
<li><code>DelayQueue</code>：延迟队列，延迟队列中的元素只有到了指定的延迟时间后才能够从队列中出队。</li>
</ol>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，优先级高的元素先出队。</p>
<ul>
<li><code>PriorityQueue</code> 基于二叉堆实现，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了 O(logn) 时间复杂度内的插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，也可以接收一个 <code>Comparator</code> 作为构造参数，从而自定义元素优先级。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap 主要用来存放键值对，是<strong>非线程安全的</strong>。<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。</p>
<h5 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h5><ul>
<li><p>JDK1.8 之前 HashMap 由 <strong>数组 + 链表</strong> 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 </p>
</li>
<li><p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当<strong>链表长度大于阈值（默认为 8）时</strong>，如果当前数组的长度小于 64，会选择进行数组扩容，否则就会将链表转化为<strong>红黑树</strong>，以减少搜索时间。</p>
</li>
</ul>
<p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a><strong>基本属性</strong></h5><ul>
<li>初始容量 16，最大容量 2 的 30 次方</li>
<li>加载因子默认为 0.75。加载因子控制数组存放数据的疏密程度，loadFactor 越大，数组中存放的数据就越多越密；loadFactor 越小，数组中存放的数据就越少越稀疏。<strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</li>
<li>链表转红黑树链表长度阈值为 8，数组长度阈值为 64；红黑树转链表阈值为 6</li>
<li>扩容阈值：<strong>数组大小 * 加载因子</strong></li>
</ul>
<h5 id="put-原理"><a href="#put-原理" class="headerlink" title="put()原理"></a>put()原理</h5><ul>
<li><p>如果 table 未初始化或者长度为 0，先进行 resize() 扩容</p>
</li>
<li><p>先根据 key 的值计算 hash 值，再根据 hash 值计算当前元素要插入的数组下标</p>
<ul>
<li>如果定位到的数组位置<strong>没有元素</strong>就直接插入，<strong>插入完毕判断当前数组的实际大小是否大于阈值，决定是否需要扩容</strong></li>
<li>如果定位到的数组位置<strong>有元素</strong>，先判断数据的存储结构：<ul>
<li>如果为树结构，就调用树的 put 方法进行<strong>插入或覆盖</strong></li>
<li>如果是链表结构，就从头结点开始遍历链表，对当前元素进行<strong>插入或覆盖</strong>；插入完毕判断链表的长度是否大于等于 8，如果是就将调用 <code>treeifyBin </code> 方法将链表转化为红黑树</li>
</ul>
</li>
<li>如果定位到的数组下标处有元素，在插入或覆盖后不需要进行数组扩容判断</li>
</ul>
</li>
<li><p>在 1.7 之前插入元素采用的是头插法</p>
</li>
</ul>
<h5 id="resize-扩容机制"><a href="#resize-扩容机制" class="headerlink" title="resize() 扩容机制"></a>resize() 扩容机制</h5><p>HashMap 的容量超过负载因子规定的容量之后就会扩容，将大小扩大为原数组的两倍，并将原对象放入新数组中。</p>
<ul>
<li>如果使用<strong>空参构造器</strong>，实例化的 HashMap 内部数组为 null，当第一次调用 put 方法时进行初始化扩容，初始容量为16。</li>
<li>如果使用<strong>有参构造器</strong>指定了初始容量，会找到不小于指定容量的 2 的幂数，并将该数赋给阈值，当第一次调用 put 方法时再将阈值赋值给容量。</li>
<li>再后续的 put 操作中，如果<strong>数组实际大小大于阈值</strong>就需要进行扩容，创建一个容量为<strong>原容量 2 倍</strong>的新数组，并将原数组的数据重新分配到新数组上。</li>
<li>由于数组的容量发生改变，导致元素的 hash 值发生变化，从而达到将长链表转为短链表的目的。数据的重新分配过程类似于反转链表。</li>
</ul>
<p><strong>“拉链法”</strong> ：将链表和数组相结合。创建一个链表数组，数组中每一格就是一个链表。如果遇到哈希冲突，将冲突的值加到链表中即可。</p>
<p><img src="/.%5Cres%5Cjdk1.7_hashmap.png"></p>
<p><strong>JDK1.8 之后</strong></p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="/.%5Cres%5Cjdk1.8_hashmap.png"></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树是为了解决二叉查找树的缺陷，二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<h5 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h5><ul>
<li><strong>加快哈希计算：</strong>根据 key 得到的 hash 值是一个整数，为了找到 key 在当前哈希表中的位置，需要计算hash % n（n为数组长度）。但是 <strong>% 计算比 &amp; 运算慢很多</strong>，当 n 为 2 的幂次方时，hash &amp; (n - 1) &#x3D; hash % n，加快了哈希计算</li>
<li><strong>可以减少哈希冲突：</strong>n为偶数时，n - 1为奇数，hash &amp; (n - 1)运算后的结果可能是奇数也可能是偶数，保证了散列的均匀性；当 n 为奇数时，n - 1为偶数，hash &amp; (n - 1)运算后的结果只能是偶数，那么任何 hash 值都会被散列到数组的偶数下标位置，浪费了一半的空间，增加了哈希冲突的概率。</li>
</ul>
<h5 id="扩容后的数据迁移"><a href="#扩容后的数据迁移" class="headerlink" title="扩容后的数据迁移"></a>扩容后的数据迁移</h5><p><strong>1.7</strong></p>
<ul>
<li>遍历旧数组取得每个 entry 上的链表，并将旧数组的引用设为 null</li>
<li>重新计算链表上的元素在新数组中的位置并插入</li>
<li>采用<strong>头插法</strong>将元素插入到新数组中</li>
</ul>
<p><strong>1.8</strong></p>
<p>扩容后不需要重新计算元素的 hash 值，而是将<strong>原先的 hash 值与旧数组的长度（oldCap）进行”与”操作</strong>。</p>
<ul>
<li>如果结果为 0 那么当前元素的桶位置不变</li>
<li>如果结果为 1 那么桶位置就是原位置 + 原数组长度 oldCap</li>
<li>如果发生 hash 冲突采用<strong>尾插法</strong></li>
</ul>
<h5 id="hashcode-、hash-与下标计算"><a href="#hashcode-、hash-与下标计算" class="headerlink" title="hashcode()、hash()与下标计算"></a>hashcode()、hash()与下标计算</h5><ol>
<li><p>计算key的hashcode()</p>
</li>
<li><p>使用hashcode计算当前对象的hash值</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为什么需要让高 16 位参与异或运算：当数组的长度很短时，只有低位数的 hashcode 值能参与运算，让高 16 位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率。并且使得高16位和低16位的信息都被保留了。</p>
<ol start="3">
<li>通过<code>(n - 1) &amp; hash</code>计算下标：在数组长度为 <strong>2 的次幂</strong>的情况下，(n <strong>- 1</strong>) &amp; hash的值与 hash % n 的值相同，但是 &amp; 运算的数据比取余快得多，<strong>n 是数组长度</strong></li>
</ol>
<h5 id="解决-hash-冲突"><a href="#解决-hash-冲突" class="headerlink" title="解决 hash 冲突"></a>解决 hash 冲突</h5><ul>
<li><strong>拉链法：</strong>哈希值相同的元素构成一个单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除在链表中进行。</li>
<li><strong>开放地址法：</strong>也称为再散列法，在插入元素时如果发生了哈希冲突，就以当前地址为基址，再次进行哈希计算，直到找到一个不冲突的哈希地址。</li>
<li><strong>再哈希法：</strong>提供多个不同的 hash 函数，当第一个哈希函数发生冲突时，再计算第二个，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。</li>
<li><strong>建立公共溢出区：</strong>将哈希表分为公共区和溢出区，溢出发生时，将溢出数据统一放到溢出区。</li>
</ul>
<h5 id="为什么在解决-hash-冲突的时候，不直接用红黑树？"><a href="#为什么在解决-hash-冲突的时候，不直接用红黑树？" class="headerlink" title="为什么在解决 hash 冲突的时候，不直接用红黑树？"></a>为什么在解决 hash 冲突的时候，不直接用红黑树？</h5><p>先用链表，再转红黑树?<br>当元素小于 8 个时，链表结构能保证查询性能。当元素大于 8 个时， 红黑树查询的时间复杂度是 O(logn)，而链表是 O(n)，就需要用红黑树来加快查询速度，不过新增节点的效率会变低，因为红黑树需要左旋，右旋，变色这些操作来保持平衡。<strong>如果一开始就用红黑树，元素太少，新增效率又低</strong>，很<strong>浪费性能</strong>。</p>
<h5 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h5><p>并发下的 Rehash 会造成元素之间形成循环链表导致死循环。因此并发环境下推荐使用 ConcurrentHashMap </p>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ul>
<li><strong>线程安全：</strong>HashMap 线程不安全，<strong>HashTable 线程安全</strong>。如果要保证线程安全的话建议使用 CurrentHashMap，HashTable 基本被淘汰了。</li>
<li><strong>效率：</strong>HashMap 不加锁，效率比 HashTable 要高。</li>
<li><strong>对Null key 和Null value的支持：</strong>HashMap支持存储null的key和value，但是null作为键只能有一个，null作为值可以有多个；HashTable不允许有null键和null值，会抛出<code>NullPointerException</code></li>
<li><strong>底层数据结构：</strong>HashMap在1.8之后为数组+链表+红黑树，而HashTable为数组+链表</li>
<li><strong>初始容量和扩容机制：</strong>HashMap的初始容量为16，每次扩容为原来的2倍；HashTable的初始容量为11，每次扩容为原来的2n+1；</li>
<li>HashTable 继承自 Dictionary 类，HashMap继承自 AbstractMap类。</li>
</ul>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p>TreeMap 和 HashMap 都继承自 AbstractMap ，TreeMap 还实现了 NavigableMap 接口和 SortedMap 接口。</p>
<p>实现 NavigableMap 接口让 TreeMap 有了对集合内元素搜索的能力。</p>
<p><strong>实现 SortedMap 接口让 TreeMap 有了对集合中的元素根据键排序的能力</strong>。默认按 key 的升序排序，也可以指定排序的比较器。</p>
<p>综上，相比于 HashMap 来说， TreeMap 多了对集合中的<strong>元素根据键排序的能力</strong>以及<strong>对集合内元素搜索的能力</strong>。</p>
<h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><p>JDK 提供的并发容器大部分在 <code>java.util.concurrent</code> 包中。</p>
<ul>
<li><strong>ConcurrentHashMap</strong> : 线程安全的 <code>HashMap</code></li>
<li><strong>CopyOnWriteArrayList</strong> : 线程安全的 <code>List</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>。</li>
<li><strong>ConcurrentLinkedQueue</strong> : 可以看做一个线程安全的 <code>LinkedList</code>，底层使用链表实现，是非阻塞队列。<strong>使用 CAS 非阻塞算法实现线程安全</strong>。</li>
<li><strong>BlockingQueue</strong> : 阻塞队列，<strong>适合用于作为数据共享的通道</strong>。</li>
<li><strong>ConcurrentSkipListMap</strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p><strong>JDK1.7</strong>：</p>
<ul>
<li><code>ConcurrnetHashMap</code> 将数据分为一段一段存储，每一段就是一个 <code>Segment</code>，每一个 <code>Segment</code> 都有一把锁 ，<code>Segment</code> 继承了 <code>ReentrantLock</code>，是一种可重入锁；一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，<code>HashEntry </code> 是链表结构的元素，对 <code>HashEntry</code> 数组的元素进行修改时，必须先获得对应 <code>Segment</code> 的锁。</li>
<li><code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>，默认为16 ，可以认为 <code>ConcurrentHashMap</code> 默认最多支持 16 个线程并发。</li>
</ul>
<p><strong>JDK1.8：</strong> </p>
<p> JDK1.8 中的 <code>ConcurrnetHashMap</code> 的结构是 <strong>Node 数组 + 链表&#x2F;红黑树</strong>，当链表达到一定长度时就会转化为红黑树；</p>
<p>在锁的实现上，抛弃了原有的 Segment 分段锁，采用 CAS + synchronized 将锁的级别控制在了更低粒度的哈希桶元素级别，即<strong>只锁住链表头结点（红黑树的根节点）</strong>，不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>
<h5 id="基本属性-1"><a href="#基本属性-1" class="headerlink" title="基本属性"></a>基本属性</h5><ul>
<li><p><strong>Node&lt;K,V&gt;[] table</strong>：底层的node数组，默认初始容量16，默认负载因子0.75，最大的容量2的30次方</p>
</li>
<li><p><strong>Node&lt;K,V&gt;[] nextTable</strong>： 用于哈希表扩容，扩容完成后会被重置为 null，也是Node类型。</p>
</li>
<li><p><strong>sizeCtl</strong>：</p>
<ul>
<li>默认为0，用来控制table的初始化和扩容操作</li>
<li><strong>-1</strong>：代表table正在初始化</li>
<li><strong>-N</strong>：表示有N-1个线程正在进行扩容操作</li>
<li><strong>大于0且table未初始化</strong>：表示table的初始化容量大小</li>
<li><strong>大于0且以初始化</strong>：表示下次扩容的阈值</li>
</ul>
</li>
<li><p><strong>baseCount</strong>：用于存储整个哈希表中结点的个数总和</p>
</li>
<li><p><strong>核心常量：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;	<span class="comment">//ConcurrentHashMap的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;		<span class="comment">//默认容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;	<span class="comment">//数组最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;	<span class="comment">//默认的最大并发等级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;	<span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;	<span class="comment">//链表升级成红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;	<span class="comment">//红黑树退化成链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;	<span class="comment">//链表升级成红黑树需要满足的最小容量，若不满足，则会先扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;	<span class="comment">//最小转移步长</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul>
<li>如果是空参构造，参数采用默认值。</li>
<li>如果是有参构造，初始容量设为不小于指定容量的2的幂数，并赋给sizeCtl。</li>
<li>无论有参无参，ConcurrentHashMap 实例化时其内部的 Node 数组都没有初始化，只有在第一次put时才会初始化。</li>
</ul>
<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><ul>
<li><strong>1.7</strong><ul>
<li>首先会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，改为阻塞获取锁。</li>
<li>获取到锁后计算数据要放入的位置，获取这个位置上的 HashEntry。</li>
<li>此时会存在两种情况，HashEntry 存在或者不存在<ul>
<li>如果 HashEntry 不存在，判断当前容量是否大于阈值，大于就先进行扩容，然后使用头插法插入。</li>
<li>如果 HashEntry 存在，就遍历链表，如果链表中有相同的元素则覆盖，否则使用头插法插入。</li>
</ul>
</li>
</ul>
</li>
<li><strong>1.8</strong><ul>
<li>计算当前 key 的 hashcode，判断 table 是否已经初始化，如果没有就调用 initTable() 进行初始化。</li>
<li>如果当前 key 对应的 Node 为空，则利用 CAS 写入数据，失败则自旋保证成功，成功了就 break 跳出。</li>
<li>如果当前 key 对应的 Node 的 <code>hashcode == MOVED == -1</code> , 则需要进行扩容。</li>
<li>以上都不满足说明当前 key 对应的 Node 存在链表&#x2F;红黑树，则利用 synchronized 锁往链表&#x2F;红黑树再写入数据。</li>
<li>如果当前为链表，当链表长度大于 <code>TREEIFY_THRESHOLD </code>且数组长度≥64时，就调用 treeifyBin 方法将链表转换为红黑树。</li>
</ul>
</li>
</ul>
<h5 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h5><ol>
<li><p>当 key 为 String，value 为 ArrayList 的情况下，多线程并发向 ArrayList 中加入数据，可能出现数据丢失。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1进行add时发现ArrayList为null，则进行初始化</span></span><br><span class="line"><span class="comment">//线程1还未初始化完毕，切换到线程2执行，此时ArrayList还是null，线程2同样进行初始化</span></span><br><span class="line"><span class="comment">//最终初始化了两个ArrayList，并分别执行add操作，导致某一个线程的数据丢失</span></span><br><span class="line">map.put(key,getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()).add(word));</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong>采用原子方法如 <code>computeIfAbsent</code>，以原子的方式进行初始化操作。</p>
</li>
</ol>
<h5 id="ConcurrentHashMap-和-Hashtable"><a href="#ConcurrentHashMap-和-Hashtable" class="headerlink" title="ConcurrentHashMap 和 Hashtable"></a>ConcurrentHashMap 和 Hashtable</h5><ul>
<li><code>HashTable</code>：<code>Hashtable</code> 采用 <strong>数组 + 链表</strong> 的形式，使用 <code>synchronized</code> 对整个哈希表加锁，多线程访问时，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待锁被释放；</li>
</ul>
<p>ConcurrentHashMap 的效率要高于 <strong>Hashtable</strong>，因为 Hashtable 给整个哈希表加了一把大锁来实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用<strong>分段锁</strong>实现线程安全，在 JDK1.8 中采用 <strong>CAS + Synchronized</strong> 实现线程安全。</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><ul>
<li><strong>介绍：</strong>CopyOnWriteArrayList 在读的时候不加锁，在写的时候加锁，实现了读读、读写的兼容，只有写写是互斥的。</li>
<li><strong>读操作：</strong>读取时没有任何同步控制和锁操作，因为内部 <code>array</code> 数组不会发生修改，可以保证数据安全。</li>
<li><strong>写操作：</strong><ul>
<li><strong>原理</strong>：所有的写操作都是<strong>通过创建底层数组的副本来实现</strong>的，即修改 list 时<strong>不修改原数组</strong>，而是<strong>复制原数组，将修改的内容写入副本中 ，然后再用副本替换原数组</strong>，这样就可以保证写操作不会影响读操作。</li>
<li><strong>底层实现：</strong>底层通过 ReentrantLock 对写方法加锁，避免多线程写的时候 copy 出多个副本，造成写操作丢失。</li>
</ul>
</li>
</ul>
<h4 id="BlockingQueue-1"><a href="#BlockingQueue-1" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><ul>
<li><p><strong>介绍：</strong>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“生产者-消费者”模型中，因为 <code>BlockingQueue</code> 提供了可阻塞的插入和删除方法。当容器已满，生产者线程会被阻塞，直到队列未满时继续生产；当容器为空时，消费者线程会被阻塞，直至队列非空时继续消费。BlockingQueue 是一个接口，继承自 Queue，主要实现类如下：</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong></p>
<ol>
<li>ArrayBlockingQueue 是使用数组实现的有界阻塞队列。</li>
<li>ArrayBlockingQueue 一旦创建，容量不能改变。</li>
<li>并发控制采用可重入锁 ReentrantLock ，插入和读取操作都需要获取到锁。</li>
</ol>
</li>
<li><p><strong>LinkedBlockingQueue</strong></p>
<ol>
<li>LinkedBlockingQueue 是使用链表实现的阻塞队列，满足 FIFO 特性。</li>
<li>可以是无界队列也可以是有界队列，吞吐量比 ArrayBlockingQueue 更高。</li>
<li>可以在构造函数中传入 <code>capacity</code> 指定队列最大容量，<strong>如果未指定，容量等于 <code>Integer.MAX_VALUE</code></strong></li>
</ol>
</li>
<li><p><strong>PriorityBlockingQueue</strong></p>
<ol>
<li>PriorityBlockingQueue 是支持优先级排序的无界阻塞队列，是 PriorityQueue 的线程安全版本。<strong>不可以插入 null 值，且插入队列的对象必须实现 <code>Comparable</code> 接口或者在构造函数中传入 <code>Comparator</code> 对象</strong>。默认情况下采用自然排序，也可以自定义排序规则。</li>
<li><code>PriorityBlockingQueue</code> 只能指定初始的队列大小，后面插入元素时<strong>如果空间不够会自动扩容</strong>。</li>
<li>并发控制采用的是可重入锁 <code>ReentrantLock</code>。</li>
</ol>
</li>
<li><p><strong>DelayQueue</strong><br>DelayQueue 是支持延时获取元素的无界阻塞队列，基于 PriorityQueue 实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定延迟时间，延迟队列中的元素只有到了指定的延迟时间后才能从队列中出队。</p>
<p>适用场景：缓存系统的设计：用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦从 DelayQueue 中获取到元素，就表示缓存有效期到了。<br>定时任务调度：用 DelayQueue 保存当天要执行的任务和执行时间，使用一个线程循环查询 DelayQueue，一旦从 DelayQueue 中获取到任务就开始执行。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39723544/article/details/87188696">https://blog.csdn.net/weixin_39723544/article/details/87188696</a></p>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="并发编程三个特性"><a href="#并发编程三个特性" class="headerlink" title="并发编程三个特性"></a>并发编程三个特性</h4><p><strong>原子性</strong></p>
<p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。</p>
<p>可以借助 <code>synchronized</code>、各种 <code>Lock</code> 以及原子类实现原子性。</p>
<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任意时刻只有一个线程访问该代码块，因此可以保障原子性。原子类是利用 CAS 操作（可能也会用到 <code>volatile</code> 或者 <code>final</code> 关键字）来保证原子操作。</p>
<p><strong>可见性</strong></p>
<p>如果一个线程修改了共享变量，那么其它线程可以立即看到最新值。</p>
<p>可以借助 <code>synchronized</code>、各种 <code>Lock</code> 以及 <code>volatile</code> 实现可见性。</p>
<p>如果将变量声明为 <code>volatile</code> ，这就指示 JVM 这个变量是共享且不稳定的，每次使用前都要从主存中读取。</p>
<p><strong>有序性</strong></p>
<p>由于指令重排序，代码的执行顺序未必就是代码的编写顺序。</p>
<blockquote>
<p><strong>指令重排序可以保证串行语义一致，但是无法保证多线程间的语义一致</strong> ，因此在多线程下，指令重排序可能会导致一些问题。</p>
</blockquote>
<p><code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>
<h4 id="Java中的线程状态"><a href="#Java中的线程状态" class="headerlink" title="Java中的线程状态"></a>Java中的线程状态</h4><img src="/./res\线程.png" style="zoom: 67%;">

<ol>
<li>**初始(NEW)**：创建一个新的线程对象，还没有调用 start() 方法。</li>
<li><strong>运行(RUNNABLE)<strong>：Java 线程中将</strong>就绪（ready）</strong>和<strong>运行中（running）</strong>两种状态统称为“运行”。</li>
<li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li>
<li>**等待(WAITING)**：进入该状态的线程需要依靠其他线程的通知才能返回运行状态。</li>
<li>**超时等待(TIMED_WAITING)**：该状态不同于 WAITING，它可以在指定的时间后自行返回。</li>
<li>**终止(TERMINATED)**：表示该线程已执行完毕。</li>
</ol>
<blockquote>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> </p>
<p>现在的时分多任务操作系统架构通常是用“时间分片”的方式进行抢占式轮转调度。时间分片通常很小，一个线程一次最多只能在 CPU 上运行 10 - 20 ms 的时间（running 状态），然后就会被放入调度队列的末尾等待再次调度（ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
<ul>
<li>线程创建之后处于 <strong>NEW（新建）</strong> 状态。</li>
<li>调用 <code>start()</code> 方法后线程处于 <strong>READY（可运行）</strong> 状态。READY状态的线程获得 CPU 时间片后处于 <strong>RUNNING（运行）</strong> 状态。</li>
<li>线程调用 <code>wait()</code>方法后会进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能返回运行状态。</li>
<li>调用 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法后线程处于 <strong>TIMED_WAITING 状态</strong>。进入TIMED_WAITING 状态的线程经过指定的时间后会返回 RUNNABLE 状态。</li>
<li>当线程进入 <code>synchronized</code> 方法块或者调用 <code>wait</code> 方法后被 <code>notify</code>唤醒然后重新进入 <code>synchronized</code> 方法块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li>
<li>线程执行完 <code>run()</code>方法后会进入 <strong>TERMINATED（终止）</strong> 状态。</li>
</ul>
<h4 id="Java中的线程上下文切换"><a href="#Java中的线程上下文切换" class="headerlink" title="Java中的线程上下文切换"></a>Java中的线程上下文切换</h4><p>线程在执行过程中有自己的<strong>运行条件和状态</strong>（<strong>上下文</strong>），比如程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU导致其他线程或者进程饿死。</li>
<li>调用阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行。</li>
</ul>
<p>前三种都会发生线程切换，线程切换意味着需要<strong>保存当前线程的上下文，等线程下次占用 CPU 时恢复现场，同时加载下一个将要占用 CPU 的线程上下文</strong>。这就是 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因为上下文切换需要保存信息恢复信息，所以会占用 CPU、内存等系统资源，如果频繁切换会造成整体效率低下。</p>
<h4 id="Java中的死锁"><a href="#Java中的死锁" class="headerlink" title="Java中的死锁"></a>Java中的死锁</h4><h5 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<h5 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h5><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>
<ol>
<li>互斥条件：该资源任意时刻只能由一个线程占用。</li>
<li>请求与保持条件：线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不可剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件：线程间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h5 id="死锁预防和避免"><a href="#死锁预防和避免" class="headerlink" title="死锁预防和避免"></a><strong>死锁预防和避免</strong></h5><p>只要破坏产生死锁的四个条件中的其中一个就可以了</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不可剥夺条件</strong> ：线程进一步申请其他资源时，如果申请不到，可以主动释放占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：按某一顺序申请资源，释放资源则反序释放。</li>
<li><strong>锁排序法</strong>：指定锁的获取顺序，比如规定只有获得 A 锁的线程才有资格获取 B 锁，按顺序获取锁就可以避免死锁。这是解决死锁很好的一种方法。</li>
<li>使用显式锁中的 ReentrantLock.try(long TimeUnit) 来申请锁，相当于存入超时时间</li>
</ol>
<p>互斥条件没法破坏，因为使用锁本来就是想让资源互斥访问。</p>
<h4 id="线程创建的三种方式"><a href="#线程创建的三种方式" class="headerlink" title="线程创建的三种方式"></a>线程创建的三种方式</h4><h5 id="实现-Runnable-或-Callable-接口"><a href="#实现-Runnable-或-Callable-接口" class="headerlink" title="实现 Runnable 或 Callable 接口"></a>实现 Runnable 或 Callable 接口</h5><p>可以创建一个实现了 Runnable 或 Callable 接口的实现类或者匿名类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h5 id="继承-Thread-类并重写-Run-方法"><a href="#继承-Thread-类并重写-Run-方法" class="headerlink" title="继承 Thread 类并重写 Run 方法"></a>继承 Thread 类并重写 Run 方法</h5><p>可以创建一个 Thread 的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;threadName&quot;</span>)&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Thread Running&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<h5 id="通过线程池创建"><a href="#通过线程池创建" class="headerlink" title="通过线程池创建"></a>通过线程池创建</h5><pre><code>ExecutorService pool = Executors.newFixedThreadPool(1);
pool.execute(new Runnable() &#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;多线程执行，直接实现Runnable&quot;);
    &#125;
&#125;);
</code></pre>
<p>注意：实际开发中不会使用 Executors 创建线程池，而是使用 ThreadPoolExecutor 的构造方法</p>
<h5 id="创建方式的对比"><a href="#创建方式的对比" class="headerlink" title="创建方式的对比"></a>创建方式的对比</h5><ul>
<li><strong>采用实现 Runnable. Callable 接口的方式创建多线程</strong></li>
</ul>
<blockquote>
<p><strong>优势</strong>是：</p>
<p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p>
<p>在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU 代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<p><strong>劣势</strong>是：</p>
<p>编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</p>
</blockquote>
<ul>
<li><strong>使用继承 Thread 类的方式创建多线程</strong></li>
</ul>
<blockquote>
<p><strong>优势</strong>是：</p>
<p>编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</p>
<p><strong>劣势</strong>是：</p>
<p>线程类已经继承了Thread类，所以不能再继承其他父类。</p>
</blockquote>
<ul>
<li><strong>通过线程池创建</strong></li>
</ul>
<blockquote>
<p><strong>优势</strong>是：</p>
<p>可以通过线程池管理线程。</p>
<p><strong>劣势</strong>是：</p>
<p>只有在需要管理多个线程时才比较好用，平时这种太复杂。</p>
</blockquote>
<h4 id="线程死亡的三种方式"><a href="#线程死亡的三种方式" class="headerlink" title="线程死亡的三种方式"></a>线程死亡的三种方式</h4><ul>
<li>正常结束<br>run() 方法或 call() 方法执行完成后，线程正常结束；</li>
<li>异常结束<br>线程抛出一个未捕获的 Exception 或 Error ，导致线程异常结束；</li>
<li>调用 stop() 方法<br>直接调用线程的 stop() 方法来结束线程，一般不推荐这种方式，因为容易导致死锁；</li>
</ul>
<h3 id="JMM（Java内存模型）"><a href="#JMM（Java内存模型）" class="headerlink" title="JMM（Java内存模型）"></a>JMM（Java内存模型）</h3><p>JMM 就是 Java内存模型 (java memory model)，<strong>可以把 JMM 看作是 Java 定义的并发编程相关的一组规范</strong>，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。因为在不同的硬件生产商和不同的操作系统下，内存的访问有一定的差异，所以会造成相同的代码运行在不同的系统上会出现各种问题。所以 <strong>Java 内存模型 (JMM) 屏蔽了各种硬件和操作系统的内存访问差异，让 java 程序在各种平台都能达到一致的并发效果。</strong> </p>
<p> Java 内存模型规定<strong>所有线程创建的变量都存放在主内存中</strong>，不管是成员变量还是方法中的局部变量。每个线程都有自己的工作内存，<strong>工作内存中保存了该线程用到的变量和主内存的拷贝副本，线程对变量的操作都在工作内存中进行</strong>，<strong>不能直接读写主内存中的变量</strong>。<strong>不同线程间无法访问到对方工作内存中的变量。线程间变量值的传递均需要通过主内存来完成。</strong> </p>
<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240318222109920.png" alt="image-20240318222109920"></p>
<ul>
<li><strong>主内存</strong>：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的局部变量。</li>
<li><strong>本地内存</strong>：本地内存是 JMM 抽象出来的一个概念，每个线程都有一个私有的本地内存来存储主内存中的共享变量副本，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。</li>
</ul>
<blockquote>
<ul>
<li>主内存、工作内存和 JVM 内存布局中的堆、栈、方法区不是同一个层次的划分，基本没有什么关系。</li>
<li>如果要对应起来：可以说 <strong>JVM 堆中的部分区域 &lt;&#x3D;&#x3D;&gt; 主内存</strong>  <strong>JVM 栈中的部分区域 &lt;&#x3D;&#x3D;&gt; 工作内存</strong></li>
</ul>
</blockquote>
<h4 id="八种同步操作"><a href="#八种同步操作" class="headerlink" title="八种同步操作"></a>八种同步操作</h4><ul>
<li><p><strong>lock（锁定）</strong>: 作用于主内存中的变量，将其标记为线程独享的状态。</p>
</li>
<li><p><strong>unlock（解锁）</strong>: 作用于主内存中的变量，解除变量的锁定状态。</p>
</li>
<li><p><strong>read（读取）</strong>：作用于主内存中的变量，从主内存中读取一个变量的值到线程的工作内存中。</p>
</li>
<li><p>**load(载入)**：把 read 操作从主内存中得到的变量值放入工作内存中的变量副本中。</p>
</li>
<li><p>**use(使用)**：把工作内存中的一个变量值传给执行引擎，虚拟机每遇到一个使用到的变量都会执行该指令。</p>
</li>
<li><p><strong>assign（赋值）</strong>：作用于工作内存中的变量，把执行引擎传来的值赋给工作内存中的变量，虚拟机每遇到一个给变量赋值的字节码指令都会执行这个操作。</p>
</li>
<li><p><strong>store（存储）</strong>：作用于工作内存中的变量，把工作内存中一个变量的值传送到主内存中。</p>
</li>
<li><p><strong>write（写入）</strong>：作用于主内存中的变量，把 store 操作从工作内存中得到的变量值放入主内存的变量中。</p>
<p><img src="/C:/Users\SuSu\AppData\Roaming\Typora\typora-user-images\image-20240318223501182.png" alt="image-20240318223501182"></p>
</li>
</ul>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p><strong>思想</strong></p>
<ul>
<li>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果，编译器和处理器怎么进行重排序优化都行。</li>
<li>JMM 会禁止编译器和处理器进行会改变程序执行结果的重排序。</li>
</ul>
<p><strong>定义</strong></p>
<ul>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作间存在 happens-before 关系，并不意味着必须按照 happens-before 指定的顺序执行。如果重排序之后的执行结果与按照 happens-before 关系执行的结果一致，那么 JMM 也允许这样的重排序。</li>
</ul>
<p><strong>规则</strong></p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程内，书写在前面的操作 happens-before 于书写在后面的操作；</li>
<li><strong>解锁规则</strong>：解锁 happens-before 加锁；</li>
<li><strong>volatile 变量规则</strong>：对一个 volatile 变量的写操作 happens-before 于对这个 volatile 变量的读操作。即对 volatile 变量的写操作结果对于发生于其后的任何操作都是可见的。</li>
<li><strong>传递规则</strong>：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li>
<li><strong>线程启动规则</strong>：Thread 对象的 <code>start()</code>方法 happens-before 于线程的每一个动作。</li>
</ul>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><h4 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h4><p>该方法是本地静态方法， 用于返回当前线程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h4 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h4><p>用于执行线程的运行时代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当target不为空时，执行target的run方法。若target为空，则需要重写run方法，方法内是业务逻辑</p>
<h4 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h4><p>用于启动线程并使线程处于就绪状态；当线程获得CPU时间片后 Java 虚拟机就会调用该线程的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>interrupt():改变中断状态，将中断状态标记为true，此时不会真的中断线程，会等待当前线程执行完毕。</li>
<li>isInterrupted():检测本线程是否已经中断 。如果已经中断则返回true，否则返回false。 如果调用时线程不处于活动状态，则返回false。</li>
<li>interrupted():检测本线程是否已经中断 。如果当前线程已经中断则返回true，并修改中断状态为false，再调用 isInterrupted() 会返回false。如果当前线程没有中断则返回false，不会修改中断状态。</li>
</ul>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>让线程休眠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>
<p>两个参数的sleep只是将nanos转为millis(四舍五入转换)，然后调用sleep(millis)方法。<br>sleep(millis)是本地静态方法，让当前线程休眠指定时间。<br><strong>sleep不释放锁</strong>。</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>调用join()方法的线程会被阻塞，等待join()方法完成以后，才能继续运行</p>
<p>A调用B.join()  -&gt; A暂停等待B执行完再继续</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">        millis++;</span><br><span class="line">    &#125;</span><br><span class="line">    join(millis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当传入参数为0时，代表一直等待到结束，<strong>由于join()调用了wait()方法，因此会释放掉B的锁，但不会释放掉B持有对象的锁</strong></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><code>synchronized</code> 主要解决多个线程之间访问资源的同步性，保证被它修饰的方法或者代码块在任意时刻只能有一个线程访问。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ul>
<p><strong>修饰实例方法</strong> （锁当前实例对象）</p>
<p>给当前实例对象加锁，进入同步代码前要获得 <strong>当前实例对象的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有实例对象 ，进入同步代码前要获得 <strong>当前类 的锁</strong>。</p>
<p>静态成员不属于一个实例对象，归整个类所有，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，线程 B 调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而非静态 <code>synchronized</code> 方法占用的锁是当前实例对象的锁。</p>
<p><strong>修饰代码块</strong> （锁指定对象&#x2F;类）</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码块前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字修饰静态方法和 <code>synchronized(class)</code> 代码块都是给 Class 类上锁；</li>
<li><code>synchronized</code> 关键字修饰实例方法是给实例对象上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code>。 因为 JVM 中字符串常量池具有缓存功能。</li>
<li>构造方法不能用 <code>synchronized</code> 关键字修饰，构造方法本身就是线程安全的，不存在同步的构造方法。</li>
</ul>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h5><p><strong>每个对象内部都有一个 monitor 对象与之关联，monitor 对象称为管程或监视器锁，线程获取锁的过程就是在获取 monitor 的所有权，解锁的过程就是释放 monitor 的所有权。</strong>monitor 里面有一个计数器，从0开始。</p>
<p>在 HotSpot 虚拟机中，Monitor 是基于 C++ 的 ObjectMonitor 实现的。</p>
<blockquote>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只能在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<h5 id="修饰同步代码块的情况"><a href="#修饰同步代码块的情况" class="headerlink" title="修饰同步代码块的情况"></a>修饰同步代码块的情况</h5><p><strong><code>synchronized</code> 同步代码块的实现使用了 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，<code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令指向同步代码块的结束位置。</strong></p>
<ul>
<li>在线程执行**<code>monitorenter</code><strong>时，会尝试去获得对象的锁，也就是获取 <strong>对象的监视器锁 <code>monitor</code></strong> 的持有权，</strong>如果 monitor 计数器为 0，表明锁可以被获取，获取后将 monitor 计数器加1**；只有锁的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。</li>
<li>执行 <strong><code>monitorexit</code></strong> 指令后，<strong>将 monitor 计数器设为 0，表明锁被释放，其他线程可以尝试获取锁</strong>。如果获取对象的锁失败，那当前<strong>线程就要阻塞等待</strong>，直到锁被另一个线程释放为止。</li>
</ul>
<h5 id="修饰方法的的情况"><a href="#修饰方法的的情况" class="headerlink" title="修饰方法的的情况"></a>修饰方法的的情况</h5><p><code>synchronized</code> 修饰的方法没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的是 <strong><code>ACC_SYNCHRONIZED</code></strong> 标识，<strong>该标识指明了该方法是同步方法</strong>。JVM 通过 <code>ACC_SYNCHRONIZED</code> 标识来判断方法是否是同步方法，然后执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<h4 id="锁升级机制"><a href="#锁升级机制" class="headerlink" title="锁升级机制"></a>锁升级机制</h4><p><strong>MarkWord 结构</strong></p>
<img src="/./res\1162587-20200918154125385-1537793659.png" alt="img" style="zoom: 33%;">

<p><strong>锁可以升级，但不能降级</strong>。即：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的。</p>
<p>通过 synchronized 实现的同步锁是<strong>重量级锁</strong>，重量级锁会造成线程排队（串行执行），且会使 CPU 在用户态和核心态之间频繁切换，所以代价高、效率低。为了提高效率，JVM 不会一开始就使用重量级锁，而是根据需要进行锁的升级：</p>
<ol>
<li>锁对象刚创建时，<strong>没有任何线程来竞争</strong>，锁对象的 Mark Word 的偏向锁标志位是 0，锁状态标志位是 01，该对象处于<strong>无锁状态</strong>（无线程竞争）。</li>
<li>当<strong>有一个线程来竞争锁时，先用偏向锁</strong>，表示锁对象偏爱这个线程，这个线程要执行锁关联的任何代码，不需要再做任何检查和切换，在这种竞争不激烈的情况下，效率非常高。Mark Word 会记录自己偏爱的线程的 ID。</li>
<li>当有<strong>两个线程开始竞争这个锁对象</strong>，锁会升级为<strong>轻量级锁</strong>，两个线程公平竞争，哪个线程先占有锁对象并执行代码，锁对象的 Mark Word 就会指向那个线程栈帧中的锁记录。<strong>当前线程持有锁时，其他线程进入就会 cas 自旋，直到获取锁</strong>，轻量级锁适合多线程交替执行，效率高。</li>
<li>如果<strong>竞争这个锁对象的线程更多，导致了更多的切换和等待</strong>，JVM 就会把锁升级为重量级锁，即同步锁，锁对象的 Mark Word 会<strong>指向关联的监视器对象</strong>，监视器对象会用集合的形式来登记和管理排队的线程。</li>
</ol>
<img src="/./res\20210222222345508-1660460670054.jpg" alt="img" style="zoom:67%;">

<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>大部分情况下都是同一个线程进入同一个同步代码块的，这也是偏向锁出现的原因。</p>
<blockquote>
<ul>
<li><strong>偏向锁的加锁</strong>：<ul>
<li>如果偏向锁是未偏向状态，使用 CAS 将 MarkWord 中的线程ID设置为当前线程 ID。如果成功，则获取偏向锁成功；如果失败，则进行锁升级。</li>
<li>如果偏向锁是已偏向状态，且MarkWord 中的线程 ID 是当前线程 ID，则获取偏向锁成功；如果MarkWord 中的线程 ID 不是当前线程 ID，则进行锁升级。</li>
</ul>
</li>
<li><strong>偏向锁的撤销：</strong>偏向锁升级时需要先进行偏向锁的撤销。<ul>
<li>如果对象是不可偏向状态，则不需要撤销。</li>
<li>如果对象是可偏向状态：<ul>
<li>如果MarkWord指向的线程死亡且该对象允许重偏向，则退回到可偏向但未偏向的状态；如果对象不允许重偏向，则变为无锁状态。</li>
<li>MarkWord 中的线程存活：<ul>
<li><strong>如果 MarkWord 指向的线程仍然拥有锁，则升级为轻量级锁，将 MarkWord 复制到线程栈中</strong>。</li>
<li>如果 MarkWord 指向的线程不再拥有锁且允许重偏向，则退回到可偏向但未偏向的状态；如果不允许重偏向则变为无锁状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p><strong>有两种情况会膨胀成重量级锁</strong>。</p>
<ul>
<li>当一个线程的 <strong>CAS 自旋</strong>次数<strong>超过阈值（默认是10）仍未能获取锁</strong>，为了防止 cpu 空转，会将自旋锁升级为重量级锁。</li>
<li><strong>其他线程正在 CAS 获取锁，第三个线程竞争获取锁，锁也会膨胀成重量级锁。</strong></li>
</ul>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>​		在 <strong>JDK1.6 之前 synchronized 属于重量级锁</strong>，效率低下。synchronized通过监视器锁monitor来实现，而监视器锁monitor依赖于底层操作系统的 <code>Mutex Lock</code> 来实现。Java 的线程会映射到操作系统的原生线程上，如果要挂起或者唤醒线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换需要从用户态转换到内核态，这个状态之间的转换需要相对较长的时间，时间成本相对较高，也是synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁被称作“重量级锁”。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>如果将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM 这个变量是共享且不稳定的，每次使用都会从主存中读取。</p>
<ul>
<li><p>保证可见性</p>
</li>
<li><p>不保证原子性（例如 i++ 这样的指令实际上不是独立的指令）</p>
<blockquote>
<p>原因是i++在转化为字节码指令的时候是4条指令。</p>
<ul>
<li>getfield 获取原始值</li>
<li>iconst_1 将值入栈</li>
<li>iadd 进行加 1 操作</li>
<li>putfield 把 iadd 后的操作写回主内存</li>
</ul>
</blockquote>
</li>
<li><p>禁止指令重排（保证有序性）</p>
</li>
</ul>
<h4 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h4><p>volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层是基于内存屏障实现的。</p>
<ul>
<li>对非 volatile 变量进行读写时，每个线程都会从内存中拷贝变量到 CPU 缓存中。如果计算机有多个CPU，那么线程可能在不同的 CPU 上被处理，这意味着变量可能会被拷贝到不同的 CPU cache 中。</li>
<li>对 volatile 变量进行读写时，JVM 保证每次使用都从主存中读取，不会有可见性问题。<ul>
<li>对 volatile 变量进行写操作时，会在写操作后加一条 store 屏障指令，将工作内存中的共享变量刷新回主内存；</li>
<li>对 volatile 变量进行读操作时，会在读操作后加一条 load 屏障指令，从主内存中读取共享变量；</li>
</ul>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只能在有限的情况下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p>
<ul>
<li>对变量的写操作不依赖于当前值。</li>
<li>变量没有被包含在具有其他变量的不变式中。</li>
</ul>
<p>其实就是在需要保证原子性的场景，不要使用 volatile。</p>
<h4 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h4><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是互补的存在，不是对立的存在。</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code> 性能比 <code>synchronized</code> 关键字要好 。但是 <code>volatile</code> 关键字只能修饰变量而 <code>synchronized</code> 关键字可以修饰方法和代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code> 关键字主要用于解决变量在多个线程间的可见性，而 <code>synchronized</code> 关键字主要用于解决多个线程间访问资源的同步性。</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p><strong>ThreadLocal类就像存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果创建了一个<code>ThreadLocal</code>变量，那么访问<code>ThreadLocal</code>变量的线程都会有它的本地副本。可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取和修改本地副本的，避免了线程安全问题。</p>
<h4 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h4><p>在 <code>Thread</code>类源代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Thread</code> 类中有一个 <code>threadLocals</code> 变量和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量，可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。</p>
<p>默认情况下这两个变量都是 null，只有线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，这两个方法实际上调用的是<code>ThreadLocalMap</code>类的 <code>get()</code>、<code>set()</code>方法。</p>
<p>在<code>ThreadLocal</code>类源代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这些内容，可以得出结论：<strong>最终变量放在当前线程的 <code>ThreadLocalMap</code> 中，而不是<code>ThreadLocal</code>中， 可以认为<code>ThreadLocal</code>是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类通过<code>Thread.currentThread()</code>得到当前线程对象后，再通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个 <code>Thread</code> 中都有一个 <code>ThreadLocalMap</code>，<code>ThreadLocalMap</code> 可以存储以 <code>ThreadLocal</code> 为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在一个线程中声明了两个 <code>ThreadLocal</code> 对象，数据都是存放在在<code>Thread</code>内部的<code>ThreadLocalMap</code> 中，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set()</code>方法设置的值。</p>
<h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p><code>ThreadLocalMap</code> 的 key 是 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。如果 <code>ThreadLocal</code> 没有被外部强引用，在垃圾回收时，key 就会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。如果不采取措施的话，value 永远无法被 GC 回收，就会产生内存泄露。</p>
<p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法时会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后最好手动调用 <code>remove()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>一个只具有弱引用的对象就像<strong>可有可无的生活用品</strong>，生命周期更短暂。垃圾回收器线程扫描它所管辖的内存区域时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器线程的优先级很低， 因此不一定会很快发现那些只具有弱引用的对象。</p>
</blockquote>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会被销毁，而是等待下一个任务。</p>
<p>池化技术可以减少每次获取资源的消耗，提高资源利用率。</p>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，不需要创建线程就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="处理任务流程"><a href="#处理任务流程" class="headerlink" title="处理任务流程"></a>处理任务流程</h4><p><img src="/.%5Cres%5C%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，就把该任务放入到任务队列里等待执行。</li>
<li>如果任务队列已满，且当前运行的线程数小于最大线程数，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于最大线程数，新建线程将会使当前运行的线程超出最大线程数，就会拒绝当前任务，饱和策略会调用 <code>RejectedExecutionHandler.rejectedExecution()</code> 方法。</li>
</ol>
<h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><p><strong>通过 <code>ThreadPoolExecutor</code> 构造函数创建（主要推荐方式）</strong></p>
<p><img src="/.%5Cres%5Cthreadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-d54a5992.png" alt="通过构造方法实现"></p>
<p><strong>通过 <code>Executor</code> 框架的 Executors 来创建</strong></p>
<p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p>
<ul>
<li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li>**<code>ScheduledThreadPool</code>**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<p><code>Executors</code> 返回线程池对象的弊端如下：</p>
<ul>
<li>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>, 可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code>:</strong> 最大可以同时运行的核心线程数量。</li>
<li><strong><code>maximumPoolSize</code>:</strong> 最大可以同时运行的线程数量。</li>
<li><strong><code>workQueue</code>:</strong> 新任务到来时会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li>**<code>keepAliveTime</code>**：线程池中的线程数量大于 <code>corePoolSize</code> 时，如果没有新任务提交，核心线程外的线程会等待 <code>keepAliveTime</code> 后被回收销毁；</li>
<li><strong><code>unit</code></strong>: <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>allowCoreThreadTimeOut</code></strong>: 设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁</li>
<li><strong><code>threadFactory</code></strong>: executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong>: 饱和策略。</li>
</ul>
<img src="/./res\线程池各个参数之间的关系-d65f3309.png" alt="线程池各个参数的关系" style="zoom: 33%;">

<h4 id="动态参数配置"><a href="#动态参数配置" class="headerlink" title="动态参数配置"></a>动态参数配置</h4><img src="/./res\threadpoolexecutor-methods.png" alt="img" style="zoom:50%;">

<p>程序运行期间，如果调用 <code>setCorePoolSize()</code> 方法，线程池会先判断当前工作线程数是否大于 <code>corePoolSize</code>，如果大于的话就会回收工作线程。</p>
<h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>如果当前运行的线程数等于最大线程数且队列也满了，此时有新任务到来就会触发饱和策略。<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong>会在调用 <code>execute</code> 方法的线程中运行被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。这个策略会降低新任务的提交速度，影响程序的整体性能。如果应用程序可以接收此延迟且要求所有任务都要执行的话，可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 直接丢弃新任务。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 丢弃最早的未处理的任务。</li>
</ul>
<h4 id="常用的阻塞队列"><a href="#常用的阻塞队列" class="headerlink" title="常用的阻塞队列"></a>常用的阻塞队列</h4><p>新任务到来时会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExector</code>： 使用 <code>LinkedBlockingQueue</code>（无界队列），容量为 <code>Integer.MAX_VALUE</code>。由于队列永远不会被放满，所以 <code>FixedThreadPool</code> 最多只能创建核心线程数的线程。</li>
<li><code>CachedThreadPool</code> ：使用 <code>SynchronousQueue</code>（同步队列）。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证提交的新任务，如果有空闲线程，则使用空闲线程来处理；否则就新建一个线程来处理。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程导致 OOM。</li>
<li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code>：使用 <code>DelayedWorkQueue</code>（延迟阻塞队列） 。<code>DelayedWorkQueue</code> 内部的任务不是按照放入的时间来排序，而是按照延迟的时间长短进行排序，内部采用“堆”的数据结构，保证每次出队的任务都是当前队列中延迟时间最短的。<code>DelayedWorkQueue</code> 满了之后会自动扩容原容量的 1&#x2F;2，最大可达 <code>Integer.MAX_VALUE</code>，即永远不会阻塞，所以最多只能创建核心线程数的线程。</li>
</ul>
<h4 id="线程池命名"><a href="#线程池命名" class="headerlink" title="线程池命名"></a>线程池命名</h4><p><strong>使用 guava 的 <code>ThreadFactoryBuilder</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure>

<p><strong>自己实现 ThreadFactor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个带名字的线程池生产工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池大小设定策略"><a href="#线程池大小设定策略" class="headerlink" title="线程池大小设定策略"></a>线程池大小设定策略</h4><p>线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>
<ul>
<li>如果线程池太小，同一时间有大量任务需要处理，会导致大量的任务在任务队列中排队等待，CPU 没有得到充分利用。大量任务堆积在任务队列也可能会导致 OOM。</li>
<li>如果线程池太大，大量线程可能同时竞争 CPU 资源，导致大量的上下文切换，从而增加线程执行时间，影响整体效率。</li>
</ul>
<p>一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> CPU 密集型任务主要消耗 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多一个线程是为了防止线程偶发的缺页中断或其它原因导致任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，这时多出来的一个线程就可以充分利用 CPU。</li>
<li><strong>I&#x2F;O 密集型任务(2N)：</strong> 执行I&#x2F;O 密集型任务时，线程大部分时间在处理 I&#x2F;O 交互，在处理 I&#x2F;O 的时间段内不会占用 CPU ，这时就可以将 CPU 交给其它线程使用。因此可以多配置一些线程。</li>
</ul>
<p>如何判断类型：</p>
<p>CPU 密集型任务：利用 CPU 计算能力的任务，比如在内存中对大量数据进行排序。</p>
<p>IO 密集型任务：涉及到网络读取，文件读取的任务，这类任务的特点是 CPU 计算耗费的时间远小于等待 IO 操作完成的时间，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="Lock-API"><a href="#Lock-API" class="headerlink" title="Lock API"></a>Lock API</h3><p>Lock接口抽象方法 </p>
<ul>
<li>void lock()：获取锁，如果锁不可用，当前线程将阻塞等待直至获取锁。</li>
<li>boolean tryLock()：如果锁可用返回true，如果锁不可用返回false；</li>
<li>boolean tryLock(long time, TimeUnit unit) throws InterruptedException：如果锁可用，则此方法立即返回true。 如果该锁不可用，则当前线程将出于线程调度目的而被禁用并处于休眠状态，直到发生以下三种情况之一为止：①当前线程获取到该锁；②当前线程被其他线程中断，并且支持中断获取锁；③经过指定的等待时间如果获得了锁，则返回true，没获取到锁返回false。</li>
<li>void unlock()：释放锁。释放锁的操作放在finally块中进行，以确保锁被释放，防止死锁。</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是可重入的独占锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code> 有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code> 的底层是由 AQS 来实现的。</p>
<h5 id="与-synchronized-的区别"><a href="#与-synchronized-的区别" class="headerlink" title="与 synchronized 的区别"></a><strong>与 synchronized 的区别</strong></h5><p><strong>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p>
<p><code>synchronized</code> 是依赖于 JVM 实现的，虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比 <code>synchronized</code>，<code>ReentrantLock</code> 增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : 通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待锁的线程可以放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code> 可以指定是公平锁还是非公平锁。而 <code>synchronized</code> 只能是非公平锁。公平锁就是先等待的线程先获得锁。可以通过构造器来显式的指定使用公平锁。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code> 关键字与 <code>wait()</code> 和 <code>notify()</code> &#x2F; <code>notifyAll()</code> 方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code> 类也可以实现，但是需要借助 <code>Condition</code> 接口与 <code>newCondition()</code> 方法。</li>
</ul>
<h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p><code>ReentrantReadWriteLock</code> 是可重入的读写锁，实现了 <code>ReadWriteLock</code> 接口 ，既可以保证多个线程同时读的效率，也可以保证写入时的线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li>
<li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥。</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，可以同时被多个线程持有。写锁是独占锁，只能被一个线程持有。</p>
<p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p>
<p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够显著提升系统性能。</p>
<ul>
<li>在线程持有读锁的情况下不能获得写锁。因为在获取写锁时，如果发现读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有。</li>
<li>在线程持有写锁的情况下可以获得读锁。获取读锁时如果发现写锁被占用，只有写锁被其它线程占用的情况才会获取失败。</li>
</ul>
<p><strong>读锁为什么不能升级为写锁？</strong></p>
<p>写锁可以降级成读锁，但是读锁不能升级成写锁。因为写锁是独占锁，读锁升级为写锁会引起线程的争夺，会影响性能。</p>
<p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则都需要对方释放自己的读锁，而双方都不释放，就会产生死锁。</p>
<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p>
<p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 没有实现 <code>Lock</code> 或 <code>ReadWriteLock</code> 接口，而是基于 <strong>CLH锁</strong> 实现的（AQS 也是基于这玩意）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLock</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StampedLock</code> 提供了三种读写控制模式：读锁、写锁和乐观读。</p>
<ul>
<li><strong>写锁</strong>：独占锁，只能被一个线程获取。当一个线程获取写锁后，其他请求读锁和写锁的线程都会阻塞等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过 <code>StampedLock</code> 的写锁是不可重入的。</li>
<li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，其他线程请求读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过 <code>StampedLock</code> 的读锁是不可重入的。</li>
<li><strong>乐观读</strong>：允许多个线程获取乐观读以及读锁，同时允许一个写线程获取写锁。</li>
</ul>
<p>另外，<code>StampedLock</code> 还支持三种锁在一定条件下相互转换 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToWriteLock</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToReadLock</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">tryConvertToOptimisticRead</span><span class="params">(<span class="type">long</span> stamp)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>StampedLock</code> 在获取锁时会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放，如果返回的数据戳为 0 ，表示获取锁失败。当前线程持有锁后再次获取锁会返回一个新的数据戳，这也是 <code>StampedLock</code> 不可重入的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">writeLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">            next : acquireWrite(<span class="literal">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="built_in">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="literal">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StampedLock 的性能为什么更好？</strong></p>
<p>相比于传统读写锁，多出来的乐观读是 <code>StampedLock</code> 比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，不会导致所有写线程阻塞。当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p>
<p><strong>StampedLock 适合什么场景？</strong></p>
<p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p>
<p>不过 <code>StampedLock</code> 不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好，如果需要用到 <code>ReentrantLock</code> 的高级功能，就不建议使用 <code>StampedLock</code> 了。</p>
<h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>原子类就是具有原子&#x2F;原子操作特征的类，一个操作是不可中断的。即使有多个线程一起执行，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下</p>
<p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，不能解决 ABA 问题。。</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可以原子的更新数据和数据的版本号，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>:原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段</li>
</ul>
<h4 id="基本类型原子类"><a href="#基本类型原子类" class="headerlink" title="基本类型原子类"></a>基本类型原子类</h4><p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicInteger</code> 为例子来介绍。</p>
<h5 id="基本类型原子类的使用"><a href="#基本类型原子类的使用" class="headerlink" title="基本类型原子类的使用"></a>基本类型原子类的使用</h5><p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p><strong><code>AtomicInteger</code> 类使用示例</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">        temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i); <span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">        temvalue = i.getAndIncrement();</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i); <span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">        temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i); <span class="comment">//temvalue:4;  i:9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基本类型原子类的优势"><a href="#基本类型原子类的优势" class="headerlink" title="基本类型原子类的优势"></a>基本类型原子类的优势</h5><p>可以对比一下多线程下使用和不使用原子类实现线程安全</p>
<p><strong>多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多线程环境使用原子类保证线程安全（基本数据类型）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AtomicInteger线程安全原理"><a href="#AtomicInteger线程安全原理" class="headerlink" title="AtomicInteger线程安全原理"></a>AtomicInteger线程安全原理</h5><p><code>AtomicInteger</code> 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p><code>AtomicInteger</code> 类使用 CAS + volatile 和 native 方法来保证原子操作，避免了 synchronized 的高开销，大大提高执行效率。</p>
<p>CAS原理：CAS算法有三个操作数，内存地址值、预期原始值、修改后的新值。如果内存地址对应的值和预期原始值相等， 就将修改后的新值保存到内存中。如果内存地址对应的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p>
<p>UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，可以拿到内存中的值的内存地址。value 是一个 volatile 变量，JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h4 id="数组类型原子类"><a href="#数组类型原子类" class="headerlink" title="数组类型原子类"></a>数组类型原子类</h4><p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerArray</code> 为例子来介绍。</p>
<h5 id="数组类型原子类的使用"><a href="#数组类型原子类的使用" class="headerlink" title="数组类型原子类的使用"></a>数组类型原子类的使用</h5><p><strong><code>AtomicIntegerArray</code> 类常用方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p><strong><code>AtomicIntegerArray</code> 类使用示例</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            System.out.println(i.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">        temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">        temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引用类型原子类"><a href="#引用类型原子类" class="headerlink" title="引用类型原子类"></a>引用类型原子类</h4><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可以原子的更新数据和数据的版本号，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li>
</ul>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicReference</code> 为例子来介绍。</p>
<h5 id="引用类型原子类的使用"><a href="#引用类型原子类的使用" class="headerlink" title="引用类型原子类的使用"></a>引用类型原子类的使用</h5><p><strong><code>AtomicReference</code> 类使用示例</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        AtomicReference &lt; Person &gt; ar = <span class="keyword">new</span> <span class="title class_">AtomicReference</span> &lt; Person &gt; ();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        ar.set(person);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">updatePerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        ar.compareAndSet(person, updatePerson);</span><br><span class="line">        System.out.println(ar.get().getName());</span><br><span class="line">        System.out.println(ar.get().getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码首先创建了一个 <code>Person</code> 对象，然后把 <code>Person</code> 对象设置进 <code>AtomicReference</code> 对象中，然后调用 <code>compareAndSet</code> 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 <code>person</code> 的话，则将其设置为 <code>updatePerson</code>。实现原理与 <code>AtomicInteger</code> 类中的 <code>compareAndSet</code> 方法相同。运行上面的代码后的输出结果如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Daisy</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<p><strong><code>AtomicStampedReference</code> 类使用</strong> : 加入了stamp作为版本号控制，其余的部分相同，可以解决ABA</p>
<p><strong><code>AtomicMarkableReference</code> 类使用</strong> : 加入了mark作为标记控制，其余的部分相同，不能解决ABA</p>
<h4 id="对象属性修改类型原子类"><a href="#对象属性修改类型原子类" class="headerlink" title="对象属性修改类型原子类"></a>对象属性修改类型原子类</h4><p>如果需要原子更新类里的某个字段时，需要用到对象属性修改类型原子类。</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>: 原子更新整型字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整型字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型里的字段的更新器</li>
</ul>
<p>要想原子地更新对象的属性需要两步。第一步，因为对象属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰。</p>
<p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p>
<h5 id="对象属性修改类型原子类的使用"><a href="#对象属性修改类型原子类的使用" class="headerlink" title="对象属性修改类型原子类的使用"></a>对象属性修改类型原子类的使用</h5><p><strong><code>AtomicIntegerFieldUpdater</code> 类使用示例</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">		System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;<span class="built_in">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure>



<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 类是一种<strong>异步任务监视器</strong>，可以让提交者监视任务的执行、取消任务的执行、获取任务执行结果。</p>
<h4 id="Future作用"><a href="#Future作用" class="headerlink" title="Future作用"></a>Future作用</h4><p><code>Future</code> 类是异步思想的典型运用，主要用在需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，提高执行效率。</p>
<p>执行某一耗时任务时，将这个耗时任务交给子线程去异步执行，然后可以执行别的任务，不用原地等待耗时任务执行完成。等别的任务执行完成后，再通过 <code>Future</code> 类获取耗时任务的执行结果。这样的话程序执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，可以看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>
<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li>判断任务是否已经执行完成;</li>
<li>获取任务执行结果。</li>
</ul>
<h4 id="Future使用"><a href="#Future使用" class="headerlink" title="Future使用"></a>Future使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行</span></span><br><span class="line">    <span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cancel(boolean mayInterruptIfRunning)</code>：取消任务的执行</p>
<blockquote>
<p>执行这个方法时候，会有三种情况，</p>
<ul>
<li>第一种情况，如果<strong>任务还没开始执行</strong>，调用cancel方法后任务会被正常取消，然后返回true。</li>
<li>第二种情况，如果任务<strong>已经执行完毕或已经执行过一次cancel方法</strong>，如果再调用cancel方法，会取消失败，返回false。</li>
<li>第三种情况，如果<strong>任务正在执行</strong>，会根据传入的<code>mayInterruptIfRunning</code>参数分情况调用。如果值为true，执行任务的线程会收到中断信号，然后执行中断任务的逻辑并返回true。如果值为false，任务不会被取消，而是继续执行并返回false，表示不执行取消任务操作。</li>
</ul>
</blockquote>
</li>
<li><p><code>isCancelled()</code>：获取是否取消了任务</p>
<blockquote>
<p>用于判断任务是否被取消了</p>
</blockquote>
</li>
<li><p><code>isDone()</code>：任务是否执行完成</p>
<blockquote>
<p>如果返回true，表示任务执行完毕。返回false，表示任务还没执行完毕。有一种特殊情况，就是如果执行任务的过程发生了Exception，这种情况是会被当成执行完成的，因为抛出Exception的任务，在”Future“也是不会执行的，所以都当成执行完成返回true</p>
</blockquote>
</li>
<li><p><code>get()</code> 和 <code>get(long timeout, TimeUnit unit)</code>：获取任务执行的返回值</p>
<blockquote>
<p>get方法最主要的作用就是获取任务返回的结果，get方法可能会发生以下 3 种情况：</p>
<ul>
<li>第一种情况：如果<strong>任务执行完毕</strong>，直接返回任务执行结果。</li>
<li>第二种情况：如果<strong>任务还没执行完成</strong>，这种情况可能是任务本身业务比较复杂，需要花较长时间，也可能是放在线程池里，然后线程池中堆积了不少任务，需要等待线程来执行。这时调用get方法会把当前线程阻塞，直到任务执行完毕再返回结果。</li>
<li>第三种情况：如果<strong>任务执行过程抛出了异常</strong>，这时调用get方法会返回<code>ExecutionException</code>，不管实际的异常类型是什么。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h4><p><strong>偏向锁</strong></p>
<p>如果一把锁不存在竞争，那么就没必要上锁，只需要打个标记就行，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁，此时锁是可偏向的，当第一个线程尝试获取锁时，会将这个线程记录下来。之后如果尝试获取锁的线程是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</p>
<p><strong>轻量级锁</strong></p>
<p>JVM 开发者发现在很多情况下，synchronized 中的代码是不存在竞争的，不同线程交替执行synchronized 中的代码。这种情况下，没必要用完全互斥的重量级锁， CAS 就可以解决。当锁原来是偏向锁时，被另一个线程访问，说明存在竞争，偏向锁就会升级为轻量级锁，线程会通过自旋的方式尝试获取锁，而不会陷入阻塞。</p>
<p><strong>重量级锁</strong></p>
<p>重量级锁是互斥锁，利用操作系统的同步机制实现（锁交给OS管理），所以开销比较大。当多个线程存在竞争，轻量级锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</p>
<p>锁升级的路径：无锁→偏向锁→轻量级锁→重量级锁。</p>
<p>偏向锁性能最好，可以避免执行 CAS 操作。而轻量级锁利用自旋和 CAS 避免了重量级锁带来的线程阻塞和唤醒，性能中等。重量级锁则会把获取不到锁的线程阻塞，性能最差。</p>
<h4 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁&#x2F;不可重入锁"></a>可重入锁&#x2F;不可重入锁</h4><p>可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是线程当前持有了这把锁，如果想再次获取这把锁，必须要先释放锁后才能再次尝试获取。</p>
<p>对于可重入锁而言，最典型的就是 ReentrantLock 了，它也是 Lock 接口最主要的一个实现类。</p>
<h4 id="共享锁-独占锁"><a href="#共享锁-独占锁" class="headerlink" title="共享锁&#x2F;独占锁"></a>共享锁&#x2F;独占锁</h4><p>共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>
<h4 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h4><p>公平锁公平的含义在于如果线程拿不到锁，就会进入等待，开始排队，在等待队列里<strong>等待时间长的线程会优先拿到这把锁</strong>，有先来先得的意思。而非公平锁可能会忽略掉已经在排队的线程，发生插队现象。</p>
<h4 id="悲观锁-乐观锁"><a href="#悲观锁-乐观锁" class="headerlink" title="悲观锁&#x2F;乐观锁"></a>悲观锁&#x2F;乐观锁</h4><p>悲观锁要求在获取资源前，必须<strong>先拿到锁</strong>，以便达到“独占”的状态。当前线程在操作资源时，由于其他线程拿不到锁，所以其他线程不能来影响我。</p>
<p>乐观锁并<strong>不要求获取资源前拿到锁</strong>，也不会锁住资源；而是<strong>利用 CAS 理念</strong>，在不独占资源的情况下，对资源进行修改。</p>
<h4 id="自旋锁-非自旋锁"><a href="#自旋锁-非自旋锁" class="headerlink" title="自旋锁&#x2F;非自旋锁"></a>自旋锁&#x2F;非自旋锁</h4><p>自旋锁的理念是<strong>如果线程拿不到锁</strong>，不会陷入阻塞或释放 CPU 资源，而是<strong>利用循环，不停地尝试获取锁</strong>，这个循环过程被形象地比喻为“自旋”。</p>
<p><strong>非自旋锁</strong>的理念是如果拿不到锁，<strong>就直接放弃</strong>，或者执行其他的处理逻辑，如排队、陷入阻塞等。</p>
<p><strong>自旋锁好处：</strong>如果持有锁的线程在短时间内释放锁，等待锁的线程就不需进入阻塞状态，只需要等一等（<strong>自旋</strong>），等持有锁的线程释放锁后即可获取，这样就<strong>无需线程上下文切换&#x2F;无需用户态与内核态切换</strong>。</p>
<h4 id="可中断锁-不可中断锁"><a href="#可中断锁-不可中断锁" class="headerlink" title="可中断锁&#x2F;不可中断锁"></a>可中断锁&#x2F;不可中断锁</h4><p>在Java中，<strong>synchronized 关键字修饰的锁是不可中断锁</strong>，一旦线程申请了锁，就只能等到拿到锁之后才能进行其他的逻辑处理。</p>
<p>而 <strong>ReentrantLock 是典型的可中断锁</strong>，使用 lockInterruptibly() 方法，如果在获取锁的过程中突然不想获取了，就可以中断获取锁然后去做其他的事情，不需要等到获取到锁后才离开。</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32998153/article/details/79529704?ops_request_misc=%7B%22request_id%22:%22165776539116782184664188%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165776539116782184664188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79529704-null-null.142%5Ev32%5Eexperiment_2_v1,185%5Ev2%5Econtrol&utm_term=CAS&spm=1018.2226.3001.4187">什么是CAS机制？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwMDg2OTAxNg==&mid=2652048732&idx=1&sn=9519a130bf9776555306af126c565a20&chksm=8105faabb67273bdf908202d46690961080a1a23071416cb14845afee04fb79827748489ef04&scene=178&cur_album_id=1826996971702665222">由浅入深C A S，小白也能与BAT面试官对线 (qq.com)</a></p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>CAS（Compare and Swap）比较并替换，是一种<strong>无锁算法</strong>，即<strong>在不加锁的情况下实现多线程间的变量同步</strong>，也就是在没有线程阻塞的情况下实现变量同步，所以也叫<strong>非阻塞算法</strong>。</p>
<p><strong>CAS 机制中使用了 3 个基本操作数：</strong></p>
<ul>
<li><strong>内存地址 V，</strong></li>
<li><strong>旧的预期值 A，</strong></li>
<li><strong>要修改的新值 B。</strong></li>
</ul>
<p><strong>更新变量时，只有变量旧的预期值 A 和内存地址 V 中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</strong></p>
<p><strong>从思想上来说，synchronized 属于悲观锁，悲观的认为程序中并发情况严重，所以严防死守。CAS 属于乐观锁，乐观地认为程序中并发情况不那么严重，所以让线程不断重试更新。</strong></p>
<p><strong>在 java 中 Atomic 系列类、Lock 系列类的底层实现，甚至在 JAVA1.6 以上版本，synchronized 转变为重量级锁之前，都会采用 CAS 机制。</strong></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ol>
<li>在内存地址V当中，存储着值为10的变量。</li>
</ol>
<img src="/./res\20180312172707148" alt="img" style="zoom: 67%;">

<ol start="2">
<li>此时线程1想把变量的值增加1.对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11.</li>
</ol>
<img src="/./res\20180312172814864" alt="img" style="zoom: 67%;">

<ol start="3">
<li>在线程1要提交更新之前，线程2抢先一步，把内存地址V中的变量值率先更新成了11。</li>
</ol>
<img src="/./res\20180312172943800" alt="img" style="zoom: 67%;">

<ol start="4">
<li>线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败。</li>
</ol>
<img src="/./res\20180312173045349" alt="img" style="zoom:67%;">

<ol start="5">
<li>线程1 重新获取内存地址V的当前值，并重新计算想要修改的值。此时对线程1来说，A&#x3D;11，B&#x3D;12。这个重新尝试的过程被称为自旋。</li>
</ol>
<img src="/./res\20180312173220371" alt="img" style="zoom:67%;">

<ol start="6">
<li>这一次比较幸运，没有其他线程改变地址V的值。线程1进行比较，发现A和地址V的实际值是相等的。</li>
</ol>
<img src="/./res\20180312173331761" alt="img" style="zoom:67%;">

<ol start="7">
<li>线程1进行交换，把地址V的值替换为B，也就是12.</li>
</ol>
<img src="/./res\20180312173421205" alt="img" style="zoom:67%;">

<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>Java语言不像C，C++语言一样可以直接访问底层操作系统，但是JVM为我们开了一个后门，这个后门就是unsafe，unsafe为我们提供了硬件级别的原子操作。</p>
<p>正是 <strong>unsafe 的compareAndSwapXxx方法保证了比较和替换的原子性操作！</strong>Unsafe.cpp 文件调用了 lock cmpxchg 指令，lock实现了原子性（<strong>汇编指令cmpxchg 本身不具备原子性</strong>），lock的锁有两种可能：<strong>锁总线，锁缓存行</strong></p>
<p><strong>总线锁定：</strong></p>
<p>总线（BUS）用于计算机组件间的数据传输，CPU与其他组件间传输数据，就是靠总线完成的，比如CPU对内存的读写。</p>
<p>总线锁定指CPU使用了总线锁，总线锁就是CPU提供的LOCK#信号，当CPU在总线上输出LOCK#信号时，其他CPU的总线请求将被阻塞。</p>
<p><strong>缓存锁定：</strong></p>
<p>总线锁定方式虽然保证了原子性，但是在锁定期间会导致大量阻塞，现代CPU为了提升性能，基于缩小锁定范围的思想设计了缓存行锁定（缓存行是CPU高速缓存存储的最小单位）。</p>
<p><strong>缓存锁定是指CPU对缓存行进行锁定</strong>，当缓存行中的共享变量回写到内存时，其他CPU会通过总线嗅探机制感知该共享变量是否发生变化，如果发生变化，让自己对应的共享变量缓存行失效，然后重新从内存中读取最新数据。缓存锁定基于缓存一致性机制实现，缓存一致性机制会阻止两个以上CPU同时修改同一个共享变量（现代CPU基本都支持和使用缓存锁定机制）。</p>
<p><strong>缓存行：</strong></p>
<p>由于CPU与主存速度差异较大，所以在CPU与主存之间有<strong>3级高速缓存</strong>（L1、L2、L3），L1、L2在CPU核里面，L3在多CPU核共用的CPU里面，每次从主存中读取的数据，都要在L1、L2、L3里面放置一份。同时由于空间局部性原理，每次会从主存中获取所需变量附近64字节的数据，称为一行数据（缓存行）。</p>
<p><strong>CPU需要实现缓存一致性协议来保证缓存行同步，</strong>为了解决不同内存变量间缓存行同步的问题，可以在不同内存变量间插入7个long类型的无意义变量，这样可以确保不同的内存变量不在同一个缓存行里面。</p>
<p><img src="/.%5Cres%5Cwps1-1660474685484.jpg" alt="img"></p>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul>
<li><p><strong>CPU 开销过大</strong></p>
<p>CAS 建立在自旋锁的基础上，在高并发量情况下，如果许多线程反复尝试更新一个变量，却又一直失败，循环往复，自旋时间太长，会给 CPU 带来很大的压力。</p>
</li>
<li><p><strong>不能保证代码块的原子性</strong></p>
<p>CAS 只能保证一个变量的原子性操作，不能保证整个代码块的原子性。如果需要 3 个变量同时进行原子性更新，就只能使用 synchronized 了。</p>
</li>
<li><p><strong>ABA 问题</strong></p>
<p>这是 CAS 机制最大的问题所在。</p>
</li>
</ul>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>问题所在</strong></p>
<p>假设有两个线程，线程 <code>1</code> 读取到内存值 <code>A</code>，线程 <code>1</code> 时间片用完，切换到线程 <code>2</code>，线程 <code>2</code> 也读取到了内存值 <code>A</code>，并把它修改为 <code>B</code> 值，然后再把 <code>B</code> 值还原到 <code>A</code> 值，简单说，修改次序是<code>A-&gt;B-&gt;A</code>，接着线程 <code>1</code> 恢复运行，它发现内存值还是<code>A</code>，然后执行 <code>CAS</code> 操作，这就是著名的 <code>ABA</code> 问题。</p>
<p><strong>解决办法</strong></p>
<p>解决 <code>ABA</code> 问题也非常简单，只要追加版本号即可，每次改变版本号加<code>1</code>，即 <code>A—&gt;B—&gt;A</code>，变成 <code>1A—&gt;2B—&gt;3A</code>，在 <code>Java</code> 中提供了<code>AtomicStampedReference</code> 实现这个方案。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS介绍"><a href="#AQS介绍" class="headerlink" title="AQS介绍"></a>AQS介绍</h4><p>AQS 全称 <code>AbstractQueuedSynchronizer</code>，这个类在 <code>java.util.concurrent.locks</code> 包下面。AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单高效地构造出同步器，如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>、<code>FutureTask</code> 等。也能利用 AQS 构造出符合自己需求的同步器。</p>
<h4 id="AQS原理分析"><a href="#AQS原理分析" class="headerlink" title="AQS原理分析"></a>AQS原理分析</h4><h5 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h5><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设为有效工作线程，并将共享资源设为锁定状态。如果被请求的共享资源被占用，就需要一套线程阻塞等待及被唤醒后锁分配的机制，AQS 用 CLH 锁队列实现这个机制，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<h5 id="CLH锁队列"><a href="#CLH锁队列" class="headerlink" title="CLH锁队列"></a>CLH锁队列</h5><ul>
<li><strong>CLH锁队列</strong>是一个虚拟的双向队列，不存在队列实例，仅存在结点之间的关联关系。AQS 将请求共享资源的线程封装成 CLH 锁队列的一个结点来实现锁的分配。</li>
<li>AQS 通过内置的 FIFO 队列完成线程的排队工作。AQS 使用 int 成员变量 state 来表示同步状态，使用 <strong>CAS</strong> 对 state 进行原子操作实现值的修改。</li>
<li>state &gt; 0 时，表示已经获取了锁，state &#x3D; 0 时表示释放了锁，提供了getState()、setState(int newState)、<strong>compareAndSetState</strong>(int expect, int update)三个方法对同步状态state进行操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<img src="/./res\AQS原理图.png" alt="AQS原理图" style="zoom:67%;">

<h5 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h5><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如<code> CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code>。</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 读写锁允许多个线程同时对某一资源进行读操作。</p>
<h5 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h5><p>如果需要自定义同步器一般的方式是这样：</p>
<ol>
<li>自定义同步组件继承 <code>AbstractQueuedSynchronizer</code> 并重写指定方法。重写方法很简单，无非是对共享资源state的获取和释放。</li>
<li>将 AQS 组合在自定义同步组件中并调用其模板方法，模板方法会调用重写的方法。</li>
</ol>
<p><strong>AQS 使用模板方法设计模式，自定义同步器需要重写下面几个 AQS 钩子方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p><strong>什么是钩子方法呢？</strong> 钩子方法被声明在抽象类中，一般使用 <code>protected</code> 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板方法设计模式通过钩子方法控制固定步骤的实现。</p>
<p>篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zpScSCktFpnSWHWIQem2jg">用 Java8 改造后的模板方法模式真的是 yyds!open in new window</a>。</p>
<p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p>
<h4 id="基于AQS的组件"><a href="#基于AQS的组件" class="headerlink" title="基于AQS的组件"></a>基于AQS的组件</h4><ul>
<li><strong><code>Semaphore</code>(信号量)：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch </code>（倒计时器）：</strong> <strong><code>CountDownLatch</code> 是一个同步工具类</strong>，用来协调多个线程间的同步。通常用来控制线程等待，可以让某一个线程等待，直到倒计时结束后再开始执行。(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">CountDownLatch的理解和使用 )</a>)</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，主要应用场景也和 <code>CountDownLatch</code> 类似，可以实现线程等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。<code>CyclicBarrier</code> 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障后，屏障才会开门，被屏障拦截的线程才会继续执行。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，parties 表示屏障拦截的线程数量，线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 自己到达了屏障，然后就会被阻塞。</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h3><p><strong>JDK1.7以前：</strong></p>
<img src="/./res\java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）" style="zoom:50%;">

<p><strong>JDK1.8以后：</strong></p>
<img src="/./res\java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:50%;">

<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区（元空间）</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<p>Java 虚拟机规范对运行时数据区域的规定很宽松。以堆为例：可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。可以使用任何垃圾回收算法管理堆，也可以完全不进行垃圾回收。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作当前线程字节码的行号指示器。</p>
<p>为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各线程之间计数器互不影响。</p>
<p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>多线程的情况下，程序计数器用于记录当前线程执行到的位置，线程切换回来时能够知道上次运行到哪儿了。</li>
</ul>
<p><strong>注意</strong>：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>虚拟机栈是 JVM 运行时数据区域的一个核心</strong>，除了一些 Native 方法调用是通过本地方法栈实现的，其他方法调用都是通过虚拟机栈实现的。</p>
<p>方法调用的数据通过虚拟机栈传递，每一次方法调用都会有一个对应的栈帧被压入虚拟机栈中，方法调用结束后，对应的栈帧会被弹出。</p>
<p>虚拟机栈由一个个栈帧组成，每个栈帧中有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构中的栈类似，都是先进后出的数据结构，只支持出栈和入栈两种操作。</p>
<img src="/./res\stack-area.png" alt="Java 虚拟机栈" style="zoom: 67%;">

<p>虚拟机栈空间虽然不是无限的，但一般正常调用是不会出现问题的。如果函数调用陷入无限循环的话，就会导致虚拟机栈压入太多栈帧而占用太多空间，导致栈空间过深。当线程请求的栈的深度超过 Java 虚拟机栈的最大深度时，就会抛出 <code>StackOverFlowError</code> 错误。</p>
<p>Java 方法有两种返回方式，一种是 return 正常返回，另一种是抛出异常。两种方式都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法是正常完成还是异常完成都算作方法结束。</strong></p>
<p>除了 <code>StackOverFlowError</code> 错误外，虚拟机栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为虚拟机栈的内存大小可以动态扩展， 如果动态扩展时无法申请到足够的内存空间，就会抛出<code>OutOfMemoryError</code>异常。</p>
<p>简单总结一下程序运行中栈可能会出现两种错误：</p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 如果虚拟机栈的内存大小不允许动态扩展，当线程请求的栈的深度超过 Java 虚拟机栈的最大深度时，就会抛出 <code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> 如果虚拟机栈的内存大小可以动态扩展， 当虚拟机栈在动态扩展栈时无法申请到足够的内存空间，就会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，不同于对象本身，可能是指向对象起始地址的引用指针，也可能指向代表对象的句柄或其他与对象相关的位置）。</p>
<p><img src="/.%5Cres%5Clocal-variables-table.png" alt="局部变量表"></p>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>是方法调用的中转站，存放方法执行过程中产生的中间计算结果。计算过程中产生的临时变量也会放在操作数栈中。</p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>用于一个方法需要调用其他方法的场景。Class 文件的常量池里保存了大量的符号引用。当一个方法调用其他方法时，需要将常量池中指向方法的符号引用转换为调用方法在内存地址中的直接引用。动态链接的作用就是将符号引用转换为调用方法的直接引用。</p>
<img src="/./res\jvmimage-20220331175738692.png" alt="img" style="zoom: 80%;">

<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，本地方法栈为虚拟机执行 Native 方法服务。</strong> 在 HotSpot 虚拟机中本地方法栈和虚拟机栈合二为一。</p>
<p>本地方法执行时也会创建一个栈帧压入本地方法栈中，栈帧中存放本地方法的局部变量表、操作数栈、动态链接、方法返回地址。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是所有线程共享的一块内存区域，是 Java 虚拟机管理的内存中最大的一块，堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>堆的唯一目的就是存放对象实例，几乎所有对象实例和数组都在堆中分配内存。</strong></p>
<p>“几乎”所有的对象都在堆中分配，但是，从 JDK 1.7 开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（即没有逃逸出去），那么对象可以直接在栈上分配内存。</p>
<p>堆是垃圾收集器管理的主要区域，因此堆也被称为 <strong>GC 堆</strong>。现在收集器基本都采用分代垃圾收集算法，所以堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等。进一步划分是为了更好地回收内存或更快地分配内存。</p>
<p>在 JDK 7 及 JDK 7 之前，堆内存被通常分为下面三部分：</p>
<ul>
<li>新生代内存(Young Generation)</li>
<li>老年代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ul>
<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>
<p><strong>JDK 8 之后 PermGen(永久代) 被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> </p>
<img src="/./res\hotspot-heap-structure.png" alt="堆内存结构" style="zoom:67%;">

<p>大部分情况，会首先在 Eden 区给对象分配内存，在一次新生代垃圾回收后，如果对象还存活，就会进入 S0 或 S1，初始年龄为 1，每次新生代垃圾回收后对象的年龄会加 1，当年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。<strong>对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</strong></p>
<p>堆很容易出现 <code>OutOfMemoryError</code> 错误，表现形式 有几种，比如：</p>
<ol>
<li>**<code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code>**：当 JVM 花大量时间执行垃圾回收却只能回收少量堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> : 创建新对象时, 如果堆内存中的空间不足以存放新对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap sizeopen in new window</a>)</li>
</ol>
<h5 id="字符串常量池-1"><a href="#字符串常量池-1" class="headerlink" title="字符串常量池"></a>字符串常量池</h5><p><strong>字符串常量池</strong>是 JVM 为了提升性能、减少内存消耗，针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> , <code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的键值对是字符串和字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</p>
<p>JDK1.7 之前，字符串常量池存放在永久代中。JDK1.7 将字符串常量池和静态变量从永久代移动了 Java 堆中。</p>
<img src="/./res\method-area-jdk1.6.png" alt="method-area-jdk1.6" style="zoom:67%;">

<img src="/./res\method-area-jdk1.7.png" alt="method-area-jdk1.7" style="zoom:67%;">

<p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p>
<p>因为永久代（方法区的实现）GC 回收效率太低，只有整堆收集 Full GC 时才会执行 GC。Java 程序中通常有大量被创建的字符串等待回收，将字符串常量池放到堆中能够更高效及时地回收字符串内存。</p>
<blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>
<p>在不同的虚拟机中，方法区的实现是不同的。</p>
<p>当虚拟机要使用一个类时，需要加载并解析 Class 文件来获取相关信息，再将信息存入方法区。方法区会存储被虚拟机加载的<strong>类信息、字段信息、方法信息、常量 、即时编译器编译后的代码缓存等</strong>。</p>
<p><strong>方法区和永久代、元空间是什么关系呢？</strong> </p>
<p>方法区和永久代、元空间的关系很像接口和类的关系，永久代和元空间可以看作是类，方法区可以看作是接口，也就是说永久代和元空间是 HotSpot 虚拟机对方法区的两种实现。永久代是 JDK 1.8 之前的方法区实现，元空间是 JDK 1.8 及以后的方法区实现。</p>
<img src="/./res\method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现" style="zoom:67%;">

<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>
<ol>
<li><p>永久代的内存大小固定，无法调整，由 JVM 设置。元空间使用本地内存，受本机可用内存的限制，虽然仍旧可能溢出，但是几率更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
</li>
<li><p>元空间里存放类的元数据，加载多少类的元数据不由 <code>MaxPermSize</code> 决定, 而由系统实际可用空间决定，这样能加载的类就更多了。</p>
</li>
<li><p>JDK8 合并 HotSpot 和 JRockit 的代码时，JRockit 里没有永久代，合并后就没有必要设置永久代了。</p>
</li>
</ol>
<p><strong>方法区常用参数有哪些？</strong></p>
<p>JDK 1.8 之前，永久代还没被彻底移除时通常通过下面这些参数来调节方法区大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>

<p>垃圾收集行为在方法区比较少，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 时，方法区（HotSpot 的永久代）被彻底移除了，取而代之是元空间，元空间使用本地内存。下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始大小（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<p>与永久代不同，如果不指定大小，随着更多类的创建，虚拟机会耗尽所有可用的本地内存。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>Class 文件中除了有类信息、字段信息、方法信息等描述信息外，还有存放编译期生成的各种字面量和符号引用的 <strong>常量池表(Constant Pool Table)</strong> 。</p>
<p>字面量是源代码中固定值的表示方法，通过字面量就能知道值的含义。字面量包括整数字面量、浮点数字面量和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口符号引用。</p>
<p>常量池表会在类加载后放到方法区的运行时常量池中。</p>
<p>运行时常量池的功能类似于传统编程语言的符号表，不过包含了更广泛的数据。</p>
<p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当运行时常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存是特殊的内存缓冲区，通过 JNI 的方式在本地内存上分配。</p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是直接内存也被频繁地使用，也可能发生 <code>OutOfMemoryError</code> 错误。</p>
<p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I&#x2F;O，也被称为 New I&#x2F;O）</strong>，引入了一种基于<strong>通道（Channel）与缓存区（Buffer）的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>
<p>直接内存的分配不会受到 Java 堆的限制，但是会受到本地内存大小和处理器寻址空间的限制。</p>
<p>类似的概念还有 <strong>堆外内存</strong> 。堆外内存就是把内存分配在堆（新生代+老年代+永久代）以外的内存，堆外内存受操作系统管理而不是虚拟机，能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>
<h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h4><p>Java 自动内存管理主要针对对象内存的分配和回收。Java 自动内存管理最核心的功能是 <strong>堆</strong>内存中对象内存的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>
<p>现在收集器基本都采用分代垃圾收集算法，Java 堆被划分为几个不同的区域，这样就可以根据各个区域的特点选择合适的垃圾收集算法。</p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老年代(Old Generation)</li>
<li>永久代(Permanent Generation)</li>
</ol>
<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>
<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt="堆内存结构" style="zoom:67%;">

<p><strong>JDK 8 版本之后 PermGen (永久) 已被 Metaspace (元空间) 取代，元空间使用的是直接内存</strong> 。</p>
<h4 id="GC类型"><a href="#GC类型" class="headerlink" title="GC类型"></a>GC类型</h4><p>JVM 的 GC 分为两种：Minor GC 和 Full GC</p>
<ul>
<li><strong>Minor GC (Young GC)</strong><br>Minor GC 也叫 Young GC，主要对堆内存中新生代进行垃圾收集。Minor GC 比较频繁，回收的速度也比较快。</li>
<li><strong>Major GC (Full GC)</strong><br>Major GC 也叫 Full GC，主要对堆内存中老年代、新生代和方法区进行垃圾收集，Major GC 执行频率很低，一般几个小时才会执行一次，执行速度也比Minor GC 慢很多，大概在10倍以上。</li>
</ul>
<p><strong>HotSpot VM 的 GC 分类有两大种</strong>：</p>
<ul>
<li><p>**部分收集 (Partial GC)**：</p>
<blockquote>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
</blockquote>
</li>
<li><p>**整堆收集 (Full GC)**：对整个 Java 堆和方法区进行垃圾收集。</p>
</li>
</ul>
<h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><h5 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h5><p>大多数情况下，对象在新生代 Eden 区分配内存。当 Eden 区没有足够空间时，虚拟机将发起一次 Minor GC。如果 GC 期间虚拟机发现对象无法存入 Survivor 区，就会通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代，老年代的空间足够存放，不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。</p>
<h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p>大对象直接进入老年代是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><p>虚拟机采用分代收集的思想来管理内存，所以需要识别哪些对象应放在新生代，哪些对象应放在老年代。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>大部分情况，对象首先在 Eden 区域分配内存。如果对象在 Eden 区域出生且经第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，就会移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1 (Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p>
<p>对象在 Survivor 中每经过一次 MinorGC，年龄就加 1 ，当年龄增加到一定程度（默认为 15 岁），就会晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置</p>
<h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p>空间分配担保是<strong>为了确保 Minor GC 之前老年代还有容纳新生代所有对象的空间</strong>。</p>
<blockquote>
<p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须<strong>先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会<strong>先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败</strong>(Handle Promotion Failure)；<strong>如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小</strong>，<strong>如果大于，将尝试进行一次 Minor GC</strong>，尽管这次 Minor GC 是有风险的；<strong>如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC</strong>。</p>
<p>JDK 6 Update 24 之后规则变为<strong>虚拟机会检查老年代的连续空间是否大于新生代对象总大小或者历次晋升的平均大小，如果大于就进行 Minor GC，否则就进行 Full GC</strong>。</p>
</blockquote>
<h4 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>计数器为 0 的对象不可能再被使用，需要被回收。</li>
</ul>
<p><strong>引用计数法实现简单、效率高，但是目前主流的虚拟机中并没有选择这个算法，因为它很难解决对象之间循环引用的问题。</strong></p>
<p><img src="/.%5Cres%5Cobject-circular-reference.png" alt="对象之间循环引用"></p>
<h5 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h5><p>可达性算法将一系列称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点走过的路径称为引用链，如果一个对象到 GC Roots 没有任何引用链相连，说明此对象不可用 ，需要被回收。</p>
<p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p>
<img src="/./res\jvm-gc-roots.png" alt="可达性分析算法" style="zoom:67%;">

<p><strong>哪些对象可以作为 GC Roots？</strong></p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p>
<p>在可达性分析法中不可达的对象，也并非是“非死不可”的，这些对象暂时处于“缓刑阶段”。要真正宣告一个对象死亡，至少要经历两次标记过程；</p>
<p>可达性分析法中不可达的对象会被第一次标记然后进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。如果对象没有覆盖 <code>finalize</code> 方法，或虚拟机已经调用过<code>finalize</code> 方法，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象会被放在一个队列中进行第二次标记，除非对象与引用链上任何一个对象建立关联，否则就会被回收。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象引用链是否可达，对象的存活都与“引用”有关。</p>
<p><img src="/.%5Cres%5Cjava-reference-type.png" alt="Java 引用类型总结"></p>
<p><strong>强引用（StrongReference）</strong></p>
<p>大部分引用都是强引用，是使用最普遍的引用。如果一个对象具有强引用，就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误使程序异常终止，也不会回收具有强引用的对象。</p>
<p><strong>软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器不会回收，如果内存空间不足，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p><strong>弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。垃圾回收器线程扫描它所管辖的内存区域时，一旦发现了只具有弱引用的对象，无论当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器线程优先级很低， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p><strong>虚引用（PhantomReference）</strong></p>
<p>“虚引用”，就是形同虚设，与其他几种引用不同，虚引用不会决定对象的生命周期。如果一个对象仅持有虚引用，就和没有任何引用一样，在任何时候都可以被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收器回收的活动。</strong></p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现对象有虚引用，就会在回收对象内存前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果发现虚引用加入到引用队列中，就可以在被引用的对象的内存被回收之前采取必要的行动。</p>
<p>在程序设计中很少使用弱引用与虚引用，使用软引用的情况较多，因为<strong>软引用可以加快 JVM 垃圾回收的速度，防止内存溢出（OutOfMemory）等问题</strong>。</p>
<h4 id="常量和类的回收"><a href="#常量和类的回收" class="headerlink" title="常量和类的回收"></a>常量和类的回收</h4><p><strong>字符串常量池</strong></p>
<p>假设字符串常量池中存在字符串 “abc”，如果没有任何 String 对象引用该字符串常量，就说明常量 “abc” 是废弃常量，如果这时发生垃圾回收且有必要的话，”abc” 就会被清理出常量池。</p>
<p><strong>类</strong></p>
<p>满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，仅仅是“可以”，并不是和对象一样不使用了就必然会被回收。</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）” 和 “清除（Sweep）”两个阶段：首先标记所有不需要回收的对象，标记完成后统一回收所有没被标记的对象。</p>
<p>标记-清除算法是最基础的收集算法，后续的算法都是对其不足进行改进得到。标记-清除算法有两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong>：标记、清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<img src="/./res\mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法" style="zoom:67%;">

<p>具体是标记不可回收对象还是可回收对象，众说纷纭，两种说法其实都没问题，个人更倾向于前者。</p>
<p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p>
<ol>
<li>对象创建时，给一个标记位，假设为 0 (false)；</li>
<li>在标记阶段，将所有可达对象的标记位设置为 1 (true)；</li>
<li>清除阶段清除标记位为 0 (false)的对象。</li>
</ol>
<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。复制算法将内存分为大小相同的两块，每次使用其中一块。当一块内存使用完后，就将还存活的对象复制到另一块，然后再把原来那块内存一次清理掉。每次内存回收都是对内存区间的一半进行回收。</p>
<img src="/./res\copying-garbage-collection-algorithm.png" alt="复制算法" style="zoom:67%;">

<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较多，复制性能会变得很差。</li>
</ul>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>标记-整理（Mark-and-Compact）算法是根据老年代特点提出的算法，标记过程与“标记-清除”算法一样，后续不是直接回收可回收对象，而是让所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p>
<img src="/./res\mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法" style="zoom:67%;">

<p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不高的场景。</p>
<h5 id="分代收集算法（目前使用的）"><a href="#分代收集算法（目前使用的）" class="headerlink" title="分代收集算法（目前使用的）"></a>分代收集算法（目前使用的）</h5><p>现在虚拟机垃圾收集都采用分代收集算法，根据对象存活周期将内存分为几块。一般将 Java 堆分为新生代和老年代，然后根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>在新生代中，每次垃圾收集都会有大量对象死去，所以可以选择”复制“算法，只需少量的对象复制成本就可以完成垃圾收集。老年代中的对象存活几率比较高，而且没有额外的空间对它进行分配担保，所以必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>Serial（串行）收集器是最基本的垃圾收集器，它是一个单线程收集器，只使用一条垃圾收集线程进行垃圾收集工作，且<strong>在进行垃圾收集工作时必须暂停其他所有工作线程</strong>（ <strong>“Stop The World”</strong> ），直到垃圾收集结束。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<img src="/./res\serial-garbage-collector.png" alt="Serial 收集器" style="zoom:67%;">

<p>虚拟机的设计者知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>相比其他垃圾收集器，Serial 收集器没有线程交互的开销，所以有很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机是个不错的选择。</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余和 Serial 收集器完全一样。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<img src="/./res\parnew-garbage-collector.png" alt="ParNew 收集器 " style="zoom:67%;">

<p>ParNew 收集器是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，此时用户线程处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程和垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序继续运行，垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<h5 id="Parallel-Scavenge收集器（JDK1-8默认使用）"><a href="#Parallel-Scavenge收集器（JDK1-8默认使用）" class="headerlink" title="Parallel Scavenge收集器（JDK1.8默认使用）"></a>Parallel Scavenge收集器（JDK1.8默认使用）</h5><p>Parallel Scavenge 收集器也是多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure>

<p>Parallel Scavenge 收集器的关注点是吞吐量（高效率的利用 CPU），而 CMS 等垃圾收集器的关注点是用户线程的停顿时间（提高用户体验）。吞吐量就是 CPU 用于运行用户代码的时间与 CPU 消耗的总时间的比值。 </p>
<p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，可以使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机完成。</p>
<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p>
<img src="/./res\parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图" style="zoom:67%;">

<p><strong>这是 JDK1.8 默认收集器</strong>，默认使用 Parallel Scavenge + Parallel Old。</p>
<p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p><strong>Serial 收集器的老年代版本</strong>，也是单线程收集器。主要有两大用途：一是在 JDK1.5 及以前的版本中与 Parallel Scavenge 收集器搭配使用，二是作为 CMS 收集器的后备方案。</p>
<img src="/./res\serial-garbage-collector1.png" alt="Serial 收集器" style="zoom:67%;">

<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h5><p><strong>Parallel Scavenge 收集器的老年代版本</strong>，使用多线程和“标记-整理”算法。在注重吞吐量及高效率利用 CPU 的场合，可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<img src="/./res\parallel-scavenge-garbage-collector1.png" alt="Parallel Old收集器运行示意图" style="zoom:67%;">

<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p><strong>CMS（Concurrent Mark Sweep）收集器以最短回收停顿时间为目标，非常适合在注重用户体验的应用上使用。</strong></p>
<p><strong>CMS 收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，实现垃圾收集线程与用户线程同时工作。</strong></p>
<p>从 <strong>Mark Sweep</strong> 可以看出，CMS 收集器使用 <strong>“标记-清除”算法</strong>，整个工作过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停其他所有线程，记录与 root 直接相连的对象，速度很快；</li>
<li><strong>并发标记：</strong> 同时开启 GC 线程和用户线程，用一个闭包结构记录可达对象。这个闭包结构并不能保证包含当前所有可达对象，因为用户线程会不断更新引用域，GC 线程无法保证可达性分析的实时性。</li>
<li><strong>重新标记：</strong> 重新标记会修正并发标记期间因为用户程序运行导致标记变动的那些对象的标记，这个阶段的停顿时间比初始标记阶段稍长，比并发标记阶段短很多。</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始回收未标记的对象。</li>
</ul>
<img src="/./res\cms-garbage-collector.png" alt="CMS 收集器" style="zoom:67%;">

<p>CMS收集器是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。</p>
<p>也有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li>使用的“标记-清除”算法在收集结束后会产生大量内存碎片。</li>
</ul>
<h5 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h5><p><strong>G1 (Garbage-First) 是面向服务器的垃圾收集器，主要针对具有多个 CPU 及大容量内存的设备，以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量。</strong></p>
<p>G1 收集器具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能使用多个 CPU 或 CPU 核心来缩短 Stop-The-World 停顿时间，也可以通过并发让 GC 线程和用户线程同时执行。</li>
<li><strong>分代收集</strong>：虽然 G1 不需要其他收集器配合就能独立管理整个 GC 堆，但还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：G1 整体来看是使用“标记-整理”算法实现的，局部来看是使用“复制”算法实现。</li>
<li><strong>可预测的停顿</strong>：降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型。使用者可以指定在一个 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li>
</ul>
<p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<img src="https://oss.javaguide.cn/github/javaguide/java/jvm/g1-garbage-collector.png" alt="G1 收集器" style="zoom:67%;">

<p><strong>G1 收集器在后台维护了一个优先列表，会根据允许的收集时间，优先回收价值最大的 Region</strong>。通过 Region 划分内存空间以及有优先级的回收 Region，使 G1 收集器能在有限时间内达到尽可能高的收集效率。</p>
<h5 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h5><p>ZGC 采用复制算法，不过 ZGC 对算法做了重大改进。</p>
<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>
<p>Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p>
<p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UseZGC className</span><br></pre></td></tr></table></figure>



<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，类似 C 语言的结构体。</p>
<p><code>ClassFile</code> 的结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version; <span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version; <span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count; <span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>]; <span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags; <span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class; <span class="comment">//当前类</span></span><br><span class="line">    u2             super_class; <span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class 文件的组成：</p>
<img src="/./res\16d5ec47609818fc.jpeg" alt="ClassFile 内容分析" style="zoom: 25%;">

<h4 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure>

<p>Class 文件的头 4 个字节称为魔数（Magic Number），魔数的唯一作用是<strong>确定当前Class文件是否能被虚拟机接收</strong>。</p>
<h4 id="Class-文件版本号（Minor-Major-Version）"><a href="#Class-文件版本号（Minor-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></figure>

<p>紧接着魔数的四个字节是 Class 文件的版本号：前两个字节是<strong>次版本号</strong>，后两个字节是<strong>主版本号</strong>。</p>
<p>Java 发布大版本时，主版本号都会加 1。可以使用 <code>javap -v</code> 命令查看 Class 文件的版本号信息。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以在实际开发时要确保 JDK 版本一致。</p>
<h4 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure>

<p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p>
<p>常量池主要存放两大常量：字面量和符号引用。字面量类似 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用属于编译原理方面的概念。包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中每一项常量都是一个表，这 14 个表<strong>开始的第一位是 u1 类型的标志位 tag 来标识当前常量的常量类型。</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">标志（tag）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTANT_utf8_info</td>
<td align="center">1</td>
<td align="center">UTF-8 编码的字符串</td>
</tr>
<tr>
<td align="center">CONSTANT_Integer_info</td>
<td align="center">3</td>
<td align="center">整形字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Float_info</td>
<td align="center">4</td>
<td align="center">浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Long_info</td>
<td align="center">５</td>
<td align="center">长整型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Double_info</td>
<td align="center">６</td>
<td align="center">双精度浮点型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_Class_info</td>
<td align="center">７</td>
<td align="center">类或接口的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_String_info</td>
<td align="center">８</td>
<td align="center">字符串类型字面量</td>
</tr>
<tr>
<td align="center">CONSTANT_FieldRef_info</td>
<td align="center">９</td>
<td align="center">字段的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodRef_info</td>
<td align="center">10</td>
<td align="center">类中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InterfaceMethodRef_info</td>
<td align="center">11</td>
<td align="center">接口中方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_NameAndType_info</td>
<td align="center">12</td>
<td align="center">字段或方法的符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodType_info</td>
<td align="center">16</td>
<td align="center">方法类型符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_MethodHandle_info</td>
<td align="center">15</td>
<td align="center">方法句柄符号引用</td>
</tr>
<tr>
<td align="center">CONSTANT_InvokeDynamic_info</td>
<td align="center">18</td>
<td align="center">表示一个动态方法调用点</td>
</tr>
</tbody></table>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>：将结果输出到 temp.txt 文件)。</p>
<h4 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></figure>

<p>常量池之后的两个字节是访问标志，用于识别类或接口的访问信息，包括：这个 Class 是类还是接口，是 <code>public</code> 还是 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等。</p>
<p>类访问和属性修饰符:</p>
<p><img src="/.%5Cres%5C%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p>
<h4 id="当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure>

<p>类索引、父类索引和接口索引集合按照顺序排在访问标志之后，Java 类的继承关系由类索引、父类索引和接口索引集合三项共同确定。</p>
<p>类索引用于确定当前类的全限定名，父类索引用于确定当前类的父类的全限定名。由于 Java 是单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合描述了当前类实现的所有接口，这些接口按照 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h4 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类可以有个字段</span></span><br></pre></td></tr></table></figure>

<p>字段表（field info）描述了接口或类中声明的变量。字段包括类变量和实例变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>field info(字段表) 的结构:</strong></p>
<p><img src="/.%5Cres%5C%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p>
<ul>
<li><strong>access_flags:</strong> 字段的作用域（<code>public</code>,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符) ，能否序列化（transient 修饰符) ，可变性（final) ，可见性（volatile 修饰符）。</li>
<li><strong>name_index:</strong> 对常量池的引用，表示字段的名称；</li>
<li><strong>descriptor_index:</strong> 对常量池的引用，表示字段的描述符；</li>
<li><strong>attributes_count:</strong> 字段会拥有一些额外的属性，attributes_count 表示属性的个数；</li>
<li><strong>attributes[attributes_count]:</strong> 存放具体属性。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p>
<p><strong>字段的 access_flag 的取值:</strong></p>
<img src="/./res\image-20201031084342859.png" alt="字段的 access_flag 的取值" style="zoom:50%;">

<h4 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure>

<p>methods_count 表示方法的数量，而 method_info 表示方法表。</p>
<p>Class 文件中对方法的描述与对字段的描述几乎完全一致。方法表的结构也和字段表一样，依次是访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><strong>method_info(方法表的) 结构:</strong></p>
<p><img src="/.%5Cres%5C%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p>
<p><strong>方法表的 access_flag 取值：</strong></p>
<img src="/./res\image-20201031084248965.png" alt="方法表的 access_flag 取值" style="zoom:50%;">

<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
<h4 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure>

<p>在 Class 文件、字段表、方法表中都有属性表集合，用于描述某些场景专有的信息。与 Class 文件中其它数据项目不同，属性表集合不要求各个属性表有严格的顺序，且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自定义的属性信息，Java 虚拟机运行时会忽略掉不认识的属性。</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>从类加载到虚拟机内存中到卸载出内存，整个生命周期可以概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中<strong>验证、准备、解析</strong>统称为连接（Linking）。</p>
<img src="/./res\lifecycle-of-a-class.png" alt="一个类的完整生命周期" style="zoom:50%;">

<h4 id="类加载步骤"><a href="#类加载步骤" class="headerlink" title="类加载步骤"></a>类加载步骤</h4><p><strong>Class 文件加载到虚拟机内存后才能运行和使用。</strong></p>
<p>加载 Class 文件分为三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p>
<img src="/./res\class-loading-procedure.png" alt="类加载过程" style="zoom:50%;">

<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>类加载的第一步，主要完成下面 3 件事情：</p>
<ol>
<li>通过全类名获取类的二进制字节流。</li>
<li>将字节流代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区数据的访问入口。</li>
</ol>
<p>加载通过 <strong>类加载器</strong> 完成。类加载器有很多种，具体使用哪种类加载器加载类由 <strong>双亲委派模型</strong> 决定。</p>
<p>每个 Java 类都有一个引用，这个引用指向加载它的 <code>ClassLoader</code>。数组类不是通过 <code>ClassLoader</code> 加载的，而是 JVM 在需要时自动创建的，数组类通过 <code>getClassLoader()</code> 方法获取的 <code>ClassLoader</code> 和该数组元素类型的 <code>ClassLoader</code> 是一致的。</p>
<p>非数组类的加载阶段是可控性最强的阶段，在这个阶段还可以自定义类加载器来控制字节流的获取方式（重写类加载器的 <code>loadClass()</code> 方法）。</p>
<p>加载阶段与连接阶段的部分动作(如文件格式验证)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p><strong>验证是连接阶段的第一步，验证确保 Class 文件的字节流包含的信息符合 Java 虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身安全。</strong></p>
<p>验证阶段在整个类加载过程中耗费的资源相对较多，但很有必要，可以有效防止恶意代码的执行。</p>
<p>不过，验证阶段不是必须的。如果程序代码已经被反复使用和验证过，就可以考虑使用 <code>-Xverify:none</code> 参数关闭大部分的类验证措施来缩短虚拟机类加载的时间。</p>
<p>验证阶段主要由四个阶段组成：</p>
<ol>
<li>文件格式验证（对Class 文件进行格式检查）</li>
<li>元数据验证（对字节码描述的信息进行语义检查）</li>
<li>字节码验证（对程序进行语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ol>
<img src="/./res\class-loading-process-verification.png" alt="验证阶段示意图" style="zoom: 67%;">

<p>文件格式验证基于类的二进制字节流进行，保证类的二进制字节流能够正确解析并存储于方法区。其余三个验证阶段都在方法区存储结构上进行，不会再直接读取、操作字节流。</p>
<p>符号引用验证发生在类加载过程中的解析阶段，具体是在 JVM 将符号引用转为直接引用时。</p>
<p>符号引用验证是为了确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p>
<ul>
<li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li>
<li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个对象中不存在的字段时，抛出该异常。</li>
<li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个不存在的方法时，抛出该异常。</li>
</ul>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p><strong>准备阶段正式为类变量分配内存并设置类变量初始值</strong>，将在方法区中分配内存。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时仅对类变量（ 即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量）进行内存分配，不包括实例变量。实例变量会在对象实例化时在 Java 堆中分配内存。</li>
<li>从概念上讲，类变量应在 <strong>方法区</strong> 中分配内存。JDK 7 之前，HotSpot 使用永久代来实现方法区，这时完全符合这个逻辑概念的。 而 JDK 7 及以后，HotSpot 把原本放在永久代的字符串常量池、静态变量移动到了堆中，这时类变量就会在 Java 堆中分配内存。相关阅读：<a target="_blank" rel="noopener" href="https://github.com/fenixsoft/jvm_book/issues/75">《深入理解 Java 虚拟机（第 3 版）》勘误#75open in new window</a></li>
<li>初始值通常是数据类型默认的零值（如 0、0L、null、false 等），比如定义了 <code>public static int value = 111</code> ，在准备阶段 value 的初始值是 0 而不是 111，在初始化阶段才会给 value 赋值 111。如果给 value 变量加上了 final 关键字，<code>public static final int value = 111</code> ，那么在准备阶段时就会给 value 赋值 111。</li>
</ol>
<p><strong>基本数据类型的零值</strong>：</p>
<p><img src="/.%5Cres%5C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>解析阶段虚拟机会将常量池内的符号引用转换为直接引用</strong>，主要针对类或接口的符号引用、字段的符号引用、类中方法的符号引用、接口中方法的符号引用、方法类型符号引用、方法句柄符号引用和调用限定符共 7 类符号引用。</p>
<ul>
<li>符号引用：符号引用用一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标。符号引用与虚拟机实现的内存布局无关，引用的目标不一定是已经加载到虚拟机内存中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的。</li>
<li>直接引用：直接引用可以是直接指向目标的指针、相对偏移量或者是间接定位到目标的句柄。直接引用与虚拟机实现的内存布局直接相关，同一个符号引用在不同虚拟机上翻译出来的直接引用一般不相同。如果有直接引用，那么引用的目标必定已经在虚拟机内存中了。</li>
</ul>
<p>程序执行方法时，系统需要明确知道方法的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法，只要知道方法在方法表中的偏移量就可以调用该方法了。通过解析方法的符号引用就可以转变为目标方法在方法表中的位置，从而调用该方法。</p>
<p>综上，解析阶段虚拟机会将常量池内的符号引用转换为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p><strong>初始化阶段会执行初始化方法 <code>&lt;clinit&gt; ()</code>，是类加载的最后一步。初始化阶段 JVM 才开始真正执行类中的 Java 程序代码(字节码)。</strong></p>
<blockquote>
<p><clinit> ()&#96;方法是编译之后自动生成的。 </clinit></p>
</blockquote>
<p>调用 <code>&lt;clinit&gt; ()</code> 方法时，虚拟机会确保其在多线程环境下的安全性。<code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，如果在多线程环境下进行类初始化可能会引起多个线程阻塞，并且这种阻塞很难被发现。所以如果多个线程同时初始化一个类，那么只会有一个线程执行这个类的 <code>&lt;clinit&gt; ()</code> 方法，其他线程都需要等待，直到活动线程初始化完毕。</p>
<p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>
<ol>
<li><p>当遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这 4 条字节码指令时，会对类进行初始化。</p>
<ul>
<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即创建一个类的实例对象时。</li>
<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即访问类的静态变量 (不是静态常量，常量会被加载到运行时常量池)时。</li>
<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即给类的静态变量赋值时。</li>
<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即调用类的静态方法时。</li>
</ul>
</li>
<li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时，如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等。如果类没初始化就会对其进行初始化。</p>
</li>
<li><p>初始化一个类时，如果其父类还未初始化，则先对父类进行初始化。</p>
</li>
<li><p>虚拟机启动时，虚拟机会先初始化包含 <code>main</code> 方法的主类。</p>
</li>
<li><p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，使用这 2 个调用时必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p>
<blockquote>
<p>Reflection 和 MethodHandle 本质上都是在模拟方法的调用，Reflection 是模拟 Java 代码层次的方法调用，而 MethodHandle 是模拟字节码层次的方法调用。</p>
</blockquote>
</li>
<li><p>当一个接口中定义了默认方法（被 default 关键字修饰的接口方法），如果要初始化接口的实现类，就需要先初始化该接口。</p>
</li>
</ol>
<h4 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h4><p><strong>卸载类就是 GC 类的 Class 对象。</strong></p>
<p>卸载类需要满足 3 个要求：</p>
<ol>
<li>该类的所有实例对象都已被 GC，也就是说堆中不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用。</li>
<li>该类的类加载器实例已被 GC。</li>
</ol>
<p>在 JVM 生命周期内，jvm 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载的。</p>
<p>JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，这些类加载器的实例不会被回收。而我们自定义的类加载器的实例是可以被回收的，所使用自定义类加载器加载的类是可以被卸载的。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>类加载器负责加载类，实现类加载过程中加载这一步。</li>
<li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li>
<li>数组类不是通过 <code>ClassLoader</code> 加载的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，<strong>类加载器加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p>
<p>除了加载类之外，类加载器还可以加载 Java 应用所需的资源，如文本、图像、配置文件、视频等。</p>
<h4 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h4><p>JVM 启动时，并不会一次性加载所有类，而是根据需要动态加载。也就是说，大部分类在使用时才会加载，这样对内存更加友好。</p>
<p>已经加载的类放在 <code>ClassLoader</code> 中。类加载时会先判断当前类是否被加载过，如果当前类已被加载就直接返回，否则会尝试加载。也就是说，对于一个类加载器来说，相同名称的类只会被加载一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> &#123;</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内置类加载器"><a href="#内置类加载器" class="headerlink" title="内置类加载器"></a>内置类加载器</h4><p>   中内置了三个重要的 <code>ClassLoader</code>：</p>
<ol>
<li>**<code>BootstrapClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，没有父级，用来加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类以及 <code>-Xbootclasspath</code>参数指定路径下的所有类。</li>
<li>**<code>ExtensionClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及 <code>java.ext.dirs</code> 系统变量指定路径下的所有类。</li>
<li>**<code>AppClassLoader</code>(应用程序类加载器)**：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ol>
<p>除了这三种类加载器之外，还可以自定义类加载器，以满足特殊需求。</p>
<img src="/./res\class-loader-parents-delegation-model.png" alt="类加载器层次关系图" style="zoom:67%;">

<p><code>BootstrapClassLoader</code> 是 JVM 自身的一部分，其他的类加载器都在 JVM 外部实现，且全都继承 <code>ClassLoader</code> 抽象类。这样做的好处是可以自定义类加载器，让应用程序自己决定如何获取所需的类。</p>
<p>每个 <code>ClassLoader</code> 都可以通过 <code>getParent()</code> 获得父类 <code>ClassLoader</code>，如果获取到的 <code>ClassLoader</code> 为 <code>null</code>，说明该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>
<p><strong>为什么获取到 <code>ClassLoader</code> 为 <code>null</code> 就是由 <code>BootstrapClassLoader</code> 加载的呢？</strong> 因为 <code>BootstrapClassLoader</code> 由 C++ 实现，在 Java 中没有与之对应的类，所以拿到的结果是 <code>null</code>。</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>除了 <code>BootstrapClassLoader</code> ，其他类加载器均由 Java 实现且继承<code>ClassLoader</code>抽象类。如果要自定义类加载器，需要继承 <code>ClassLoader</code>抽象类。</p>
<p><code>ClassLoader</code> 类有两个关键的方法：</p>
<ul>
<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，<strong>实现了双亲委派机制</strong> 。<code>name</code> 为类的二进制名称，<code>resolve</code> 如果为 true，在加载时会调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>
</ul>
<p>如果不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法，无法被父类加载器加载的类会通过这个方法被加载。如果想打破双亲委派模型，就重写 <code>loadClass()</code> 方法。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><code>ClassLoader</code> 使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例在亲自查找类或资源前，会先将查找类或资源的任务委托给父类加载器。<code>BootstrapClassLoader</code> 没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。<strong>层次图见上图</strong>。</p>
<p>可以看出：</p>
<ul>
<li><code>ClassLoader</code> 使用委托模型来查找类和资源。</li>
<li>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应有父类加载器。</li>
<li><code>ClassLoader</code> 实例在亲自查找类或资源前，会将查找类或资源的任务委托给父类加载器。</li>
</ul>
<h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载器接收到类加载请求时，会先将请求转发给父类加载器。在父类加载器没有找到请求的类的情况下，类加载器才会尝试亲自去加载。</p>
<p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p>
<ul>
<li>类加载时，会先判断当前类是否已经被加载。如果已经被加载，就直接返回，否则会尝试加载。</li>
<li>类加载器在进行类加载时，在亲自加载类之前，会先把请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样，请求最终都会到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li>
<li>只有当父类加载器无法完成加载请求（搜索范围中没有找到所需的类）时，子加载器才会尝试自己加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li>
</ul>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：类的全名相同且加载类的类加载器也相同。只有两者都相同，才认为两个类相同。即使两个类来源于同一个 <code>Class</code> 文件且被同一个虚拟机加载，只要加载它们的类加载器不同，那两个类就不相同。</p>
<h5 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h5><p>双亲委派模型保证了 Java 程序的稳定，避免了类的重复加载，也保证了 Java 的核心 API 不被篡改。</p>
<p>如果没有使用双亲委派模型，然后自己编写一个 <code>Object</code> 类的话，程序运行时，系统就会加载两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的 <code>Object</code> 类，而不是自己写的 <code>Object</code> 类。因为 <code>AppClassLoader</code> 在加载自己写的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现已经加载过 <code>Object</code> 类，就会直接返回，不会再加载自己写的 <code>Object</code> 类。</p>
<h5 id="打破双亲委派模型的方法"><a href="#打破双亲委派模型的方法" class="headerlink" title="打破双亲委派模型的方法"></a>打破双亲委派模型的方法</h5><p>自定义加载器需要继承 <code>ClassLoader</code> 抽象类。如果不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法，无法被父类加载器加载的类最终会通过这个方法加载。如果想打破双亲委派模型就重写 <code>loadClass()</code> 方法。</p>
<p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p>
<blockquote>
<p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p>
</blockquote>
<p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p>
<img src="/./res\tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构" style="zoom:67%;">

<h3 id="重要的JVM参数"><a href="#重要的JVM参数" class="headerlink" title="重要的JVM参数"></a>重要的JVM参数</h3><h4 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h4><p><img src="/.%5Cres%5C%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-53ddeca6.png" alt="内存区域常见配置参数"></p>
<h5 id="显式指定堆内存–Xms和-Xmx"><a href="#显式指定堆内存–Xms和-Xmx" class="headerlink" title="显式指定堆内存–Xms和-Xmx"></a>显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h5><p>如果我们需要指定堆内存最小和最大堆大小，可以使用以下参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>heap size</strong> 表示要初始化的内存大小。</li>
<li><strong>unit</strong> 表示要初始化内存的单位。单位为<em><strong>“ g”</strong></em> (GB)、**<em>“ m”*<strong>（MB）、</strong></em>“ k”***（KB）。</li>
</ul>
<p>如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，参数应该这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></table></figure>

<h5 id="显式指定新生代内存-Young-Generation"><a href="#显式指定新生代内存-Young-Generation" class="headerlink" title="显式指定新生代内存(Young Generation)"></a>显式指定新生代内存(Young Generation)</h5><p>在配置完堆内存后，需要配置 <code>Young Generation</code> 在堆内存中所占的比例。默认情况下，YG 的最小为 1310 <em>MB</em>，最大<em>无限制</em>。</p>
<p>有两种指定新生代内存(Young Generation)大小的方法：</p>
<p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br></pre></td></tr></table></figure>

<p>如果要为新生代分配最小 256m 的内存，最大 1024m 的内存，参数应该这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br></pre></td></tr></table></figure>

<p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p>
<p>如果要为新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），参数应该这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure>

<p>GC 调优策略中很重要的一条经验总结是这样说的：</p>
<blockquote>
<p>将新对象预留在新生代，因为 Full GC 的成本远高于 Minor GC，所以尽可能将对象分配在新生代是明智的做法。在实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p>
</blockquote>
<p>还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置老年代与新生代内存的比值。</p>
<p>比如设置老年代与新生代内存的比值为 1，也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1&#x2F;2。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=1</span><br></pre></td></tr></table></figure>

<h5 id="显式指定永久代-元空间的大小"><a href="#显式指定永久代-元空间的大小" class="headerlink" title="显式指定永久代&#x2F;元空间的大小"></a>显式指定永久代&#x2F;元空间的大小</h5><p><strong>从 Java 8 开始，如果没有指定 Metaspace 的大小，随着类的创建，虚拟机会耗尽所有可用的系统内存（永久代不会出现这种情况）。</strong></p>
<p>JDK 1.8 之前永久代还没被彻底移除时通常通过下面的参数来调节方法区大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">#方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">#方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>

<p>垃圾收集行为在永久代比较少出现，但并非数据进入方法区后就“永久存在”了。</p>
<p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p>
<p>下面是一些常用参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 使用过程中触发 Full GC 的阈值</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。</p>
<p>Metaspace 由于使用扩容到<code>-XX:MetaspaceSize</code> 参数指定的量后，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p>
<p>也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。</p>
<p>垃圾搜集器内部是根据变量 <code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MetaspaceGC::initialize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// Set the high-water mark to MaxMetapaceSize during VM initializaton since</span></span><br><span class="line">  <span class="comment">// we can&#x27;t do a GC during initialization.</span></span><br><span class="line">  _capacity_until_GC = MaxMetaspaceSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h4><h5 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h5><p>为了提高应用程序的稳定性，选择正确的<a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集open in new window</a>算法至关重要。</p>
<p>JVM 具有四种类型的 GC 实现：</p>
<ul>
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS 垃圾收集器</li>
<li>G1 垃圾收集器</li>
</ul>
<p>可以使用以下参数声明这些实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<h5 id="GC-日志记录"><a href="#GC-日志记录" class="headerlink" title="GC 日志记录"></a>GC 日志记录</h5><p>生产环境或者其他要测试 GC 问题的环境，一定会配置打印 GC 日志的参数，便于分析 GC 相关的问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必选</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># 打印对象分布</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line"><span class="comment"># 打印堆数据</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment"># 打印Reference处理信息</span></span><br><span class="line"><span class="comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span></span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line"><span class="comment"># 打印STW时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span></span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 开启日志文件分割</span></span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line"><span class="comment"># 最多分割几个文件，超过之后从头文件开始写</span></span><br><span class="line">-XX:NumberOfGCLogFiles=14</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></table></figure>

<h4 id="OOM相关"><a href="#OOM相关" class="headerlink" title="OOM相关"></a>OOM相关</h4><p>对于大型应用程序，内存不足错误是非常常见的，这会导致应用程序崩溃。</p>
<p>JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，可以用来查找泄漏:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</span><br><span class="line">-XX:OnOutOfMemoryError=<span class="string">&quot;&lt; cmd args &gt;&quot;</span></span><br><span class="line">-XX:+UseGCOverheadLimit</span><br></pre></td></tr></table></figure>

<p>这里有几点需要注意:</p>
<ul>
<li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li>
<li><strong>HeapDumpPath</strong> 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用<code>.hprof</code>格式</li>
<li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError=&quot;shutdown -r&quot;</code> 。</li>
<li><strong>UseGCOverheadLimit</strong> 是一种策略，限制抛出 OutOfMemory 错误之前花费在 GC 中的时间。</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><code>-server</code> : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM</li>
<li><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存。</li>
<li><code>-XX:+UseLWPSynchronization</code>: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。</li>
<li><code>-XX:LargePageSizeInBytes </code>: 设置用于 Java 堆的较大页面大小; 它采用 GB&#x2F;MB&#x2F;KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</li>
<li><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。</li>
<li><code>-XX:SurvivorRatio</code> : eden&#x2F;survivor 空间的比例, 例如<code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</li>
<li><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</li>
<li><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</li>
<li><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</li>
<li><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。</li>
</ul>
<h3 id="OOM问题排查和解决"><a href="#OOM问题排查和解决" class="headerlink" title="OOM问题排查和解决"></a>OOM问题排查和解决</h3><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><ul>
<li><p><strong>堆溢出原因</strong></p>
<ul>
<li>无法在 Java 堆中分配对象</li>
<li>应用程序保存了无法被 GC 的对象。</li>
<li>应用程序过度使用 finalizer。</li>
</ul>
<p>对象数量达到堆最大容量限制后就会产生内存溢出异常。报错信息有两种：</p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :在创建新的对象时, 如果堆内存中的空间不足以存放新创建的对象, 就会引发此错误。</li>
</ol>
</li>
<li><p><strong>排查解决思路：</strong></p>
<ul>
<li><p>查找关键报错信息，如</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用内存映像分析工具（如Eclipsc Memory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。</p>
</li>
<li><p>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，修复应用程序中的内存泄漏。</p>
</li>
<li><p>如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 -Xmx 增加堆大小。</p>
</li>
</ul>
</li>
</ul>
<h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>关于虚拟机栈和本地方法栈，两种异常：</p>
<ul>
<li><strong>栈溢出原因</strong><ul>
<li>是否有递归调用</li>
<li>是否有大量循环或死循环</li>
</ul>
</li>
</ul>
<ol>
<li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，当线程请求的栈深度超过 Java 虚拟机栈最大深度时，就会抛出 <code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong>若栈的内存大小可以动态扩展， 如果动态扩展栈时无法申请到足够的内存空间，就会抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
<ul>
<li><strong>栈溢出排查解决思路</strong></li>
</ul>
<ol>
<li>查找关键报错信息，确定是StackOverflowError还是OutOfMemoryError</li>
<li>如果是StackOverflowError，检查代码是否递归调用方法等</li>
<li>如果是OutOfMemoryError，检查是否有死循环创建线程等，通过-Xss降低的每个线程栈的容量</li>
</ol>
<h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><p>方法区会存储被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量 、即时编译器编译后的代码缓存等。<strong>运行时产生大量的类，会填满方法区，造成溢出</strong>。</p>
<ul>
<li><p><strong>方法区溢出原因</strong></p>
<ul>
<li>使用 CGLib 生成了大量的代理类，导致方法区被撑爆</li>
<li>在 Java7 之前，频繁的错误使用 String.intern()</li>
<li>应用长时间运行，没有重启</li>
</ul>
</li>
<li><p><strong>方法区溢出排查解决思路</strong>： 方法区溢出的报错信息为 <strong><code>java.lang.OutOfMemoryError: Metaspace</code></strong></p>
<ul>
<li>检查是否永久代空间设置得过小</li>
<li>检查代码是否频繁错误得使用String.intern方法</li>
<li>检查是否使用 CGLib 生成了大量的代理类</li>
<li>重启大法，重启JVM</li>
</ul>
</li>
</ul>
<h4 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。但是，直接内存也被频繁地使用，也可能OOM。JDK1.4 加入了NIO (New Input&#x2F;Output) 类，可以使用 native 函数库直接分配堆外内存，然后将 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用，避免了在 Java 堆和直接内存中来回复制数据。</p>
<p><strong>直接内存溢出原因</strong></p>
<ul>
<li>直接内存的分配不受 Java 堆大小的限制，<strong>受本机总内存大小限制</strong>。</li>
<li>直接内存由 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</li>
<li>NIO程序中，使用ByteBuffer.allocteDirect(capability)会分配直接内存，可能导致直接内存溢出。</li>
</ul>
<p><strong>直接内存溢出</strong></p>
<ul>
<li>检查代码是否恰当</li>
<li>检查JVM参数-Xmx，-XX:MaxDirectMemorySize 是否合理。</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p><strong>定义</strong>：设计模式（Design pattern）是一套被反复使用、代码设计经验的总结。</p>
<p><strong>好处</strong>：使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<p><strong>模式：在某些场景下，针对某类问题的某种通用的解决方案。</strong></p>
<blockquote>
<p> 场景：项目所在的环境</p>
<p> 问题：约束条件，项目目标等</p>
<p> 解决方案：通用、可复用的设计，解决约束达到目标。</p>
</blockquote>
<p><strong>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong></p>
<p><strong>结构型模式：把类或对象结合在一起形成一个更大的结构。</strong></p>
<p><strong>行为型模式：类和对象如何交互，及划分责任和算法。</strong></p>
<img src="/./res\aefc6eb7f5ba13216d5f21051327816e.png" alt="img" style="zoom:67%;">



<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><p><strong>总原则——开闭原则（Open Closed Principle）</strong></p>
<p><strong>在程序需要拓展时，不能修改原有代码，而是扩展原有代码</strong>，实现一个热插拔的效果。</p>
<p><strong>1、单一职责原则（Single Responsibility Principle）</strong></p>
<p>不要有多于一个导致类变更的原因，每个类应该实现单一的职责，否则就应该把类拆分。</p>
<p><strong>2、里氏替换原则（Liskov Substitution Principle）</strong></p>
<p>所有引用父类的地方必须能透明地使用其子类的对象。</p>
<p>里氏代换原则是对开闭原则的补充。实现开闭原则的关键就是抽象化，而父类与子类的继承关系就是抽象化的具体实现。里氏替换原则中，<strong>子类尽量不要重写和重载父类的方法</strong>，因为父类代表定义好了的结构，并通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<p><strong>3、依赖倒置原则（Dependence Inversion Principle）</strong></p>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>接口中不应存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口要好。</p>
<p><strong>5、迪米特法则（最少知道原则）(Law of Demeter)</strong></p>
<p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应将逻辑封装在方法内部，并通过 public 方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>尽量使用对象组合&#x2F;聚合来将已有的对象纳入到新对象中，而不是继承。</p>
<p>组合&#x2F;聚合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，使新对象可以调用已有对象的功能。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/n3vsRQZPe0j5oIOk3umj7A">常用设计模式汇总，告诉你如何学习设计模式 (qq.com)</a></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41949328/article/details/107296517?ops_request_misc=%7B%22request_id%22:%22166070068316782248515287%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=166070068316782248515287&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107296517-null-null.142%5Ev41%5Epc_rank_34,185%5Ev2%5Etag_show&utm_term=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187">我给面试官讲解了单例模式</a></p>
<h3 id="定义与优缺点"><a href="#定义与优缺点" class="headerlink" title="定义与优缺点"></a>定义与优缺点</h3><p><strong>单例模式是指在内存中仅创建一次对象。</strong>当程序<strong>多次使用同一对象且作用相同</strong>时，为了防止频繁创建对象占用内存，所以仅在内存中<strong>创建一次对象</strong>，并让所有需要调用的地方共享这一单例对象，从而节约系统资源。</p>
<p>单例模式有两种类型：</p>
<ul>
<li><p><strong>饿汉式</strong>：在<strong>类加载</strong>时就创建单例对象，等待程序使用，不存在并发安全问题和性能问题。</p>
</li>
<li><p><strong>懒汉式</strong>：在<strong>需要使用</strong>对象时才创建单例对象，正确的实现方式是：<strong>Double Check + Lock</strong>，可以解决并发安全问题和性能问题。</p>
</li>
<li><p>开发中如果对<strong>内存要求非常高</strong>，就使用<strong>懒汉式</strong>。</p>
</li>
<li><p>如果对<strong>内存要求不高</strong>，就使用饿汉式。</p>
</li>
<li><p>为了防止多线程环境下因为指令重排序导致 NullPointerException，<strong>需要给单例对象添加volatile关键字防止指令重排序</strong>。</p>
</li>
<li><p>最优雅的实现方式是<strong>枚举</strong>，不仅没有线程安全问题，而且 Enum 类内部会<strong>防止反射和反序列化破坏单例</strong>。</p>
</li>
</ul>
<p>最常见的单例模式是 Spring 中的 bean。单例模式三要素：</p>
<ul>
<li>静态成员私有化</li>
<li>构造函数私有化</li>
<li>创建一个静态 public 方法用于创建单例对象</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>减少占用的系统资源，节省内存</li>
<li>减少对共享资源的多重占用</li>
<li>减少对象的实例化，提供了唯一实例的受控访问</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不能使用在变化的对象上</li>
<li>扩展难度大</li>
<li>滥用单例会出现一些负面问题</li>
</ul>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式在<strong>类加载</strong>时就创建单例对象，在程序调用时<strong>直接返回</strong>该单例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化静态成员变量,该实例在类加载时就被创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Single</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供公有的静态方法返回实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类加载时会在堆内存中创建一个Singleton对象，当类被卸载时，Singleton对象也随之消亡。</li>
<li>优点：没有任何锁，执行效率高，线程安全</li>
<li>缺点：容易造成内存的浪费</li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式在<strong>需要使用</strong>对象时才创建单例对象，先判断单例对象否已经创建，如果已经创建就直接返回单例对象，否则先执行实例化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Single1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在需要的时候通过类.方法的形式返回单例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Single <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Single</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>懒汉式只在需要的时候才通过类.方法的形式创建单例对象，解决了饿汉式内存浪费的问题</li>
<li>懒汉式<strong>需要使用 synchronized 关键字加锁，如果不加锁会出现问题：在单例对象还没有初始化时，多个线程同时调用该方法，就会创建多个对象，违反了单例模式的设计规则</strong></li>
<li>如果在静态方法上加锁，在多线程下会导致并行变串行，性能较低</li>
</ul>
<p><strong>每次获取对象都需要先获取锁，并发性能非常地差，极端情况下，可能会出现卡顿现象。优化性能，目标是：</strong>如果没有实例化对象则加锁创建，如果已经实例化了，则不需要加锁，直接获取实例。<strong>所以直接在方法上加锁的方式就被废掉了，因为这种方式无论如何都需要先获取锁</strong></p>
<h3 id="双检锁懒汉式-重点"><a href="#双检锁懒汉式-重点" class="headerlink" title="双检锁懒汉式(重点)"></a>双检锁懒汉式(重点)</h3><p><strong>Double Check（双重校验） + Lock（加锁）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;   <span class="comment">// 线程A或线程B获得该锁进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 volatile 关键字修饰单例对象，保证单例对象的修改对所有线程可见</strong>。</li>
<li><strong>只对单例对象初始化的步骤加锁，既不会出现创建多个对象的情况，也不影响多线程下的并发执行</strong>。</li>
</ul>
<p>使用 volatile 防止指令重排：</p>
<p>JVM 中会经过三步：</p>
<p>（1）为 singleton 分配内存空间</p>
<p>（2）初始化 singleton 对象</p>
<p>（3）将 singleton 指向分配好的内存空间</p>
<p>JVM 在 最终结果正确的情况下，可以不按照程序编码的顺序执行语句，以提高程序的性能。</p>
<p>在这三步中，第2、3步可能会指令重排序，导致创建对象的顺序变为1-3-2。当多个线程获取对象时，线程A正在创建对象的过程中，执行了1、3步骤，此时线程B判断singleton不为空，获取到未初始化的singleton对象，就会报NPE异常。</p>
<img src="/./res\aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvMTY5NDAyOS8xNTk0NTIyMzkwNzk3LTRkZjBkMDA4LTM3MmMtNDkxZi04YjlhLWY4NjBmODAzNzFhYi5wbmc" alt="image.png" style="zoom:67%;">



<h3 id="枚举模式-最安全"><a href="#枚举模式-最安全" class="headerlink" title="枚举模式(最安全)"></a>枚举模式(最安全)</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LoveLion/article/details/110983839">单例模式之枚举实现_LoveLion的博客-CSDN博客_枚举实现单例模式</a></p>
<ul>
<li><p>将类定义为枚举类，在枚举类中仅定义一个对象，<strong>Java 虚拟机会保证枚举对象的唯一性，从而实现单例模式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是枚举类型的单例模式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接通过Singleton.INSTANCE.doSomething()的方式调用即可。方便、简洁又安全。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将已有的类改造为单例类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">SingletonEnum</span><span class="params">()</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先将Singleton类的构造函数设置为private私有的，然后在Singleton类中定义一个静态的枚举类型SingletonEnum。</li>
<li>SingletonEnum中定义了枚举类型的实例对象Singleton，再按照单例模式的要求在其中定义一个Singleton类型的对象instance，其初始值为null；</li>
<li>将 SingletonEnum 的构造函数改为私有的，在私有构造函数中创建一个Singleton的实例对象；最后在 getInstance() 方法中返回该对象。</li>
<li>在实现过程中，<strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong>。</li>
</ul>
</li>
</ul>
<p><strong>枚举实现单例模式的优势在哪里？</strong></p>
<p><strong>优势1</strong>：代码对比饿汉式与懒汉式更加简洁。</p>
<p><strong>优势2</strong>：不需要做任何额外的操作去保证对象单一性与线程安全性</p>
<p><strong>程序启动时会调用 Singleton 的构造器实例化一个 Singleton 对象赋给 INSTANCE，之后再也不会实例化</strong>。</p>
<p><strong>优势3</strong>：使用枚举可以防止调用者使用<strong>反射</strong>、<strong>序列化与反序列化</strong>机制强制生成多个单例对象，破坏单例模式。</p>
<ul>
<li><p><strong>防反射</strong>：枚举类默认继承 Enum 类，利用反射调用 newInstance() 时，会判断该类是否是枚举类，如果是就抛出异常。</p>
</li>
<li><p><strong>防止反序列化创建多个枚举对象</strong>：Singleton 对象的枚举类型和枚举名字都是唯一的，所以在序列化时，仅将枚举的<strong>类型和名字</strong>输出到文件中。在反序列化成对象时，<strong>利用 Enum 类的 valueOf(String name) 方法</strong>，根据名字查找对应的枚举对象。</p>
</li>
</ul>
<p>小结：</p>
<p>（1）Enum 类内部使用 Enum 类型判定防止通过反射创建多个对象</p>
<p>（2）Enum 类通过写出（读入）对象类型和枚举名字将对象序列化（反序列化），通过 valueOf() 方法匹配枚举名找到内存中的唯一的对象实例，防止通过反序列化构造多个对象</p>
<p>（3）枚举类不需要关注线程安全、破坏单例和性能问题，因为其创建对象的时机与饿汉式单例有异曲同工之妙。</p>
<h3 id="破坏单例模式的几种方式"><a href="#破坏单例模式的几种方式" class="headerlink" title="破坏单例模式的几种方式"></a>破坏单例模式的几种方式</h3><p>除了枚举单例，其他几种单例模式都会在以下几种情况中被破坏。</p>
<h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><ul>
<li><p>如果单例类实现了 Cloneable 接口，且没有重写父类的 clone() 方法，调用 clone() 方法的话就会生成一个新对象，破坏单例模式。<strong>因为 clone() 方法不会调用构造函数，而是直接从内存中 copy 内存区域，所以单例模式的类切记不要实现 Cloneable 接口。</strong></p>
</li>
<li><p>防止克隆攻击的解决方案：重写父类的 clone() 方法，clone() 方法直接去调用 getInstance()。</p>
</li>
</ul>
<h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><ul>
<li><p>如果单例类实现了 Serializable 接口，将单例对象序列化与反序列化后就会得到一个新对象，破坏单例模式。因为<strong>在反序列化时，如果单例类实现了 Serializable 接口，就会通过 newInstance() 方法通过反射创建一个新对象</strong>。</p>
</li>
<li><p>解决方案：自定义 readResolve() 方法。因为如果单例类实现了 Serializable 接口且自定义了 readResolve() 方法，就会将 readResolve() 方法返回的对象作为反序列化的结果。</p>
</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>工厂模式</strong>是最常用的设计模式之一，属于创建型模式，提供了创建对象的最佳方式。工厂模式创建对象时不会对客户端暴露创建逻辑，即当调用者想要创建对象时，只需告诉工厂类，由工厂类去创建对象，调用者不用自己创建，也无需知道是如何创建的。</p>
<p>工厂模式分为<strong>简单工厂模式</strong>，<strong>工厂方法模式</strong>，<strong>抽象工厂模式</strong>，都属于创建型模式。主要功能都是将对象的实例化部分抽取出来，以降低系统耦合度。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul>
<li><p><strong>介绍</strong></p>
<p>简单工厂模式将不同对象的创建进行了简单的封装，也就是将不同对象的创建操作全都放到一个类中，这个类就是简单工厂类；当需要某个对象时，只需让简单工厂类根据需求创建相应的对象即可。</p>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li><strong>优点：</strong> 简单工厂模式可以根据需求，动态生成使用者所需的类的对象。使用者不用知道怎么创建对象，使得各模块各司其职，降低了系统耦合性。</li>
<li><strong>缺点：</strong>扩展性差，违背了<strong>开闭原则</strong>。新增产品时，需要修改工厂类。</li>
</ul>
</li>
<li><p><strong>实现案例</strong></p>
<ul>
<li><p>创建一个电脑抽象类</p>
</li>
<li><p>创建继承了电脑抽象类的，具体的不同品牌的电脑的实体类</p>
</li>
<li><p>创建一个电脑工厂类，根据电脑的名字创建具体的电脑</p>
</li>
<li><p><strong>测试：使用工厂生产不同品牌电脑并使用</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul>
<li><p><strong>介绍</strong></p>
<p>工厂方法模式中，工厂类下面还有很多子工厂类，对象是由子工厂类创建的。工厂方法模式改进了简单工厂模式，需要一个新产品时，只需扩展一个新的子工厂类即可，不用修改原有的代码，符合开闭原则。</p>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li><strong>优点</strong>：<strong>扩展性好，符合了开闭原则</strong>，新增一种产品时，只需增加对应的产品类和子工厂类即可，无需修改原有的代码。<strong>也符合单一职责原则</strong>，每个子工厂类只负责一种产品，而不是一个工厂生成所有商品。</li>
<li><strong>缺点：</strong>新增产品时需要提供对应的子工厂类，系统中类的个数将会成倍增加，增加了系统的复杂性。</li>
</ul>
</li>
<li><p><strong>实现案例</strong></p>
<ul>
<li><p><strong>创建一个电脑抽象类</strong></p>
</li>
<li><p><strong>创建继承了电脑抽象类的，具体的不同品牌的电脑的实体类</strong></p>
</li>
<li><p><strong>创建一个电脑抽象工厂类</strong></p>
</li>
<li><p><strong>根据不同的电脑品牌创建电脑抽象工厂类的子类</strong></p>
</li>
<li><p><strong>测试：使用不同子工厂类生产不同品牌电脑并使用</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul>
<li><p><strong>介绍</strong></p>
<p>工厂方法模式针对某一类产品，而抽象工厂模式可以针对多类产品。即工厂方法模式解决的是生产不同品牌的同一类型的产品，而抽象工厂模式解决的是生产不同品牌的多种类型的产品。</p>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li><strong>优点：</strong>抽象工厂类创建了多个类型的产品，有需求时可以创建相关产品子类和子工厂类来获取。</li>
</ul>
</li>
<li><p><strong>缺点：</strong>扩展新种类产品困难。抽象工厂模式需要在抽象工厂类中提前确定需要的产品种类，如果需要的产品种类没有在抽象工厂类中提前确定，就需要去修改抽象工厂类，一旦修改了抽象工厂类，那么所有的子工厂类也需要修改，扩展不方便。</p>
</li>
<li><p><strong>实现案例</strong></p>
<ul>
<li><p><strong>创建各种类型的电脑抽象类</strong></p>
</li>
<li><p><strong>创建具体的不同品牌的各种类型的电脑实体类</strong></p>
</li>
<li><p><strong>创建一个电脑的抽象工厂类</strong></p>
</li>
<li><p><strong>创建电脑抽象工厂类的子类（根据不同的电脑品牌）</strong></p>
</li>
<li><p><strong>测试：使用不同子工厂创建不同品牌的不同种类的电脑</strong></p>
</li>
</ul>
</li>
</ul>
<p>​	<img src="https://img-blog.csdnimg.cn/20201125000745500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNzMyMTk1,size_4,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Xu Wenjin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/">http://example.com/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/20/%E5%90%8E%E7%AB%AF/" title="Spring框架后端八股"><img class="cover" src="/img/cover/Spring%E6%A1%86%E6%9E%B6%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Spring框架后端八股</div></div><div class="info-2"><div class="info-item-1">本文总结了Java后端开发及Spring框架相关知识。</div></div></div></a><a class="pagination-related" href="/2025/01/06/Selenium%E5%85%AB%E5%A4%A7%E5%AE%9A%E4%BD%8D/" title="Selenium八大定位"><img class="cover" src="/img/cover/selenium%E5%85%AB%E5%A4%A7%E5%AE%9A%E4%BD%8D.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Selenium八大定位</div></div><div class="info-2"><div class="info-item-1">本文总结了在做web自动化测试时，利用selenium定位页面元素的八大定位方式。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC82MDYzOS8zNzExMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是操作系统？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">操作系统的管理对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel%E5%92%8CCPU"><span class="toc-number">1.1.3.</span> <span class="toc-text">Kernel和CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%EF%BC%88Kernel%EF%BC%89"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">内核（Kernel）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%8CCentral-Processing-Unit%EF%BC%89"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">中央处理器（CPU，Central Processing Unit）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-vs-Kernel-%E5%86%85%E6%A0%B8"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">CPU vs Kernel(内核)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.5.</span> <span class="toc-text">操作系统的基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">并发性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">共享性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">互斥共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">同时访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%80%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">虚拟性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">时分复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%88%86%E5%A4%8D%E7%94%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">空分复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">频分复用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%80%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">异步性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Zookepper-%E5%8D%8F%E8%B0%83%E6%80%A7"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Zookepper 协调性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">进程、线程、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">进程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">三态模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.1.2.</span> <span class="toc-text">五态模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">命名管道和匿名管道的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">进程的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.3.1.</span> <span class="toc-text">先来先服务调度算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.3.2.</span> <span class="toc-text">最短作业优先调度算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.3.3.</span> <span class="toc-text">高响应比优先调度算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.3.4.</span> <span class="toc-text">时间片轮转调度算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.3.5.</span> <span class="toc-text">最高优先级调度算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.1.3.6.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BC%95%E5%8F%91"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">死锁的引发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">死锁的预防</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">死锁的避免</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.2.2.4.</span> <span class="toc-text">死锁的检测</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">1.3.2.2.4.1.</span> <span class="toc-text">进程-资源分配图</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.2.2.4.2.</span> <span class="toc-text">死锁检测步骤</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">1.3.2.2.5.</span> <span class="toc-text">死锁的解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9%E5%9C%A8%E4%BA%8E%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%82%A3%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AF%94%EF%BC%8C%E5%8D%8F%E7%A8%8B%E6%9C%89%E4%BD%95%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.4.</span> <span class="toc-text">进程和线程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.5.</span> <span class="toc-text">并发和并行区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.6.</span> <span class="toc-text">同步和异步区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">线程安全和不安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.1.</span> <span class="toc-text">内存管理的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BC%98%E7%82%B9"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">定义与优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">虚拟内存技术实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">内存管理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">分段式管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">分页式管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.3.2.2.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.4.3.2.3.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">1.4.3.2.4.</span> <span class="toc-text">快表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5VS%E5%88%86%E9%A1%B5"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">分段VS分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">段页式管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">缺页中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">常见的页面置换算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">1.5.</span> <span class="toc-text">微内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">微内核的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%8F%90%E4%BE%9B%E7%9A%84%E6%94%AF%E6%92%91%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.2.</span> <span class="toc-text">内核提供的支撑功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.3.</span> <span class="toc-text">内核提供的资源管理功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-number">1.6.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">Linux文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inode"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">inode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">Linux 文件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.2.</span> <span class="toc-text">Linux基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">查看系统性能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%92%8CCPU%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.2.1.1.</span> <span class="toc-text">查看内存和CPU信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%92%8CLinux%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD"><span class="toc-number">1.6.2.1.2.</span> <span class="toc-text">查看主机运行时间和Linux系统负载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7cpu"><span class="toc-number">1.6.2.1.3.</span> <span class="toc-text">实时监控cpu</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98"><span class="toc-number">1.6.2.1.4.</span> <span class="toc-text">实时监控内存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%88%87%E6%8D%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">目录切换命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%89"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">目录的操作命令（增删改查）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%89"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">文件的操作命令（增删改查）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">压缩文件的操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">其他常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-IO"><span class="toc-number">1.6.3.</span> <span class="toc-text">Linux IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">五种IO模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88select%E3%80%81poll%E3%80%81epoll%EF%BC%89"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">IO多路复用（select、poll、epoll）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">OSI模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">TCP&#x2F;IP四层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">2.2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">2.2.2.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E9%99%85%E5%B1%82"><span class="toc-number">2.2.3.</span> <span class="toc-text">网际层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-number">2.2.4.</span> <span class="toc-text">网络接口层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">2.3.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">2.3.2.</span> <span class="toc-text">IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">分类地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="toc-number">2.3.3.</span> <span class="toc-text">相关技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">ARP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">ICMP协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PING%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">PING工作原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-UDP"><span class="toc-number">2.4.</span> <span class="toc-text">TCP&#x2F;UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">2.4.1.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">头部格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.4.1.2.1.</span> <span class="toc-text">1.  三次握手详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="toc-number">2.4.1.2.2.</span> <span class="toc-text">2. 为什么是三次握手？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">2.4.1.2.3.</span> <span class="toc-text">3. 初始化的序列号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">2.4.1.2.4.</span> <span class="toc-text">4. 握手丢失会怎么样？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.4.1.3.1.</span> <span class="toc-text">1. 四次挥手详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">2.4.1.3.2.</span> <span class="toc-text">2. 为什么是四次挥手？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">2.4.1.3.3.</span> <span class="toc-text">3. 挥手丢失会怎么样？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-TCP-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.3.4.</span> <span class="toc-text">4. TCP 关闭连接的方式和区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-TIME-WAIT-%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.1.3.5.</span> <span class="toc-text">5.  TIME-WAIT 状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%85%E9%9A%9C"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">连接故障</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C"><span class="toc-number">2.4.1.4.1.</span> <span class="toc-text">客户端出现故障</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83"><span class="toc-number">2.4.1.4.2.</span> <span class="toc-text">服务端进程崩溃</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF"><span class="toc-number">2.4.1.4.3.</span> <span class="toc-text">客户端拔掉网线</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">TCP保证可靠传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.4.1.6.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.4.1.6.1.</span> <span class="toc-text">发送方的滑动窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">2.4.1.6.2.</span> <span class="toc-text">接收方的滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E7%AA%97%E5%A4%A7%E5%B0%8F%E2%89%88%E5%8F%91%E9%80%81%E7%AA%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.1.6.2.1.</span> <span class="toc-text">接受窗大小≈发送窗大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.1.7.</span> <span class="toc-text">重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">2.4.1.7.1.</span> <span class="toc-text">超时重传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">2.4.1.7.2.</span> <span class="toc-text">快速重传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SACK%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.7.3.</span> <span class="toc-text">SACK方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Duplicate-SACK"><span class="toc-number">2.4.1.7.4.</span> <span class="toc-text">Duplicate SACK</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.1.8.</span> <span class="toc-text">流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E7%BC%93%E5%AD%98%E5%92%8C%E6%94%B6%E7%BC%A9%E7%AA%97%E5%8F%A3"><span class="toc-number">2.4.1.8.1.</span> <span class="toc-text">减少缓存和收缩窗口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="toc-number">2.4.1.8.2.</span> <span class="toc-text">窗口关闭</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E5%BE%81"><span class="toc-number">2.4.1.8.3.</span> <span class="toc-text">糊涂窗口综合征</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.1.9.</span> <span class="toc-text">拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">2.4.1.9.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">2.4.1.9.2.</span> <span class="toc-text">拥塞避免</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="toc-number">2.4.1.9.3.</span> <span class="toc-text">拥塞发生</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">2.4.1.9.4.</span> <span class="toc-text">快速恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">2.4.1.10.</span> <span class="toc-text">连接队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">2.4.1.10.1.</span> <span class="toc-text">全连接队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.1.10.1.1.</span> <span class="toc-text">队列大小</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%E7%9A%84%E5%9B%9E%E5%BA%94%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.1.10.1.2.</span> <span class="toc-text">队列已满的回应策略</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">2.4.1.10.2.</span> <span class="toc-text">半连接队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F-1"><span class="toc-number">2.4.1.10.2.1.</span> <span class="toc-text">队列大小</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TCP-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E6%94%B6%E5%88%B0-SYN-%E5%8C%85%EF%BC%89%E6%97%B6%E4%BC%9A%E8%A2%AB%E4%B8%A2%E5%BC%83%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.4.1.10.2.2.</span> <span class="toc-text">TCP 第一次握手（收到 SYN 包）时会被丢弃的三种条件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#syncookies"><span class="toc-number">2.4.1.10.2.3.</span> <span class="toc-text">syncookies</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#syn%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB"><span class="toc-number">2.4.1.10.3.</span> <span class="toc-text">syn洪泛攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.10.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.10.3.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A2%9E%E5%A4%A7%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">2.4.1.10.3.3.</span> <span class="toc-text">增大半连接队列</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.1.10.4.</span> <span class="toc-text">半连接队列大小</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E5%90%AF-tcp-syncookies-%E5%8A%9F%E8%83%BD"><span class="toc-number">2.4.1.10.4.1.</span> <span class="toc-text">开启 tcp_syncookies 功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%8F%E5%B0%91-SYN-ACK-%E9%87%8D%E4%BC%A0%E6%AC%A1%E6%95%B0"><span class="toc-number">2.4.1.10.4.2.</span> <span class="toc-text">减少 SYN+ACK 重传次数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.1.11.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-1"><span class="toc-number">2.4.1.11.1.</span> <span class="toc-text">三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.1.11.1.1.</span> <span class="toc-text">客户端优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.1.11.1.2.</span> <span class="toc-text">服务端优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.4.1.11.1.3.</span> <span class="toc-text">绕过三次握手</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-1"><span class="toc-number">2.4.1.11.2.</span> <span class="toc-text">四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%96%B9%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.1.11.2.1.</span> <span class="toc-text">主动方优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E6%96%B9%E4%BC%98%E5%8C%96"><span class="toc-number">2.4.1.11.2.2.</span> <span class="toc-text">被动方优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E4%B8%AA%E6%95%B0"><span class="toc-number">2.4.1.12.</span> <span class="toc-text">连接个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RST%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">2.4.1.13.</span> <span class="toc-text">RST报文段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MSS%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E9%95%BF%E5%BA%A6"><span class="toc-number">2.4.1.14.</span> <span class="toc-text">MSS最大报文长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">2.4.2.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">UDP实现可靠传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.4.2.1.1.</span> <span class="toc-text">协议设计</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E9%95%BF%E5%BA%A6"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">最大传输长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">UDP编程问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.5.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">HTTP是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1xx"><span class="toc-number">2.5.1.2.1.</span> <span class="toc-text">1xx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2xx"><span class="toc-number">2.5.1.2.2.</span> <span class="toc-text">2xx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3xx"><span class="toc-number">2.5.1.2.3.</span> <span class="toc-text">3xx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4xx"><span class="toc-number">2.5.1.2.4.</span> <span class="toc-text">4xx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5xx"><span class="toc-number">2.5.1.2.5.</span> <span class="toc-text">5xx</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-number">2.5.1.3.</span> <span class="toc-text">HTTP常见字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Host"><span class="toc-number">2.5.1.3.1.</span> <span class="toc-text">Host</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Connection"><span class="toc-number">2.5.1.3.2.</span> <span class="toc-text">Connection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Accept"><span class="toc-number">2.5.1.3.3.</span> <span class="toc-text">Accept</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Accept-Encoding"><span class="toc-number">2.5.1.3.4.</span> <span class="toc-text">Accept-Encoding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Content-Type"><span class="toc-number">2.5.1.3.5.</span> <span class="toc-text">Content-Type</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Content-Encoding"><span class="toc-number">2.5.1.3.6.</span> <span class="toc-text">Content-Encoding</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.1.4.</span> <span class="toc-text">HTTP请求方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GET%E5%92%8CPOST"><span class="toc-number">2.5.1.4.1.</span> <span class="toc-text">GET和POST</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.5.1.5.</span> <span class="toc-text">HTTP长连接和短连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E6%8A%A5%E6%96%87"><span class="toc-number">2.5.1.6.</span> <span class="toc-text">HTTP报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.2.</span> <span class="toc-text">HTTP缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8HTTP%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">为什么要使用HTTP缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">HTTP1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2-0"><span class="toc-number">2.5.4.</span> <span class="toc-text">HTTP2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP3"><span class="toc-number">2.5.5.</span> <span class="toc-text">HTTP3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.5.5.1.</span> <span class="toc-text">HTTP&#x2F;2不足</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">2.5.5.1.1.</span> <span class="toc-text">队头阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP-%E4%B8%8E-TLS-%E7%9A%84%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BB%B6%E8%BF%9F"><span class="toc-number">2.5.5.1.2.</span> <span class="toc-text">TCP 与 TLS 的握手时延迟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%81%E7%A7%BB%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.5.5.1.3.</span> <span class="toc-text">网络迁移需要重新连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC-%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.5.5.2.</span> <span class="toc-text">QUIC 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">2.5.5.2.1.</span> <span class="toc-text">无队头阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%BF%AB%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.5.5.2.2.</span> <span class="toc-text">更快的连接建立</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB"><span class="toc-number">2.5.5.2.3.</span> <span class="toc-text">连接迁移</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP3-%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.5.5.3.</span> <span class="toc-text">HTTP3 协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS"><span class="toc-number">2.5.6.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">HTTP&#x2F;1.1的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.5.6.2.</span> <span class="toc-text">HTTPS的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.6.3.</span> <span class="toc-text">HTTP和HTTPS的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3HTTP%E7%9A%84%E4%B8%89%E5%A4%A7%E9%A3%8E%E9%99%A9"><span class="toc-number">2.5.6.4.</span> <span class="toc-text">HTTPS如何解决HTTP的三大风险</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86"><span class="toc-number">2.5.6.4.1.</span> <span class="toc-text">信息加密</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.6.4.2.</span> <span class="toc-text">校验机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%B9%A6"><span class="toc-number">2.5.6.4.3.</span> <span class="toc-text">身份证书</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.6.5.</span> <span class="toc-text">TSL握手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TSL%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.5.6.5.1.</span> <span class="toc-text">TSL第一次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TSL%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.5.6.5.2.</span> <span class="toc-text">TSL第二次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TSL%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.5.6.5.3.</span> <span class="toc-text">TSL第三次握手</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TSL%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.5.6.5.4.</span> <span class="toc-text">TSL第四次握手</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.5.6.6.</span> <span class="toc-text">HTTPS如何优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">2.5.6.6.1.</span> <span class="toc-text">硬件优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.5.6.6.2.</span> <span class="toc-text">密钥交换算法优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TLS%E5%8D%87%E7%BA%A7"><span class="toc-number">2.5.6.6.3.</span> <span class="toc-text">TLS升级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie%E5%92%8CSession"><span class="toc-number">2.5.7.</span> <span class="toc-text">Cookie和Session</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie%E5%92%8CSession%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.7.3.</span> <span class="toc-text">Cookie和Session配合使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.7.4.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FSession"><span class="toc-number">2.5.7.5.</span> <span class="toc-text">分布式Session</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="toc-number">2.6.</span> <span class="toc-text">网络攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDos%E6%94%BB%E5%87%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text">DDos攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB"><span class="toc-number">2.6.2.</span> <span class="toc-text">XSS攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">2.6.3.</span> <span class="toc-text">SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%B0%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9B%B4%E6%8E%A5%E6%94%BE%E5%85%A5SQL%E8%AF%AD%E5%8F%A5%E4%B8%AD"><span class="toc-number">2.6.3.0.1.</span> <span class="toc-text">避免将用户输入直接放入SQL语句中</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java"><span class="toc-number">3.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">3.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">Java特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E3%80%81JRE%E3%80%81JDK"><span class="toc-number">3.1.2.</span> <span class="toc-text">JVM、JRE、JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E3%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98"><span class="toc-number">3.1.3.</span> <span class="toc-text">字节码、编译和解释并存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Oracle-JDK%E5%92%8COpen-JDK"><span class="toc-number">3.1.4.</span> <span class="toc-text">Oracle JDK和Open JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%92%8CC"><span class="toc-number">3.1.5.</span> <span class="toc-text">Java和C++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.6.</span> <span class="toc-text">成员变量、局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">何为成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.7.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E3%80%81finally%E3%80%81finalize"><span class="toc-number">3.1.7.1.</span> <span class="toc-text">final、finally、finalize</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#final%EF%BC%9A"><span class="toc-number">3.1.7.1.1.</span> <span class="toc-text">final：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#finally%EF%BC%9A"><span class="toc-number">3.1.7.1.2.</span> <span class="toc-text">finally：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract"><span class="toc-number">3.1.7.2.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">3.1.7.3.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.7.4.</span> <span class="toc-text">switch 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public%E3%80%81protected%E3%80%81private%E3%80%81default"><span class="toc-number">3.1.8.</span> <span class="toc-text">访问修饰符(public、protected、private、default)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="toc-number">3.1.9.</span> <span class="toc-text">重载（Overload）和重写（Override）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.10.</span> <span class="toc-text">静态方法和静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.10.1.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.10.2.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">3.1.10.3.</span> <span class="toc-text">静态方法为什么不能调用非静态成员?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.1.10.4.</span> <span class="toc-text">静态变量、代码块、和静态方法的执行顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">基本数据类型和包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">基本类型和包装类型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">包装类型的缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">自动装箱和拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.2.3.</span> <span class="toc-text">浮点数精度丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E8%BF%87Long%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.2.4.</span> <span class="toc-text">超过Long的数据表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">面向对象三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">面向对象和面向过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">对象相等和引用相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.3.5.</span> <span class="toc-text">接口和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.5.3.</span> <span class="toc-text">共同点和区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.6.</span> <span class="toc-text">深拷贝、浅拷贝、引用拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">实现浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.3.6.2.</span> <span class="toc-text">实现深拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E7%B1%BB%EF%BC%88Object%E3%80%81String%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">重要的类（Object、String）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">hashcode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">wait()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#notifiy"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">notifiy()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%B1%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">String 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">字符串常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%9A%84-equals"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">String 的 equals()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%9A%84-intern"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">String 的 intern()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">String、StringBuilder、StringBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%81"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">+、+&#x3D;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.5.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exception-%E5%92%8C-Error"><span class="toc-number">3.5.1.</span> <span class="toc-text">Exception 和 Error</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8"><span class="toc-number">3.5.2.</span> <span class="toc-text">运行时异常和一般异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.3.</span> <span class="toc-text">异常处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw-%E5%92%8C-throws"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">throw 和 throws</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">异常使用时需要注意的点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.1.</span> <span class="toc-text">泛型的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">3.6.2.</span> <span class="toc-text">泛型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">3.6.3.</span> <span class="toc-text">泛型的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">3.6.4.</span> <span class="toc-text">泛型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">什么是泛型中的限定通配符和非限定通配符 ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%9B%E5%9E%8B-T-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">通配符 ? 和常用的泛型 T 之间有什么区别?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">3.7.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.7.1.</span> <span class="toc-text">反射的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-Class-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.2.</span> <span class="toc-text">获取 Class 对象的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.7.3.</span> <span class="toc-text">反射使用的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.4.</span> <span class="toc-text">反射机制的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.7.5.</span> <span class="toc-text">反射的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.8.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.1.</span> <span class="toc-text">注解的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">标准注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">自定义注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">3.8.2.</span> <span class="toc-text">注解的解析方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">3.9.</span> <span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.9.1.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">3.9.2.</span> <span class="toc-text">Java IO流分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">字符流和字节流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.9.3.</span> <span class="toc-text">Java IO的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO%E5%88%86%E7%B1%BB"><span class="toc-number">3.9.4.</span> <span class="toc-text">Java IO分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO%EF%BC%88Blocking-IO%EF%BC%89"><span class="toc-number">3.9.4.1.</span> <span class="toc-text">BIO（Blocking IO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%EF%BC%88Non-Blocking-IO%EF%BC%89"><span class="toc-number">3.9.4.2.</span> <span class="toc-text">NIO（Non-Blocking IO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO%EF%BC%88Asynchronous-IO%EF%BC%89"><span class="toc-number">3.9.4.3.</span> <span class="toc-text">AIO（Asynchronous IO）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">3.10.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">3.10.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">3.10.2.</span> <span class="toc-text">底层数据结构总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.10.3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">3.10.3.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.3.1.1.</span> <span class="toc-text">ArrayList 构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">3.10.3.1.2.</span> <span class="toc-text">ArrayList 扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.10.3.1.3.</span> <span class="toc-text">ArrayList 的序列化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList"><span class="toc-number">3.10.3.2.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.3.2.1.</span> <span class="toc-text">LinkedList 和 ArrayList 的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-number">3.10.3.3.</span> <span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector-%E5%92%8C-ArrayList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.10.3.3.1.</span> <span class="toc-text">Vector 和 ArrayList 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">3.10.4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">3.10.4.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">3.10.4.2.</span> <span class="toc-text">LinkedHashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">3.10.4.3.</span> <span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7"><span class="toc-number">3.10.4.4.</span> <span class="toc-text">无序性和不可重复性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.10.4.5.</span> <span class="toc-text">HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-number">3.10.5.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deque"><span class="toc-number">3.10.5.1.</span> <span class="toc-text">Deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">3.10.5.2.</span> <span class="toc-text">BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityQueue"><span class="toc-number">3.10.5.3.</span> <span class="toc-text">PriorityQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">3.10.6.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">3.10.6.1.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.6.1.1.</span> <span class="toc-text">底层结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">3.10.6.1.2.</span> <span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put-%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.6.1.3.</span> <span class="toc-text">put()原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#resize-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">3.10.6.1.4.</span> <span class="toc-text">resize() 扩容机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="toc-number">3.10.6.1.5.</span> <span class="toc-text">HashMap 的长度为什么是 2 的幂次方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-number">3.10.6.1.6.</span> <span class="toc-text">扩容后的数据迁移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hashcode-%E3%80%81hash-%E4%B8%8E%E4%B8%8B%E6%A0%87%E8%AE%A1%E7%AE%97"><span class="toc-number">3.10.6.1.7.</span> <span class="toc-text">hashcode()、hash()与下标计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81"><span class="toc-number">3.10.6.1.8.</span> <span class="toc-text">解决 hash 冲突</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E8%A7%A3%E5%86%B3-hash-%E5%86%B2%E7%AA%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">3.10.6.1.9.</span> <span class="toc-text">为什么在解决 hash 冲突的时候，不直接用红黑树？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">3.10.6.1.10.</span> <span class="toc-text">HashMap 多线程操作导致死循环问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-number">3.10.6.2.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap"><span class="toc-number">3.10.6.3.</span> <span class="toc-text">TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">3.10.7.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">3.10.7.1.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.7.1.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7-1"><span class="toc-number">3.10.7.1.2.</span> <span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.10.7.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.7.1.4.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">3.10.7.1.5.</span> <span class="toc-text">可能问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable"><span class="toc-number">3.10.7.1.6.</span> <span class="toc-text">ConcurrentHashMap 和 Hashtable</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">3.10.7.2.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockingQueue-1"><span class="toc-number">3.10.7.3.</span> <span class="toc-text">BlockingQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="toc-number">3.11.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">3.11.1.1.</span> <span class="toc-text">并发编程三个特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.11.1.2.</span> <span class="toc-text">Java中的线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.11.1.3.</span> <span class="toc-text">Java中的线程上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">3.11.1.4.</span> <span class="toc-text">Java中的死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.11.1.4.1.</span> <span class="toc-text">死锁示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.11.1.4.2.</span> <span class="toc-text">死锁条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D"><span class="toc-number">3.11.1.4.3.</span> <span class="toc-text">死锁预防和避免</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.11.1.5.</span> <span class="toc-text">线程创建的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%88%96-Callable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.11.1.5.1.</span> <span class="toc-text">实现 Runnable 或 Callable 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB%E5%B9%B6%E9%87%8D%E5%86%99-Run-%E6%96%B9%E6%B3%95"><span class="toc-number">3.11.1.5.2.</span> <span class="toc-text">继承 Thread 类并重写 Run 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA"><span class="toc-number">3.11.1.5.3.</span> <span class="toc-text">通过线程池创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.11.1.5.4.</span> <span class="toc-text">创建方式的对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.11.1.6.</span> <span class="toc-text">线程死亡的三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="toc-number">3.11.2.</span> <span class="toc-text">JMM（Java内存模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.11.2.1.</span> <span class="toc-text">八种同步操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before"><span class="toc-number">3.11.2.2.</span> <span class="toc-text">happens-before</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread"><span class="toc-number">3.11.3.</span> <span class="toc-text">Thread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#currentThread"><span class="toc-number">3.11.3.1.</span> <span class="toc-text">currentThread()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">3.11.3.2.</span> <span class="toc-text">run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start"><span class="toc-number">3.11.3.3.</span> <span class="toc-text">start()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt"><span class="toc-number">3.11.3.4.</span> <span class="toc-text">interrupt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep"><span class="toc-number">3.11.3.5.</span> <span class="toc-text">sleep()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">3.11.3.6.</span> <span class="toc-text">join()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">3.11.4.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.11.4.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.11.4.2.</span> <span class="toc-text">底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#monitor"><span class="toc-number">3.11.4.2.1.</span> <span class="toc-text">monitor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.11.4.2.2.</span> <span class="toc-text">修饰同步代码块的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.11.4.2.3.</span> <span class="toc-text">修饰方法的的情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">3.11.4.3.</span> <span class="toc-text">锁升级机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">3.11.4.3.1.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.11.4.3.2.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.11.4.3.3.</span> <span class="toc-text">重量级锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-number">3.11.5.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">3.11.5.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.11.5.2.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.11.5.3.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E5%92%8C-synchronized"><span class="toc-number">3.11.5.4.</span> <span class="toc-text">volatile 和 synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.11.6.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">3.11.6.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.11.6.2.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.6.3.</span> <span class="toc-text">内存泄漏问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.11.7.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">3.11.7.1.</span> <span class="toc-text">处理任务流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">3.11.7.2.</span> <span class="toc-text">创建方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0"><span class="toc-number">3.11.7.3.</span> <span class="toc-text">常见参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">3.11.7.4.</span> <span class="toc-text">动态参数配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">3.11.7.5.</span> <span class="toc-text">饱和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">3.11.7.6.</span> <span class="toc-text">常用的阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%91%BD%E5%90%8D"><span class="toc-number">3.11.7.7.</span> <span class="toc-text">线程池命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E8%AE%BE%E5%AE%9A%E7%AD%96%E7%95%A5"><span class="toc-number">3.11.7.8.</span> <span class="toc-text">线程池大小设定策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-API"><span class="toc-number">3.11.8.</span> <span class="toc-text">Lock API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.11.8.1.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.11.8.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E-synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.11.8.1.2.</span> <span class="toc-text">与 synchronized 的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">3.11.8.2.</span> <span class="toc-text">ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.11.8.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.8.2.2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StampedLock"><span class="toc-number">3.11.8.3.</span> <span class="toc-text">StampedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">3.11.8.3.1.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.11.9.</span> <span class="toc-text">Atomic 原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.11.9.1.</span> <span class="toc-text">基本类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.9.1.1.</span> <span class="toc-text">基本类型原子类的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">3.11.9.1.2.</span> <span class="toc-text">基本类型原子类的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.11.9.1.3.</span> <span class="toc-text">AtomicInteger线程安全原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.11.9.2.</span> <span class="toc-text">数组类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.9.2.1.</span> <span class="toc-text">数组类型原子类的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.11.9.3.</span> <span class="toc-text">引用类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.9.3.1.</span> <span class="toc-text">引用类型原子类的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">3.11.9.4.</span> <span class="toc-text">对象属性修改类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.9.4.1.</span> <span class="toc-text">对象属性修改类型原子类的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-number">3.11.10.</span> <span class="toc-text">Future</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%E4%BD%9C%E7%94%A8"><span class="toc-number">3.11.10.1.</span> <span class="toc-text">Future作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future%E4%BD%BF%E7%94%A8"><span class="toc-number">3.11.10.2.</span> <span class="toc-text">Future使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.11.11.</span> <span class="toc-text">锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">3.11.11.1.</span> <span class="toc-text">偏向锁&#x2F;轻量级锁&#x2F;重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.11.11.2.</span> <span class="toc-text">可重入锁&#x2F;不可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">3.11.11.3.</span> <span class="toc-text">共享锁&#x2F;独占锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.11.11.4.</span> <span class="toc-text">公平锁&#x2F;非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">3.11.11.5.</span> <span class="toc-text">悲观锁&#x2F;乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">3.11.11.6.</span> <span class="toc-text">自旋锁&#x2F;非自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81-%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-number">3.11.11.7.</span> <span class="toc-text">可中断锁&#x2F;不可中断锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">3.11.12.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.11.12.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">3.11.12.2.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.11.12.3.</span> <span class="toc-text">底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.11.12.4.</span> <span class="toc-text">CAS的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.12.5.</span> <span class="toc-text">ABA问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">3.11.13.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.11.13.1.</span> <span class="toc-text">AQS介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">3.11.13.2.</span> <span class="toc-text">AQS原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88"><span class="toc-number">3.11.13.2.1.</span> <span class="toc-text">原理概览</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CLH%E9%94%81%E9%98%9F%E5%88%97"><span class="toc-number">3.11.13.2.2.</span> <span class="toc-text">CLH锁队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">3.11.13.2.3.</span> <span class="toc-text">资源共享方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">3.11.13.2.4.</span> <span class="toc-text">自定义同步器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EAQS%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">3.11.13.3.</span> <span class="toc-text">基于AQS的组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">3.12.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.12.1.</span> <span class="toc-text">JVM内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">3.12.1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">3.12.1.2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">3.12.1.2.1.</span> <span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">3.12.1.2.2.</span> <span class="toc-text">操作数栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">3.12.1.2.3.</span> <span class="toc-text">动态链接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">3.12.1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.12.1.4.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0-1"><span class="toc-number">3.12.1.4.1.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">3.12.1.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">3.12.1.5.1.</span> <span class="toc-text">运行时常量池</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">3.12.1.6.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.12.2.</span> <span class="toc-text">JVM垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.12.2.1.</span> <span class="toc-text">堆内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.2.2.</span> <span class="toc-text">GC类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99"><span class="toc-number">3.12.2.3.</span> <span class="toc-text">内存分配和回收原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.12.2.3.1.</span> <span class="toc-text">对象优先在 Eden 区分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">3.12.2.3.2.</span> <span class="toc-text">大对象直接进入老年代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">3.12.2.3.3.</span> <span class="toc-text">长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">3.12.2.3.4.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">3.12.2.4.</span> <span class="toc-text">死亡对象判断方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.12.2.4.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">3.12.2.4.2.</span> <span class="toc-text">可达性算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.2.5.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="toc-number">3.12.2.6.</span> <span class="toc-text">常量和类的回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.12.2.7.</span> <span class="toc-text">垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.12.2.7.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.12.2.7.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.12.2.7.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88%E7%9B%AE%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%89"><span class="toc-number">3.12.2.7.4.</span> <span class="toc-text">分代收集算法（目前使用的）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88JDK1-8%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">3.12.2.8.3.</span> <span class="toc-text">Parallel Scavenge收集器（JDK1.8默认使用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.4.</span> <span class="toc-text">Serial Old 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.5.</span> <span class="toc-text">Parallel Old 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.6.</span> <span class="toc-text">CMS 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.7.</span> <span class="toc-text">G1 收集器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ZGC-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.12.2.8.8.</span> <span class="toc-text">ZGC 收集器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.12.3.</span> <span class="toc-text">类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AD%94%E6%95%B0%EF%BC%88Magic-Number%EF%BC%89"><span class="toc-number">3.12.3.1.</span> <span class="toc-text">魔数（Magic Number）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7%EF%BC%88Minor-Major-Version%EF%BC%89"><span class="toc-number">3.12.3.2.</span> <span class="toc-text">Class 文件版本号（Minor&amp;Major Version）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88Constant-Pool%EF%BC%89"><span class="toc-number">3.12.3.3.</span> <span class="toc-text">常量池（Constant Pool）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97-Access-Flags"><span class="toc-number">3.12.3.4.</span> <span class="toc-text">访问标志(Access Flags)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%B1%BB%EF%BC%88This-Class%EF%BC%89%E3%80%81%E7%88%B6%E7%B1%BB%EF%BC%88Super-Class%EF%BC%89%E3%80%81%E6%8E%A5%E5%8F%A3%EF%BC%88Interfaces%EF%BC%89%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88"><span class="toc-number">3.12.3.5.</span> <span class="toc-text">当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88%EF%BC%88Fields%EF%BC%89"><span class="toc-number">3.12.3.6.</span> <span class="toc-text">字段表集合（Fields）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88%EF%BC%88Methods%EF%BC%89"><span class="toc-number">3.12.3.7.</span> <span class="toc-text">方法表集合（Methods）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88%EF%BC%88Attributes%EF%BC%89"><span class="toc-number">3.12.3.8.</span> <span class="toc-text">属性表集合（Attributes）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.12.4.</span> <span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.12.4.1.</span> <span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.12.4.2.</span> <span class="toc-text">类加载步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.12.4.2.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">3.12.4.2.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">3.12.4.2.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">3.12.4.2.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">3.12.4.2.5.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.12.4.3.</span> <span class="toc-text">类卸载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.12.5.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99"><span class="toc-number">3.12.5.1.</span> <span class="toc-text">加载规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.12.5.2.</span> <span class="toc-text">内置类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.12.5.3.</span> <span class="toc-text">自定义类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.12.5.4.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.12.5.4.1.</span> <span class="toc-text">执行流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.12.5.4.2.</span> <span class="toc-text">双亲委派模型的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.12.5.4.3.</span> <span class="toc-text">打破双亲委派模型的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84JVM%E5%8F%82%E6%95%B0"><span class="toc-number">3.12.6.</span> <span class="toc-text">重要的JVM参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">3.12.6.1.</span> <span class="toc-text">堆内存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E5%A0%86%E5%86%85%E5%AD%98%E2%80%93Xms%E5%92%8C-Xmx"><span class="toc-number">3.12.6.1.1.</span> <span class="toc-text">显式指定堆内存–Xms和-Xmx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98-Young-Generation"><span class="toc-number">3.12.6.1.2.</span> <span class="toc-text">显式指定新生代内存(Young Generation)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%B0%B8%E4%B9%85%E4%BB%A3-%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.12.6.1.3.</span> <span class="toc-text">显式指定永久代&#x2F;元空间的大小</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E7%9B%B8%E5%85%B3"><span class="toc-number">3.12.6.2.</span> <span class="toc-text">GC相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.12.6.2.1.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">3.12.6.2.2.</span> <span class="toc-text">GC 日志记录</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OOM%E7%9B%B8%E5%85%B3"><span class="toc-number">3.12.6.3.</span> <span class="toc-text">OOM相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.12.6.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%92%8C%E8%A7%A3%E5%86%B3"><span class="toc-number">3.12.7.</span> <span class="toc-text">OOM问题排查和解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-number">3.12.7.1.</span> <span class="toc-text">堆溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">3.12.7.2.</span> <span class="toc-text">栈溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">3.12.7.3.</span> <span class="toc-text">方法区溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">3.12.7.4.</span> <span class="toc-text">直接内存溢出</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">设计模式分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">4.2.</span> <span class="toc-text">六大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.1.</span> <span class="toc-text">定义与优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A3%80%E9%94%81%E6%87%92%E6%B1%89%E5%BC%8F-%E9%87%8D%E7%82%B9"><span class="toc-number">4.3.4.</span> <span class="toc-text">双检锁懒汉式(重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E6%A8%A1%E5%BC%8F-%E6%9C%80%E5%AE%89%E5%85%A8"><span class="toc-number">4.3.5.</span> <span class="toc-text">枚举模式(最安全)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.6.</span> <span class="toc-text">破坏单例模式的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%9A%86"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-1"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.4.</span> <span class="toc-text">抽象工厂模式</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Xu Wenjin</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">欢迎浏览我的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="关键字搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>