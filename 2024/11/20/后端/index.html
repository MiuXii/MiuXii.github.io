<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring框架后端八股 | 知识小岛</title><meta name="author" content="Xu Wenjin"><meta name="copyright" content="Xu Wenjin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文总结了Java后端开发及Spring框架相关知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring框架后端八股">
<meta property="og:url" content="http://example.com/2024/11/20/%E5%90%8E%E7%AB%AF/index.html">
<meta property="og:site_name" content="知识小岛">
<meta property="og:description" content="本文总结了Java后端开发及Spring框架相关知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover/Spring%E6%A1%86%E6%9E%B6%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1.jpg">
<meta property="article:published_time" content="2024-11-20T13:32:37.000Z">
<meta property="article:modified_time" content="2025-05-08T03:50:28.401Z">
<meta property="article:author" content="Xu Wenjin">
<meta property="article:tag" content="Spring框架">
<meta property="article:tag" content="后端开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover/Spring%E6%A1%86%E6%9E%B6%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spring框架后端八股",
  "url": "http://example.com/2024/11/20/%E5%90%8E%E7%AB%AF/",
  "image": "http://example.com/img/cover/Spring%E6%A1%86%E6%9E%B6%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1.jpg",
  "datePublished": "2024-11-20T13:32:37.000Z",
  "dateModified": "2025-05-08T03:50:28.401Z",
  "author": [
    {
      "@type": "Person",
      "name": "Xu Wenjin",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/2024/11/20/%E5%90%8E%E7%AB%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":150,"languages":{"author":"Author: Xu Wenjin","link":"Link: ","source":"Source: 知识小岛","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring框架后端八股',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fa fa-link"></i><span> 学习资源</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(img/cover/Spring框架后端八股.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">知识小岛</span></a><a class="nav-page-title" href="/"><span class="site-name">Spring框架后端八股</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="fa-fw fa fa-link"></i><span> 学习资源</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spring框架后端八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-20T13:32:37.000Z" title="Created 2024-11-20 21:32:37">2024-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-08T03:50:28.401Z" title="Updated 2025-05-08 11:50:28">2025-05-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%90%8E%E7%AB%AF/">Java后端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><meta name="referrer" content="no-referrer">


<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a>Spring 基础</h2><h3 id="Spring概念"><a href="#Spring概念" class="headerlink" title="Spring概念"></a>Spring概念</h3><p>Spring 是一款<strong>开源的轻量级 Java 开发框架</strong>，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>Spring 提供的核心功能主要是 <strong>IoC 和 AOP</strong>。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP (Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<h3 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h3><p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C20200831175708.png" alt="Spring5.x主要模块"></p>
<h4 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h4><p><strong>Spring 框架的核心模块，主要为 IoC 依赖注入功能提供支持</strong>。Spring 其他所有功能都需要依赖于该模块。</p>
<ul>
<li><strong>spring-core</strong> ：Spring 框架的核心工具类，Spring 的其他模块基本都需要依赖于该模块。</li>
<li><strong>spring-beans</strong> ：<strong>对 bean 的创建、配置和管理等功能提供支持。</strong></li>
<li><strong>spring-context</strong> ：对国际化、事件传播、资源加载等功能提供支持。</li>
<li><strong>spring-expression</strong> ：对表达式语言（Spring Expression Language） SpEL 提供支持，只依赖 core 模块，可以单独使用。</li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul>
<li><strong>spring-aspects</strong> ：为集成 AspectJ 提供支持。</li>
<li><strong>spring-aop</strong> ：提供<strong>面向切面编程的实现。</strong></li>
<li><strong>spring-instrument</strong> ：为 JVM 添加代理（agent）。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限</li>
</ul>
<h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><ul>
<li><strong>spring-messaging</strong> 是 Spring4.0 新加入的模块，<strong>为 Spring 框架集成一些基础的报文传送应用。</strong></li>
</ul>
<h4 id="Data-Access-Intergration"><a href="#Data-Access-Intergration" class="headerlink" title="Data Access &#x2F; Intergration"></a>Data Access &#x2F; Intergration</h4><ul>
<li><strong>spring-jdbc</strong> ：<strong>提供访问数据库的抽象 JDBC。</strong>不同的数据库有自己独立的 API 用于操作数据库， JDBC 屏蔽了不同数据库的影响，Java 程序只需和 JDBC API 交互即可访问不同数据库。</li>
<li><strong>spring-tx</strong> ：提供对事务的支持。</li>
<li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li>
<li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li>
<li><strong>spring-jms</strong> : 消息服务。Spring Framework 4.1 以后还提供了对 spring-messaging 模块的继承。</li>
</ul>
<h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul>
<li><strong>spring-web</strong> ：<strong>为 Web 功能的实现提供最基础的支持。</strong></li>
<li><strong>spring-webmvc</strong> ：提供 Spring MVC 的实现。</li>
<li><strong>spring-websocket</strong> ：提供对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 引入的响应式框架。与 Spring MVC 不同，WebFlux 不需要 Servlet API，是完全异步的。</li>
</ul>
<h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><ul>
<li><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
</li>
</ul>
<h3 id="Spring-Spring-MVC-Spring-Boot"><a href="#Spring-Spring-MVC-Spring-Boot" class="headerlink" title="Spring &#x2F; Spring MVC &#x2F; Spring Boot"></a>Spring &#x2F; Spring MVC &#x2F; Spring Boot</h3><ul>
<li><p><strong>Spring</strong> 是一款<strong>开源的轻量级 Java 开发框架</strong>，旨在简化 J2EE 企业应用程序开发，Spring 中包含多个功能模块，其中最重要的是 Spring-Core（为 IoC 依赖注入功能提供支持） 模块， Spring 中的其他模块的功能实现基本都需要依赖于该模块。</p>
</li>
<li><p><strong>Spring MVC</strong> 是 Spring 中的重要模块，让 <strong>Spring 能够快速构建 MVC 架构的 Web 程序</strong>。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，核心思想是将<strong>业务逻辑、数据、显示</strong>分离来组织代码。</p>
</li>
<li><p><strong>Spring Boot</strong> 旨在简化 Spring 开发（减少配置文件，开箱即用！）。因为使用 Spring 开发时需要用 XML 或 Java 进行显式配置，过于麻烦。于是，Spring Boot 诞生了！</p>
</li>
</ul>
<h2 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h2><h3 id="Bean的定义"><a href="#Bean的定义" class="headerlink" title="Bean的定义"></a>Bean的定义</h3><p>Bean 指<strong>被 IoC 容器管理的对象</strong>，可以通过 <strong>xml 配置文件、注解或 Java 配置类</strong>告诉 IoC 容器要管理哪些对象。</p>
<h3 id="声明Bean的方式"><a href="#声明Bean的方式" class="headerlink" title="声明Bean的方式"></a>声明Bean的方式</h3><ul>
<li><code>@Component</code> ：被 <code>@Component</code> 注解标注的类会被注册为 <code>Bean</code>。如果一个类不知道属于哪个层，可以使用 <code>@Component</code>  注解标注。</li>
<li><code>@Repository</code> : 在 Dao 层使用， Dao 层主要用于数据库相关操作。</li>
<li><code>@Service</code> : 在 Service 层使用，Service 层主要涉及业务逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 在 Controller 层使用，Controller 层主要用于接受用户请求并调用 Service 层返回数据给前端。</li>
</ul>
<h3 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h3><ul>
<li><strong><code>@Component</code> 注解作用于类，<code>@Bean</code>注解作用于方法。</strong></li>
<li><code>@Component</code> 通常通过<strong>类路径扫描来自动侦测并自动装配到 Ioc 容器中</strong>（使用 <code>@ComponentScan</code> 注解定义要扫描的路径，从中找出被 <code>@Component</code> 注解标注的类并自动装配到 Ioc  容器中）。</li>
<li>被 <code>@Bean</code> 注解标注的方法通常会<strong>在方法中产生 Bean 对象</strong>，然后再把 Bean 对象放入 IOC 容器中。被 <code>@Bean</code> 注解标注的方法 Spring 只会调用一次。</li>
<li><strong><code>@Bean</code> 的自定义性比 <code>@Component</code> 更强</strong>，很多地方只能通过 <code>@Bean</code> 注解来注册 bean。比如需要将第三方库中的类装配到 <code>Spring</code>容器中，就只能通过 <code>@Bean</code>来实现。</li>
</ul>
<h3 id="注入-Bean-的方式"><a href="#注入-Bean-的方式" class="headerlink" title="注入 Bean 的方式"></a>注入 Bean 的方式</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr>
<th>Annotaion</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr>
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody></table>
<p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p>
<h3 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h3><ul>
<li>@Autowired 是 <strong>Spring 提供的注解</strong>，@Resource 是 <strong>JDK 提供的注解</strong></li>
<li>@Autowired 默认注入方式是 <strong>byType 根据类型匹配</strong>，如果一个接口有多个实现类，byType 方式会注入失败，就需要 <strong><code>byName</code> 根据名称匹配</strong>，名称通常就是类名的首字母小写。建议使用 @Autowired + @Qualifier，通过 @Qualifier 注解来显式指定名称。</li>
<li>@Resource 默认注入方式是 <strong>byName</strong>，其次是 <strong>byType</strong>。@Resource 有两个属性 name 和 type，仅指定 name 属性则注入方式为 byName，如果仅指定type 属性则注入方式为byType，如果同时指定 <code>name</code>  和 <code>type</code> 属性（不建议这么做）则注入方式为 <code>byType</code> + <code>byName</code>。</li>
</ul>
<h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中每个类只有唯一的 Bean 实例。Spring 中的 Bean 默认是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建新的 Bean 实例。也就是连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用）: 每一次 HTTP 请求都会产生新的 Bean（请求 Bean），该 Bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用） : 每一次来自新 session 的 HTTP 请求都会产生一个 Bean（会话 Bean），该 Bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong> （仅 Web 应用）： Web 应用启动时创建一个 Bean（应用 Bean），该 Bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用）：每一次 WebSocket 会话都会产生一个新的 Bean。</li>
</ul>
<p>配置方式：</p>
<p><strong>xml 方式</strong>：通过 scope 属性配置 bean 的作用域</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注解方式</strong>：@Bean + @Scope 注解配置bean的作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例-Bean-的线程安全问题"><a href="#单例-Bean-的线程安全问题" class="headerlink" title="单例 Bean 的线程安全问题"></a>单例 Bean 的线程安全问题</h3><ul>
<li><p><strong>单例 Bean 存在线程安全问题</strong>，<strong>多个线程同时操作一个单例 Bean 时存在资源竞争</strong>。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义 <code>ThreadLocal</code> 变量，将可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>大部分 Bean 都是无状态（<strong>没有实例变量</strong>）的（如 Dao、Service），这种情况下 Bean 是线程安全的。</p>
<h4 id="无状态和有状态"><a href="#无状态和有状态" class="headerlink" title="无状态和有状态"></a>无状态和有状态</h4><ul>
<li><strong>有状态会话 Bean</strong>  ：有状态就是有数据存储功能，有状态 Bean 就是有可变实例变量的 Bean ，可以保存数据，是<strong>非线程安全</strong>的。每个用户开始都会得到一个初始 Bean，在用户生存期内，Bean 会保持用户的信息，即“有状态”。一旦用户灭亡，Bean 的生命期也结束。</li>
<li><strong>无状态会话 Bean</strong>  ：无状态 Bean 就是没有可变实例变量的 Bean，不能保存数据，是<strong>线程安全</strong>的。无状态 Bean 没有特定的用户，不能保持用户的信息，所以叫无状态 Bean。无状态会话 Bean 并非没有实例变量。</li>
</ul>
</li>
</ul>
<h4 id="解决有状态Bean的线程安全问题"><a href="#解决有状态Bean的线程安全问题" class="headerlink" title="解决有状态Bean的线程安全问题"></a>解决有状态Bean的线程安全问题</h4><p>Spring对bean的配置中有四种配置方式，我们只说其中两种：singleton单例模式、prototype原型模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;testManager&quot;</span> class=<span class="string">&quot;com.sw.TestManagerImpl&quot;</span> scope=<span class="string">&quot;singleton&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;testManager&quot;</span> class=<span class="string">&quot;com.sw.TestManagerImpl&quot;</span> scope=<span class="string">&quot;prototype&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>默认的配置是 singleton。</p>
<p>singleton 表示该 bean 全局只有一个实例。</p>
<p>prototype 表示该 bean 每次被注入时，都会重新创建一个实例，适用于有状态的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果有两个用户同时访问</span><br><span class="line"></span><br><span class="line">假定为user1,user2</span><br><span class="line"></span><br><span class="line">当user1 调用到程序中的<span class="number">1</span>步骤的时候，该Bean的私有变量user被付值为user1</span><br><span class="line"></span><br><span class="line">当user1的程序走到<span class="number">2</span>步骤的时候，该Bean的私有变量user被重新付值为user1_create</span><br><span class="line"></span><br><span class="line">理想的状况，当user1走到<span class="number">3</span>步骤的时候，私有变量user应该为user1_create;</span><br><span class="line"></span><br><span class="line">但如果在user1调用到<span class="number">3</span>步骤之前，user2开始运行到了<span class="number">1</span>步骤了，由于单态的资源共享，则私有变量user被修改为user2</span><br><span class="line"></span><br><span class="line">这种情况下，user1的步骤<span class="number">3</span>用到的user.getId()实际用到是user2的对象。</span><br></pre></td></tr></table></figure>

<p>对于这种情况我们可以这样解决</p>
<p>1.将有状态的 bean 配置成 <strong>prototype</strong> 模式，这样每个线程拿到的都是新的 Bean 实例，但是这样会产生消耗较多的内存空间。</p>
<p>2.在类中定义 <code>ThreadLocal</code> 变量，给每条线程设置变量副本。</p>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><ul>
<li>加载 Spring 配置文件，通过反射生成 Bean 实例。</li>
<li>Bean 实例化后调用属性的 set 方法设置对象属性。</li>
<li>检查当前 Bean 是否实现了 <code>xxxAware</code> 接口，执行相应的 set 方法。<ul>
<li>如果实现了 <code>BeanNameAware</code> 接口，Spring 会调用 <code>setBeanName()</code> 方法将当前 Bean 的名字作为属性传入。</li>
<li>如果实现了 <code>BeanFactoryAware</code> 接口，Spring 将调用 <code>setBeanFactory()</code> 方法将 BeanFactory 容器实例传入。</li>
<li>如果实现了 <code>ApplicationContextAware</code> 接口，Spring 将调用 <code>setApplicationContext()</code> 方法将当前 Bean 所在应用上下文的引用传入。</li>
</ul>
</li>
<li><strong>BeanPostProcessor 的前置处理</strong>：检查当前 Bean 是否实现了 <code>BeanPostProcessor</code> 接口，如果实现了 Spring 将调用 <code>postProcessBeforeInitialization()</code> 方法。</li>
<li>检查当前 Bean 是否实现了 <code>InitializingBean</code> 接口，如果实现了 Spring 将调用 <code>afterPropertiesSet()</code> 方法。</li>
<li>检查当前 Bean 在配置文件中的定义是否包含 <code>init-method</code> 属性，如果有则调用相应的方法。</li>
<li><strong>BeanPostProcessor的后置处理</strong>：检查当前 Bean 是否实现了 <code>BeanPostProcessor</code>  接口，如果实现了 Spring 将调用 <code>postProcessAfterInitialization()</code> 方法。</li>
<li>此时 Bean 已经准备就绪，可以被应用程序使用了，并且将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
<li>销毁 Bean 时，如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring  将调用 <code>destroy()</code> 方法。如果 Bean 在配置文件中的定义包含 <code>destroy-method </code> 属性，也会调用相应的方法。</li>
</ul>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cb5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期"></p>
<h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h2><h3 id="IOC的定义"><a href="#IOC的定义" class="headerlink" title="IOC的定义"></a>IOC的定义</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486938&idx=1&sn=c99ef0233f39a5ffc1b98c81e02dfcd4&chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&token=1736772241&lang=zh_CN#rd">面试被问了几百遍的 IoC 和 AOP )</a></p>
<p><strong>IoC（Inverse of Control:控制反转）将原来在程序中手动创建对象的控制权交给 Spring 框架管理。</strong> 由 IoC 容器来管理对象间的依赖关系，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p>
<p><strong>IoC 容器是 Spring 实现 IoC 的载体，IoC 容器就像一个工厂。需要创建对象时，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何创建的。</strong></p>
<p>Spring 启动时会加载配置文件，使用反射机制来创建和初始化对象，并将创建的对象存入 Spring 容器中，需要时直接从容器中注入即可。</p>
<p><strong>IoC 容器实际上是 Map，Map 中存放的是各种对象。</strong></p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cfrc-365faceb5697f04f31399937c059c162.png" alt="img"></p>
<h3 id="IOC-的实现"><a href="#IOC-的实现" class="headerlink" title="IOC 的实现"></a>IOC 的实现</h3><ul>
<li><strong>导入 Spring 依赖</strong></li>
</ul>
<p>新建 Maven 程序，在 pom.xml 中引入 Spring 相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring-context 中引入了 aop、core、beans 和 expression</p>
<ul>
<li><strong>新建 Person 类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法person()被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了setAge()方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了setName()方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建Spring配置文件</strong></li>
</ul>
<p>在 resources 目录下新建 Spring 的配置文件 application.xml，并将 Person 类添加到配置文件中，由 Spring 来管理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.whut.entity.Person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hwf&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>① <code>&lt;bean&gt;</code> 标签代表将该类的对象交由 Spring 来管理。</p>
<p>② bean 标签的作用相当于创建了一个类的对象，id 为对象名，class 为对象类型。</p>
<p>③ 对象的属性由 <code>&lt;property&gt;</code> 标签定义，name 表示属性名，如果属性为基本数据类型，则使用 value 来赋值，如果属性为引用数据类型，则使用 ref 来赋值。</p>
<p>④ 属性的设置是利用 set 方法来注入的，所以必须有对应的 set() 方法</p>
<ul>
<li><strong>从 IOC 容器中获取对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">springApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以读取XML文件的形式来获取Spring的上下文对象</span></span><br><span class="line">        <span class="comment">//这一步会读取xml配置文件，创建和初始化配置文件中的对象并存入Spring容器中</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从容器中获取对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="IOC容器的启动过程"><a href="#IOC容器的启动过程" class="headerlink" title="IOC容器的启动过程"></a>IOC容器的启动过程</h3><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">Spring IOC 容器源码分析_Javadoop</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hbs321123/article/details/38824091">FileSystemXmlApplicationContext</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:/project/bean.xml&quot;</span>);<span class="comment">//根据具体路径加载文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:/*.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注：其中 <code>FileSystemXmlApplicationContext</code> 和 <code>ClassPathXmlApplicationContext</code> 与 <code>BeanFactory</code> 的 xml 文件定位方式一样是基于路径的。<br>BeanFactory 是生产 bean 的工厂，负责生产和管理 bean 实例，ApplicationContext 其实就是一个 BeanFactory。</p>
<ul>
<li><p><strong>ClassPathXmlApplicationContext(String configLocation)</strong></p>
<p>调用上述的构造器时会进入如下重载的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>super(parent)</code>：调用父类构造器，如果当前应用环境存在父环境，则建立两者的父子环境关系。</li>
<li><code>setConfigLocations(configLocations)</code>：对配置文件的路径进行处理，添加到<code>configLocations</code>数组中</li>
<li><strong>refresh()<strong>：</strong>核心的初始化方法</strong>。为什么叫 refresh()，而不叫 init() ？因为 ApplicationContext 建立起来以后，可以通过 refresh() 方法来重建，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</li>
</ul>
</li>
<li><p><strong>refresh()</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，xml 配置文件会被解析成一个个 BeanDefinition，并注册到 BeanFactory 中</span></span><br><span class="line">      <span class="comment">// 此时 Bean 还没有初始化，只是将配置信息提取出来了</span></span><br><span class="line">      <span class="comment">// 注册是将这些配置信息保存到注册中心中(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 子类可以在这步添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 接口的实现类</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>obtainFreshBeanFactory()<strong>：</strong>初始化 BeanFactory，加载并注册 Bean；注意这一步结束后 Bean 还没有初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**refreshBeanFactory()**：关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，就销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 可以有多个，但这里说的是当前 ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下面这两个方法很重要</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据配置文件加载 Bean，然后放到 BeanFactory 中。</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① **createBeanFactory()**：初始化一个DefaultListableBeanFactory</p>
<p>② **customizeBeanFactory(beanFactory)**：配置BeanFactory的两个配置属性：是否允许Bean覆盖、是否允许循环引用</p>
<p>③ <strong>loadBeanDefinitions(beanFactory)：</strong>根据配置文件加载 Bean，然后放到 BeanFactory 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader，用来加载各个 Bean</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**loadBeanDefinitions(beanDefinitionReader)**：通过初始化的 Reader 加载 xml 配置并解析成一个个 BeanDefinition，再将 BeanDefinition 注册到BeanFactory，即使用一个 beanDefinitionMap 来存储 BeanDefinition。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">    <span class="comment">//configResources为null</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//configLocations为之前加载过的配置文件路径数组，不为null</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//所以后续走的是loadBeanDefinitions(configLocations)</span></span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**BeanDefinition()**：BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的 Bean 都会转换成 BeanDefinition 存在于 Spring 的 BeanFactory 中。BeanDefinition 中保存了 Bean 的信息，比如 Bean 指向哪个类、是否是单例、是否懒加载、依赖了哪些 Bean 等。</li>
</ul>
<p>到此为止完成了 Bean 容器的初始化、加载和注册 Bean，但是还没有初始化 Bean，下面是 Bean 的初始化过程</p>
<ul>
<li>**prepareBeanFactory(beanFactory)**：实例化 BeanFactory 后的相关操作，会设置 BeanFactory 的类加载器，初始化所有实现了 BeanFactoryPostProcessor 接口的 Bean 并调用其 postProcessBeanFactory(factory) 方法，并“手动”注册了一些特殊的 Bean，如 environment、systemProperties 等</li>
<li>**finishBeanFactoryInitialization(beanFactory)**：初始化所有 singleton beans (懒加载的除外)</li>
</ul>
<h3 id="Bean的定义覆盖"><a href="#Bean的定义覆盖" class="headerlink" title="Bean的定义覆盖"></a>Bean的定义覆盖</h3><p>BeanFactory 的属性 allowBeanDefinitionOverriding：<strong>是否允许具有相同名称的 Bean 覆盖之前的 Bean</strong>。</p>
<ul>
<li>**设为 true (默认为 true)**：同一个配置文件中不能定义两个相同名称的 Bean，否则会报错；不同配置文件中可以定义两个相同名称的 Bean，只不过后加载的配置文件中的 Bean 会覆盖掉前面加载的配置文件中的 Bean。</li>
<li><strong>设为false</strong>：不允许相同名称的 Bean 加载到 Spring 容器中，否则直接报错。</li>
</ul>
<h3 id="循环依赖问题"><a href="#循环依赖问题" class="headerlink" title="循环依赖问题"></a>循环依赖问题</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19801061/article/details/118991633">https://blog.csdn.net/qq_19801061/article/details/118991633</a></p>
<p>循环依赖就是循环引用，即两个或两个以上的 bean 互相持有对方的引用形成闭环。如A依赖于B，B依赖于C，C又依赖于A。</p>
<p><strong>Spring 可以通过三级缓存机制解决单例模式下的循环依赖问题</strong>。</p>
<p>Spring中循环依赖的三种情况：</p>
<p>① <strong>构造器循环依赖</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassA</span><span class="params">(ClassB classB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classB = classB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassB</span><span class="params">(ClassA classA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classA = classA;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 无法解决构造器循环依赖问题，会报出 BeanCurrentlylnCreationException 异常。</p>
<p>② <strong>单例模式下的属性注入循环依赖</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring 可以通过三级缓存机制解决单例模式下的属性注入循环依赖问题</strong>。</p>
<p>③ <strong>多例模式下的属性注入循环依赖</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassB classB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ClassA classA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 无法解决多例模式下的属性注入循环依赖问题。在多例模式下，一个类存在多个对象，因此 Spring 注入对象时，不知道选择哪个对象进行属性注入。</p>
<h4 id="三级缓存机制"><a href="#三级缓存机制" class="headerlink" title="三级缓存机制"></a><strong>三级缓存机制</strong></h4><ul>
<li><strong>三级缓存对象</strong></li>
</ul>
<p>Spring 有三个缓存，用于存储单例 Bean，<strong>三个缓存彼此互斥，不会同时存储同一个单例 Bean</strong>。调用 getBean() 方法会依次从三个缓存中获取指定单例 Bean， 读取顺序是一级缓存 &#x3D;&gt; 二级缓存 &#x3D;&gt; 三级缓存。三级缓存对象如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 一级缓存：存储经历了完整生命周期的单例 Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 二级缓存：存储提前曝光的已经实例化但未初始化的单例 Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 三级缓存：存储已经实例化但未初始化的单例 Bean</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p><strong>单例对象的初始化过程</strong>：</p>
<ul>
<li><strong>createBeanInstance：实例化</strong>，<strong>调用构造方法实例化对象</strong>。</li>
<li><strong>populateBean：填充属性</strong>，填充单例 bean 的属性。</li>
<li><strong>initializeBean</strong>：<strong>初始化</strong>，调用 spring xml 中 init-method 属性对应的 init() 方法。</li>
</ul>
<h4 id="A-B-A循环注入的过程"><a href="#A-B-A循环注入的过程" class="headerlink" title="A-B-A循环注入的过程"></a><strong>A-B-A循环注入的过程</strong></h4><p>A 先实例化并存储到三级缓存 singletonFactories 中，进行属性注入时发现自己依赖于对象 B，就尝试获取对象 B，但是查询了一二三级缓存都没有发现 B，于是去创建 B 对象。B 实例化后发现自己又依赖于对象 A，于是尝试获取对象 A，在一级缓存 singletonObjects 中发现没有，在二级缓存 earlySingletonObjects 中发现也没有，最后在三级缓存 singletonFactories 中找到了对象 A，就将对象 A 从三级缓存移动到二级缓存，在拿到对象 A 后 B 顺利完成了初始化，完全初始化之后就将自己放入一级缓存 singletonObjects 中。此时对象 A 通过查询一级缓存拿到了对象 B，也顺利完成初始化，然后也进入一级缓存 singletonObjects 中。</p>
<p><strong>加入三级缓存的前提是完成了实例化，即执行了构造方法，这也是 Spring 无法解决构造器循环依赖的原因</strong>。</p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="AOP定义"><a href="#AOP定义" class="headerlink" title="AOP定义"></a>AOP定义</h3><p>AOP(面向切面编程)能够将<strong>与业务无关，却被业务模块共同调用的逻辑（如事务处理、日志管理、权限校验等）封装起来</strong>，从而减少重复代码，降低模块间的耦合度，调高可拓展性和可维护性。</p>
<p>Spring AOP 基于<strong>动态代理</strong>创建代理对象。</p>
<ul>
<li><p>如果要代理的对象<strong>实现了某个接口</strong>，Spring AOP 会使用 <strong>JDK Proxy</strong> 去创建代理对象。</p>
</li>
<li><p>如果要代理的对象<strong>没有实现接口</strong>，就无法使用 JDK Proxy 进行代理，Spring AOP 会使用 <strong>Cglib</strong> 生成被要代理的对象的子类作为代理对象。</p>
<p>如下图所示：</p>
</li>
</ul>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"></p>
<p>AOP 切面编程的专业术语：</p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">目标(Target)</td>
<td align="center">被通知(代理)的对象</td>
</tr>
<tr>
<td align="left">代理(Proxy)</td>
<td align="center">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td align="left">连接点(JoinPoint)</td>
<td align="center">目标对象所属类中定义的所有方法均为连接点</td>
</tr>
<tr>
<td align="left">切入点(Pointcut)</td>
<td align="center">被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td align="left">通知(Advice)</td>
<td align="center">增强的逻辑代码，即拦截到目标对象的连接点后要做的事</td>
</tr>
<tr>
<td align="left">切面(Aspect)</td>
<td align="center">切入点(Pointcut) + 通知(Advice)</td>
</tr>
<tr>
<td align="left">织入(Weaving)</td>
<td align="center">将通知应用到目标对象，进而生成代理对象的过程</td>
</tr>
</tbody></table>
<h3 id="AOP体系与概念"><a href="#AOP体系与概念" class="headerlink" title="AOP体系与概念"></a>AOP体系与概念</h3><h4 id="AOP主要做三件事情"><a href="#AOP主要做三件事情" class="headerlink" title="AOP主要做三件事情"></a><strong>AOP主要做三件事情</strong></h4><p>① 在哪里切入，即非业务操作在哪些业务代码中执行。</p>
<p>② 什么时候切入，在业务代码执行前还是执行后切入。</p>
<p>③ 切入后做什么事，比如权限校验、日志管理等</p>
<h4 id="AOP相关概念和注解"><a href="#AOP相关概念和注解" class="headerlink" title="AOP相关概念和注解"></a><strong>AOP相关概念和注解</strong></h4><p>① Aspect：切面，可以在切面上定义切入点和通知。使用 @Aspect 定义切面类。</p>
<p>② Pointcut：切入点，被切面拦截 &#x2F; 增强的连接点。使用 @Pointcut 定义切入点。切入点分为 <code>execution</code> 方式和 <code>annotation</code> 方式，前者用路径表达式指定要织入切面的类，后者在被指定注解修饰的代码中织入切面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execution()方式:指定路径下的类织入切面</span></span><br><span class="line"><span class="comment">//第一个 * 号的位置：表示返回值类型，* 表示所有类型。</span></span><br><span class="line"><span class="comment">//包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，在本例中指 com.mutest.controller包、子包下所有类的方法</span></span><br><span class="line"><span class="comment">//第二个 * 号的位置：表示类名，* 表示所有类</span></span><br><span class="line"><span class="comment">//*(..)：这个星号表示方法名，* 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.mutest.controller..*.*(..))&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//annotation()方式：被指定注解修饰的代码织入切面</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(org.springframework.web.bind.annotation.PostMapping)&quot;)</span></span><br></pre></td></tr></table></figure>

<p>③ Advice：通知，包括切入时机和增强内容。增强内容就是要做什么事，比如权限校验和日志管理。切入时机就是什么时候切入，分为前置处理、后置处理等。</p>
<ul>
<li>@Before：前置处理，在业务代码执行前执行指定的处理方法。</li>
<li>@After：后置处理，在业务代码执行后执行指定的处理方法。</li>
<li>@Around：环绕处理。</li>
<li>@AfterReturning：和 @After 类似，区别在于 @AfterReturning 可以捕获业务代码执行完成后的返回值，对返回值进行增强处理。</li>
<li>@AfterThrowing：被切入的方法抛出异常时执行指定的处理方法，在该方法中可以做异常处理。</li>
</ul>
<p>④ Joint Point：连接点，目标对象所属类中定义的所有方法均为连接点。</p>
<p>⑤ Weaving：织入，将通知应用到目标对象，进而生成代理对象的过程。</p>
<h3 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h3><p><strong>Spring AOP 是运行时增强，AspectJ 是编译时增强。</strong> Spring AOP 基于动态代理，AspectJ 基于字节码操作。</p>
<p>Spring AOP 集成了 AspectJ ，AspectJ 算是 Java 生态系统中最完整的 AOP 框架。AspectJ 相比 Spring AOP 功能更强大，Spring AOP 相比 AspectJ 更简单，</p>
<p>如果切面比较少，两者的性能差异就不大。切面多的话，最好选择 AspectJ ，会比 Spring AOP 快很多。</p>
<h3 id="AspectJ-定义的通知类型"><a href="#AspectJ-定义的通知类型" class="headerlink" title="AspectJ 定义的通知类型"></a>AspectJ 定义的通知类型</h3><ul>
<li><strong>Before</strong>：在目标对象的方法调用前触发。</li>
<li><strong>After</strong>：在目标对象的方法调用后触发。</li>
<li><strong>AfterReturning</strong>：在目标对象的方法调用完成，返回结果值后触发。</li>
<li><strong>AfterThrowing</strong>：在目标对象的方法抛出异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong>：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，可以直接拿到目标对象和要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后执行指定的处理方法，甚至可以不调用目标对象的方法。</li>
</ul>
<h3 id="多个切面的执行顺序控制"><a href="#多个切面的执行顺序控制" class="headerlink" title="多个切面的执行顺序控制"></a>多个切面的执行顺序控制</h3><ul>
<li><strong>使用 <code>@Order</code> 注解直接定义切面顺序</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现 <code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ul>
<li>定义一个接口及其实现类</li>
<li>创建一个代理类，同样实现该接口</li>
<li>将目标对象注入代理类，然后在代理类的对应方法调用目标类中的对应方法。这样就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DogProxy</span> <span class="variable">dogProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogProxy</span>(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        dogProxy.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个接口 Eatable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//定义一个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现类 Dog 实现接口 Eatable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//实现抽象方法eat</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个代理类同样实现 Eatable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogProxy</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//将代理对象作为代理类的一个属性</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DogProxy</span><span class="params">(Dog dog)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//插入前置代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗在吃饭前要喝水&quot;</span>);</span><br><span class="line">        <span class="comment">//调用代理对象的方法</span></span><br><span class="line">        dog.eat();</span><br><span class="line">        <span class="comment">//插入后置代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗在吃饭后要运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a><strong>JDK动态代理</strong></h4><ul>
<li>定义一个接口及其实现类</li>
<li>定义一个类实现 InvocationHandler 接口并重写 invoke 方法，在 invoke 方法中调用目标类中的方法并自定义一些处理逻辑</li>
<li>通过 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 方法创建代理对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口Eatable</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//定义一个抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现类Dog实现接口Eatable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    <span class="comment">//实现抽象方法eat</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义InvocationHandler接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">//target是被代理类的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法前的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前的操作&quot;</span>);</span><br><span class="line">        <span class="comment">//调用被代理类的原生方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法后的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后的操作&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//被代理对象</span></span><br><span class="line">        <span class="type">Eatable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//MyInvocationHandler</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">Eatable</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Eatable)Proxy.newProxyInstance(ProxyTest.class.getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">        proxyInstance.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a><strong>CGLIB动态代理</strong></h4><ul>
<li>定义一个类</li>
<li>定义一个类实现 MethodInterceptor 接口并重写 intercept 方法，intercept 方法用于拦截增强目标类的方法，和 JDK 动态代理中的 invoke 方法类似</li>
<li>通过 Enhancer 类的 create() 方法创建代理对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个被CGLIB代理的代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个实现了MethodInterceptor的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//方法执行前的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">//调用被代理类的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="comment">//方法执行后的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer类的对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        <span class="comment">//设置拦截方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">//生成代理对象</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl) enhancer.create();</span><br><span class="line">        userService.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cglib-和-JDK-的-Proxy-区别"><a href="#Cglib-和-JDK-的-Proxy-区别" class="headerlink" title="Cglib 和 JDK 的 Proxy 区别"></a><strong>Cglib 和 JDK 的 Proxy 区别</strong></h4><ul>
<li>JDK 动态代理是实现目标对象的接口，Cglib 是继承目标对象。</li>
<li>JDK 和 Cglib 都在运行期生成字节码，JDK 直接写 Class 字节码，Cglib 使用 ASM 框架写 Class 字节码。Cglib 实现更复杂，生成代理类效率较低。</li>
<li>JDK 通过反射机制调用目标方法，Cglib 通过 FastClass 机制调用目标方法，Cglib 执行效率更高。</li>
</ul>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h4><p><img src="https://img-blog.csdnimg.cn/20201011154637538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vY2FzX3dhbmc=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>Spring 不直接管理事务，而是提供多种事务管理器，将事务管理的职责委托给相应的持久化框架</strong>。Spring 通过 PlatformTransactionManager 接口为各个平台如 JDBC、Hibernate 等提供对应的事务管理器，事务管理器的具体实现由各个平台负责。具体的事务管理机制对 Spring 来说是透明的，所以 <strong>Spring 事务管理的一个优点就是能为不同的事务 API 提供统一的编程模型</strong>。</p>
<p>PlatformTransactionManager 接口的内容如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span>()...&#123;  </span><br><span class="line">    <span class="comment">// 由 TransactionDefinition 得到 TransactionStatus 对象</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException; </span><br><span class="line">    <span class="comment">// 提交</span></span><br><span class="line">    Void <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;  </span><br><span class="line">    <span class="comment">// 回滚</span></span><br><span class="line">    Void <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;  </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h4 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h4><p>TransactionDefinition 接口定义了一些基本的事务属性。</p>
<ul>
<li><strong>事务名称</strong>：有多个事务时可用于区分事务。对应注解中的属性 value、transactionManager。</li>
<li><strong>隔离级别</strong>：用于分级加锁处理策略解决数据库容易出现的问题。对应注解中的属性 isolation。</li>
<li><strong>超时时间</strong>：定义事务执行的超时时间，超时后就会回滚，防止事务长期占用资源。对应注解中的属性 timeout。</li>
<li><strong>是否只读</strong>：表示事务是否是只读取数据、不更新数据，可以帮助数据库引擎优化事务。对应注解中的属性 readOnly。</li>
<li><strong>传播机制</strong>：定义事务的传播特性，共有7种类型。对应注解中的属性 propagation。</li>
<li><strong>回滚机制</strong>：定义事务遇到异常时的回滚策略。对应注解中的属性 rollbackFor、noRollbackFor、rollbackForClassName、noRollbackForClassName。</li>
</ul>
<h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p><code>TransactionStatus</code> 接口用来记录事务的状态，该接口定义了一组方法用来获取或判断事务的状态。其接口内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事务传播机制"><a href="#事务传播机制" class="headerlink" title="事务传播机制"></a>事务传播机制</h4><p><strong>事务传播机制用于解决多个事务方法相互调用的问题</strong>。当一个事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
<ul>
<li><strong>REQUIRED(默认)：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。</li>
<li><strong>REQUIRES_NEW：</strong>创建一个新事务，如果当前存在事务，就把当前事务挂起。即不管外部方法是否开启事务，都会开启自己的事务，且事务间相互独立，互不干扰。</li>
<li><strong>NESTED：</strong>如果当前存在事务，则创建一个新事务作为当前事务的嵌套事务。如果当前没有事务，则创建一个新事务。</li>
<li><strong>MANDATORY：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li><strong>SUPPORTS：</strong>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式运行。</li>
<li><strong>NOT_SUPPORTED：</strong>以非事务方式运行，如果当前存在事务，则把当前事务挂起。执行完后，恢复挂起的事务。</li>
<li><strong>NEVER：</strong>以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>通过 <code>TransactionTemplate</code> 或 <code>TransactionManager</code> 手动管理事务，实现更细粒度的事务控制，是典型的模板模式。</p>
<p> <code>TransactionTemplate</code> 的继承结构如下：</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/Users/SuSu\AppData\Roaming\Typora\typora-user-images\image-20240305204939995.png" alt="image-20240305204939995"></p>
<p>使用 TransactionTemplate 执行事务的过程如下：</p>
<p>① 创建 TransactionTemplate 对象（如果自定义了 TransactionTemplate 的 bean 则使用自定义的 bean，否则使用自动装配的默认 bean）</p>
<p>② 新建事务方法，并调用 excute() 方法执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用户并创建账户余额(手动事务，不带结果)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserBalanceAndUserWithinTT</span><span class="params">(String name, BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="comment">//实现一个没有返回值的事务回调</span></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;[addUserBalanceAndUser] begin!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//1.新增用户</span></span><br><span class="line">                    userService.addUser(name);</span><br><span class="line">                    <span class="comment">//2.新增用户余额</span></span><br><span class="line">                    <span class="type">UserBalance</span> <span class="variable">userBalance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBalance</span>();</span><br><span class="line">                    userBalance.setName(name);</span><br><span class="line">                    userBalance.setBalance(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1000</span>));</span><br><span class="line">                    userBalanceRepository.insert(userBalance);</span><br><span class="line">                    log.info(<span class="string">&quot;[addUserBalanceAndUser] end!!!&quot;</span>);</span><br><span class="line">                    <span class="comment">//注意：这里catch住异常后，设置setRollbackOnly，否则事务不会滚。当然如果不需要自行处理异常，就不要catch了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 异常回滚</span></span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    log.error(<span class="string">&quot;异常回滚!,e=&#123;&#125;&quot;</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><p>execute() 方法是 TransactionTemplate 执行事务的核心方法，主要步骤如下：</p>
<ul>
<li>getTransaction() 获取事务。</li>
<li>doInTransaction() 执行业务逻辑，即用户的业务代码。如果没有返回值，就是 doInTransactionWithoutResult()。</li>
<li>如果事务执行成功，则调用 commit() 方法提交事务，否则调用 rollback() 回滚事务。</li>
</ul>
<h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p><strong>定义</strong>：基于 <strong>Spring AOP 实现</strong>，对目标方法前后进行拦截，将事务处理的功能织入到目标方法中。在目标方法开始前创建或者加入一个事务，在目标方法结束后根据执行情况提交或回滚事务。<strong>使用 @Transactional 注解，并定义传播机制 + 回滚策略来实现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 2      * 创建用户并创建账户余额</span></span><br><span class="line"><span class="comment"> 3      *</span></span><br><span class="line"><span class="comment"> 4      * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> 5      * <span class="doctag">@param</span> balance</span></span><br><span class="line"><span class="comment"> 6      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> 7      */</span></span><br><span class="line"> <span class="number">8</span>     <span class="meta">@Transactional(propagation= Propagation.REQUIRED, rollbackFor = Exception.class)</span></span><br><span class="line"> <span class="number">9</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUserBalanceAndUser</span><span class="params">(String name, BigDecimal balance)</span> &#123;</span><br><span class="line"><span class="number">11</span>         log.info(<span class="string">&quot;[addUserBalanceAndUser] begin!!!&quot;</span>);</span><br><span class="line"><span class="number">12</span>         <span class="comment">//1.新增用户</span></span><br><span class="line"><span class="number">13</span>         userService.addUser(name);</span><br><span class="line"><span class="number">14</span>         <span class="comment">//2.新增用户余额</span></span><br><span class="line"><span class="number">15</span>         <span class="type">UserBalance</span> <span class="variable">userBalance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserBalance</span>();</span><br><span class="line"><span class="number">16</span>         userBalance.setName(name);</span><br><span class="line"><span class="number">17</span>         userBalance.setBalance(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1000</span>));</span><br><span class="line"><span class="number">18</span>         <span class="built_in">this</span>.addUserBalance(userBalance);</span><br><span class="line"><span class="number">19</span>         log.info(<span class="string">&quot;[addUserBalanceAndUser] end!!!&quot;</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<p>① <code>@Transactional</code> 的作用范围</p>
<ol>
<li>方法：推荐在方法上使用，不过只能应用到 public 方法上，否则不生效。</li>
<li>类：如果在类上使用，表明该注解对该类中所有的 public 方法都生效。</li>
<li>接口：不推荐在接口上使用</li>
</ol>
<p>② <strong><code>@Transactional</code> 的工作机制是基于 AOP 实现，AOP 又基于动态代理实现。如果目标对象实现了接口，会采用 JDK 动态代理，如果目标对象没有实现接口，会使用 CGLIB 动态代理。</strong><code>createAopProxy()</code> 方法决定了是使用 JDK 还是 Cglib 来做动态代理。</p>
<p>③ <strong>若同一类中没有 <code>@Transactional</code> 注解的方法调用了有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</strong></p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="Spring-Boot优点"><a href="#Spring-Boot优点" class="headerlink" title="Spring Boot优点"></a>Spring Boot优点</h3><ul>
<li><p>开发基于 Spring 的应用程序很容易。</p>
</li>
<li><p>Spring Boot 项目所需的开发或工程时间明显减少，通常会提高整体生产力。</p>
</li>
<li><p>Spring Boot 不需要编写大量样板代码、XML 配置和注释。</p>
</li>
<li><p>Spring Boot 应用程序可以很容易地与 Spring 生态系统集成，如 Spring  JDBC、Spring ORM、Spring Data、Spring Security 等。</p>
</li>
<li><p>Spring Boot 遵循“固执己见的默认配置”，以减少开发工作(默认配置可以修改)。</p>
</li>
<li><p>Spring Boot 应用程序提供嵌入式 HTTP 服务器，如 Tomcat 和 Jetty，可以轻松地开发和测试 web 应用程序。</p>
</li>
<li><p>Spring Boot 提供命令行接口(CLI)工具，用于开发和测试 Spring Boot 应用程序，如 Java或 Groovy。</p>
</li>
<li><p>Spring Boot 提供了多种插件，可以使用内置工具(如 Maven 和 Gradle)开发和测试 Spring Boot 应用程序。</p>
</li>
</ul>
<h3 id="Spring-Boot-Starters"><a href="#Spring-Boot-Starters" class="headerlink" title="Spring Boot Starters"></a>Spring Boot Starters</h3><p>Spring Boot Starters 是一系列依赖关系的集合，可以简化项目依赖间的关系。<br>在没有 Spring Boot Starters 之前，开发 Web 应用程序时需要手动一个一个添加 Spring MVC、Tomcat 和 Jackson 这样的库。有了Spring Boot Starters 后只需添加 <strong>spring-boot-starter-web</strong> 一个依赖就可以了，这个依赖中包含了开发 Web 应用程序需要的所有依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内嵌-Servlet-容器"><a href="#内嵌-Servlet-容器" class="headerlink" title="内嵌 Servlet 容器"></a>内嵌 Servlet 容器</h3><p>Spring Boot 支持以下嵌入式 Servlet 容器：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/image-20220706144429941.png" alt="image-20220706144429941" style="zoom:67%;"> 

<h4 id="修改嵌入式容器"><a href="#修改嵌入式容器" class="headerlink" title="修改嵌入式容器"></a>修改嵌入式容器</h4><p>Spring Boot (spring-boot-starter-web) 使用 Tomcat 作为默认的嵌入式 Servlet 容器，如果想使用 Jetty 的话只需修改 pom.xml (Maven) 或 build.gradle (Gradle) 就可以了。</p>
<p><strong>Maven：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--从Web启动器依赖中排除Tomcat--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;exclusions&gt;</span><br><span class="line">		&lt;exclusion&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">		&lt;/exclusion&gt;</span><br><span class="line">	&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--添加Jetty依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Gradle：</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>) &#123;</span><br><span class="line">     exclude <span class="attr">group:</span> <span class="string">&#x27;org.springframework.boot&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;spring-boot-starter-tomcat&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">compile(<span class="string">&quot;org.springframework.boot:spring-boot-starter-jetty&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>从上面可以看出使用 Gradle 更加简洁明了，但是国内目前还是 Maven 使用的多一点，我个人觉得 Gradle 在很多方面都要好很多。</p>
<h3 id="常用基本注解"><a href="#常用基本注解" class="headerlink" title="常用基本注解"></a>常用基本注解</h3><h4 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h4><p>可以把 <code>@SpringBootApplication</code> 看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p>
<p>三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制。</li>
<li><code>@ComponentScan</code>：扫描被 <code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code> 注解注释的 bean，注解默认会扫描该类所在包下所有的类。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h4 id="ComponentScan、-Import"><a href="#ComponentScan、-Import" class="headerlink" title="@ComponentScan、@Import"></a>@ComponentScan、@Import</h4><p>@ComponentScan：扫描包</p>
<p>@Import：使用类的<strong>无参构造函数</strong>创建一个实例注册到 IOC 容器中</p>
<p>【注意】@Import 所创建的实例在 IOC 容器中<strong>默认的 id 名为类的全限定名</strong>，如 User 类就是：com.atguigu.bean.User</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  在容器中自动创建出这两个类型的组件、默认组件的名字就是全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h4><p>@ConditionalOnBean 和 @ConditionalOnMissBean、@Conditional</p>
<p>简单理解就是<code>@ConditionalOnBean</code>是依赖，<code>@ConditionalOnMissBean</code>是排斥，<code>@Conditional</code> 是条件。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43993065/article/details/106740140">@ConditionalOnMissingBean注解使用案例</a></p>
<h3 id="RESTful-Web-服务常用的注解"><a href="#RESTful-Web-服务常用的注解" class="headerlink" title="RESTful Web 服务常用的注解"></a>RESTful Web 服务常用的注解</h3><h4 id="Spring-Bean-相关"><a href="#Spring-Bean-相关" class="headerlink" title="Spring Bean 相关"></a>Spring Bean 相关</h4><ul>
<li><p><code>@Autowired</code>：自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。比如：Service 类注入到 Controller 类中。</p>
</li>
<li><p><code>@RestController</code>：<code>@RestController</code> 注解是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的合集，表示这是个控制器 bean，并且是将函数的返回值直接填入 HTTP 响应体中，是 REST 风格的控制器。</p>
</li>
<li><p><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用 <code>@Component</code> 注解标注。</p>
</li>
<li><p><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
<li><p><code>@Service</code>: 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
</ul>
<h4 id="处理常见的HTTP请求类型"><a href="#处理常见的HTTP请求类型" class="headerlink" title="处理常见的HTTP请求类型"></a>处理常见的HTTP请求类型</h4><p><strong>5 种常见的请求类型：</strong></p>
<ul>
<li><p><strong>GET</strong>：从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</p>
<p><code>@GetMapping(&quot;users&quot;)</code> 等价于 <code>@RequestMapping(value=&quot;/users&quot;, method=RequestMethod.GET)</code></p>
</li>
<li><p><strong>POST</strong>：在服务器上创建新资源。举个例子：<code>POST /users</code>（创建学生）</p>
<p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p>
</li>
<li><p><strong>PUT</strong>：更新服务器上的资源。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</p>
<p><code>@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.PUT)</code></p>
</li>
<li><p><strong>DELETE</strong>：从服务器删除特定资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</p>
<p><code>@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.DELETE)</code></p>
</li>
<li><p><strong>PATCH</strong>：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</p>
</li>
<li><p><code>@PatchMapping(&quot;/users&quot;)</code></p>
</li>
</ul>
<h4 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h4><p><strong>1.<code>@PathVariable</code> 和 <code>@RequestParam</code></strong></p>
<p><code>@PathVariable</code> 用于获取路径参数，<code>@RequestParam</code> 用于获取查询参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title function_">getKlassRelatedTeachers</span><span class="params">(</span></span><br><span class="line"><span class="params">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span><br><span class="line"><span class="params">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们请求的 url 是：<code>/klasses/123456/teachers?type=web</code></p>
<p>那么我们服务获取到的数据就是：<code>klassId = 123456, type = web</code>。</p>
<p><strong>2.<code>@RequestBody</code></strong></p>
<p>用于读取 Request 请求 body 中的 <strong>json</strong> 数据并绑定到 Java 对象上去。系统会使用 <code>HttpMessageConverter</code> 或自定义的 <code>HttpMessageConverter</code> 将请求 body 中的 json 字符串转换为 java 对象。</p>
<p>需要注意的是：**一个请求方法只可以有一个 <code>@RequestBody</code>，但是可以有多个 <code>@RequestParam</code> 和 <code>@PathVariable</code>**。</p>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>通过 <code>@EnableAutoConfiguration</code> 注解在 META-INF&#x2F;spring.factories 文件中找到所有自动配置类，然后将这些自动配置类加载到 spring 容器中。</p>
<ul>
<li><code>@EnableAutoConfiguration</code> 注解使用 <code>@Import</code> 注解导入 <code>AutoConfigurationImportSelector</code> 类。</li>
<li><code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code> 接口中的 <code>selectImports</code> 方法，该方法用于<strong>获取所有需要被加载到 IoC 容器中的类的全限定名</strong>。</li>
<li><code>selectImports</code> 方法中的 <code>getAutoConfigurationEntry()</code> 方法负责加载自动配置类。</li>
</ul>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:67%;">

<p>结合 <code>getAutoConfigurationEntry()</code> 的源码来详细分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AutoConfigurationEntry</span> <span class="variable">EMPTY_ENTRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>();</span><br><span class="line"></span><br><span class="line">AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.用于获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName。</span></span><br><span class="line">            <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.获取需要自动装配的所有配置类，读取 META-INF/spring.factories</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="built_in">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</li>
<li>获取 <code>EnableAutoConfiguration</code> 注解中的 <code>exclude</code> 和 <code>excludeName</code>。</li>
<li>读取 <code>META-INF/spring.factories</code> 文件，获取所有需要被自动装配的自动配置类。<code>getcandidateconfigurations</code> 方法会将所有<strong>自动配置类的信息以 List 形式返回</strong>。这些信息会被 Spring 容器当做 bean 来管理。</li>
<li>经历了一遍筛选，如果 <code>@ConditionalOnXXX</code> 中的所有条件都满足，类就会生效。</li>
</ol>
<h3 id="启动机制"><a href="#启动机制" class="headerlink" title="启动机制"></a>启动机制</h3><p>spring boot 启动流程分析 - 掘金 (juejin.cn)](<a target="_blank" rel="noopener" href="https://juejin.cn/post/7035910505810100255">https://juejin.cn/post/7035910505810100255</a>)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46047193/article/details/123557570?ops_request_misc=%7B%22request_id%22:%22165993113716782184616144%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=165993113716782184616144&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123557570-null-null.142%5Ev39%5Epc_rank_34,185%5Ev2%5Etag_show&utm_term=springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E9%9D%A2%E8%AF%95&spm=1018.2226.3001.4187"> Spring Boot面试必问：启动流程</a></p>
<ol>
<li>首先从 main 中找到 run() 方法，在执行 run() 方法之前先 new 一个 <code>SpringApplication</code> 对象。</li>
<li>进入 run() 方法，创建应用监听器 <code>SpringApplicationRunListeners</code> 开始监听。</li>
<li>加载 SpringBoot 配置环境 <code>ConfigurableEnvironment</code>，然后把配置环境加入监听对象中。</li>
<li>加载应用上下文 <code>ConfigurableApplicationContext</code>，作为 run() 方法的返回对象。</li>
<li>最后创建 Spring 容器，调用 <code>refreshContext(context)</code> 方法，实现 starter 自动配置和 bean 实例化等工作。</li>
</ol>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220712153744731.png" alt="SpringApplication的实例化"></p>
<h4 id="SpringApplication的实例化"><a href="#SpringApplication的实例化" class="headerlink" title="SpringApplication的实例化"></a>SpringApplication的实例化</h4><p>SpringApplication 实例化的过程中，主要做了以下4件事：</p>
<ul>
<li><h5 id="推断应用类型是否是Web环境"><a href="#推断应用类型是否是Web环境" class="headerlink" title="推断应用类型是否是Web环境"></a>推断应用类型是否是Web环境</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br></pre></td></tr></table></figure>

<p>通过判断是否存在 Servlet 和 ConfigurableWebApplicationContext 类来判断是否是Web环境，如果该应用是一个web应用，会启动Springboot内嵌的web服务器</p>
</li>
<li><p><strong>设置初始化器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br></pre></td></tr></table></figure>

<p>该方法会加载所有配置的 ApplicationContextInitializer 并进行实例化，加载过程为从  jar 包的类路径下的 META-INF&#x2F;spring.factories 中读取配置文件中 Key 为 org.springframework.context.ApplicationContextInitializer 的 value 值，将其放入到列表中并去重，然后根据这些 value 值通过反射来实例化对应的类，这些类就是一个个的初始化器，他们都是 ApplicationContextInitializer 的实现类。ApplicationContextInitializer 是一个回调接口，它会在 ConfigurableApplicationContext 容器 refresh() 方法调用之前被调用，做一些容器的初始化工作。</p>
</li>
<li><p><strong>设置监听器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure>

<p>该方法会加载所有配置的 ApplicationListener并进行实例化，加载过程为从jar包的类路径下的META-INF&#x2F;spring.factories中读取配置文件中Key为org.springframework.context.ApplicationListener的 value值，将其放入到列表中并去重，然后根据这些value值通过反射来实例化对应的类，这些类就是一个个的监听器，他们都是ApplicationListener的实现类。</p>
</li>
<li><p><strong>推断应用入口类(Main)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br></pre></td></tr></table></figure>

<p>通过构造一个运行时异常，通过异常栈中方法名为main的栈帧来得到入口类的名字。</p>
</li>
</ul>
<h4 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h4><ul>
<li><p><strong>获取RunListeners</strong></p>
<p>加载所有配置的 SpringApplicationRunListener 并进行实例化，加载过程为从 jar 包的类路径下的 META-INF&#x2F;spring.factories 中读取配置文件中 Key 为 org.springframework.context.SpringApplicationRunListener 的 value 值，将其放入到列表中并去重，然后根据这些 value 值通过反射来实例化对应的类，这些类就是一个个的运行时监听器，他们都是 SpringApplicationRunListener 的实现类。</p>
</li>
<li><p><strong>准备Environment环境</strong></p>
<p>根据SpringApplicationRunListeners以及参数来准备环境，主要用来配置Property Sources和Profiles，为应用程序环境配置哪些配置文件处于active（活动）状态。</p>
</li>
<li><p><strong>创建Spring Context</strong></p>
<p>根据应用程序的类型来创建web应用的Spring上下文环境和非web应用的Spring上下文环境</p>
</li>
<li><p><strong>Spring Context前置处理</strong></p>
<p>主要用来配置Bean生成器以及资源加载器，然后调用SpringApplication实例创建时设置的初始化器，依次对它们进行遍历，并调用initialize方法。</p>
</li>
<li><p><strong>Spring Context刷新</strong></p>
<p>首先调用父类的refresh方法完成容器刷新的基础操作，然后注册一个关闭容器时的钩子函数，用来完成一些容器销毁时的清理工作</p>
</li>
<li><p><strong>Spring Context后置处理</strong></p>
<p>在容器完成刷新后，依次调用注册的Runners，Runners可以是两个接口的实现类：org.springframework.boot.ApplicationRunner、org.springframework.boot.CommandLineRunner。CommandLineRunner、ApplicationRunner 接口是在容器启动成功后的最后一步回调</p>
</li>
</ul>
<h3 id="配置文件读取"><a href="#配置文件读取" class="headerlink" title="配置文件读取"></a>配置文件读取</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486181&idx=2&sn=10db0ae64ef501f96a5b0dbc4bd78786&chksm=cea2452ef9d5cc384678e456427328600971180a77e40c13936b19369672ca3e342c26e92b50&token=816772476&lang=zh_CN#rd">《10 分钟搞定 SpringBoot 如何优雅读取配置文件？》open in new window</a> </p>
<h4 id="通过-value-读取简单的配置信息"><a href="#通过-value-读取简单的配置信息" class="headerlink" title="通过 @value 读取简单的配置信息"></a>通过 <code>@value</code> 读取简单的配置信息</h4><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取简单的配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure>

<h4 id="通过-ConfigurationProperties-读取并与-bean-绑定"><a href="#通过-ConfigurationProperties-读取并与-bean-绑定" class="headerlink" title="通过 @ConfigurationProperties 读取并与 bean 绑定"></a>通过 <code>@ConfigurationProperties</code> 读取并与 bean 绑定</h4><blockquote>
<p>LibraryProperties 类上加了 @Component 注解，可以像使用普通 bean 一样将其注入到类中使用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LibraryProperties</span> </span><br></pre></td></tr></table></figure>

<h4 id="通过-ConfigurationProperties-读取并校验"><a href="#通过-ConfigurationProperties-读取并校验" class="headerlink" title="通过 @ConfigurationProperties 读取并校验"></a>通过 <code>@ConfigurationProperties</code> 读取并校验</h4><p>我们先将application.yml修改为如下内容，明显看出这不是一个正确的email格式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Guide哥</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">koushuangbwcx@</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ProfileProperties</code>类没有加<code>@Component</code>注解。我们在我们要使用<code>ProfileProperties</code>的地方使用<code>@EnableConfigurationProperties </code>注册我们的配置<code>bean</code>:</p>
</blockquote>
<p>具体使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;my-profile&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfileProperties</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ProfileProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadConfigPropertiesApplication</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-PropertySource-读取指定-properties-文件"><a href="#通过-PropertySource-读取指定-properties-文件" class="headerlink" title="通过 @PropertySource 读取指定 properties 文件"></a>通过 <code>@PropertySource</code> 读取指定 properties 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSite</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebSite webSite;</span><br><span class="line"></span><br><span class="line">System.out.println(webSite.getUrl());<span class="comment">//https://javaguide.cn/</span></span><br></pre></td></tr></table></figure>

<h3 id="请求参数检验"><a href="#请求参数检验" class="headerlink" title="请求参数检验"></a>请求参数检验</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485783&idx=1&sn=a407f3b75efa17c643407daa7fb2acd6&chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&token=292197051&lang=zh_CN#rd">如何在 Spring&#x2F;Spring Boot 中做参数校验？你需要了解的都在这里！ (qq.com)</a></p>
<h4 id="校验注解"><a href="#校验注解" class="headerlink" title="校验注解"></a>校验注解</h4><p><strong>JSR提供的校验注解</strong>:</p>
<ul>
<li><code>@Null</code>  被注释的元素必须为 null</li>
<li><code>@NotNull</code>   被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code>   被注释的元素必须为 true</li>
<li><code>@AssertFalse</code>   被注释的元素必须为 false</li>
<li><code>@Min(value)</code>   被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value)</code>   被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code>   被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code>   被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=)</code>   被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits(integer, fraction)</code>  被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past</code>   被注释的元素必须是过去的日期</li>
<li><code>@Future</code>   被注释的元素必须是将来的日期</li>
<li><code>@Pattern(regex= ,flag= )</code>   被注释的元素必须符合指定的正则表达式</li>
</ul>
<p><strong>Hibernate Validator提供的校验注解</strong>： </p>
<ul>
<li><code>@NotBlank(message = )</code> 验证字符串非null，且长度必须大于0</li>
<li><code>@Email</code> 被注释的元素必须是电子邮箱地址</li>
<li><code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内</li>
<li><code>@NotEmpty</code> 被注释的字符串的必须非空</li>
<li><code>@Range(min=,max=,message=)</code> 被注释的元素必须在合适的范围内</li>
</ul>
<h4 id="验证请求体-RequestBody"><a href="#验证请求体-RequestBody" class="headerlink" title="验证请求体(RequestBody)"></a>验证请求体(RequestBody)</h4><p>在需要验证的参数上加上 <code>@Valid</code> 注解，如果验证失败会抛出 <code>MethodArgumentNotValidException</code>。默认情况下，Spring 会将此异常转换为 HTTP Status 400。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line">publicclass PersonController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title function_">getPerson</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证请求参数-Path-Variables-和-Request-Parameters"><a href="#验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="验证请求参数(Path Variables 和 Request Parameters)"></a>验证请求参数(Path Variables 和 Request Parameters)</h4><p><strong>一定要在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line">publicclass PersonController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title function_">getPersonByID</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">getPersonByName</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestParam(&quot;name&quot;)</span> <span class="meta">@Size(max = 6,message = &quot;超过 name 的范围了&quot;)</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><p>可以使用 <code>@ControllerAdvice</code> 和 @<code>ExceptionHandler</code> 处理全局异常。</p>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/springboot-guide/#/./docs/advanced/springboot-handle-exception-plus">Document (gitee.io)</a></p>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>我们使用 <code>@scheduled</code> 注解就能很方便地创建一个定时任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTasks</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ScheduledTasks.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fixedRate：固定速率执行。每5秒执行一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reportCurrentTimeWithFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Current Thread : &#123;&#125;&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        log.info(<span class="string">&quot;Fixed Rate Task : The time is now &#123;&#125;&quot;</span>, dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯依靠 <code>@scheduled</code> 注解还不行，我们还需要在<code>SpringBoot </code>中我们只需要在启动类上加上 <code>@Enablescheduling</code> 注解，这样才可以启动定时任务。<code>@Enablescheduling </code>注解的作用是发现注解 <code>@scheduled</code> 的任务并在后台执行该任务。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL-基础"><a href="#MySQL-基础" class="headerlink" title="MySQL 基础"></a>MySQL 基础</h2><h3 id="MySQL-介绍"><a href="#MySQL-介绍" class="headerlink" title="MySQL 介绍"></a>MySQL 介绍</h3><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>
<h3 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1784274">非关系型数据库（NOSQL）和关系型数据库（SQL）区别详解</a></p>
<h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a><strong>关系型数据库</strong></h4><p>关系型数据库是<strong>以关系模型（二维表格模型）为基础的数据库</strong>。关系模型表明了数据库中存储的数据之间的联系（一对一、一对多、多对多）。关系型数据库中，数据都被存放在各种表中，表中的每一行就存放着一条数据。</p>
<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持<strong>事务</strong>的四大特性 (ACID)。</p>
<p>最典型的数据结构是<strong>表</strong>，由二维表及其之间的联系所组成的一个数据组织</p>
<p>优点：</p>
<p>1、 易于维护：都是使用表结构，格式一致</p>
<p>2、 使用方便：SQL 语言通用，可用于复杂查询</p>
<p>3、 复杂操作：<strong>支持 SQL</strong>，可用于一个表以及多个表之间非常复杂的查询。</p>
<p>缺点：</p>
<p>1、 读写性能比较差，尤其是海量数据的高效率读写；</p>
<p>2、 固定的表结构，灵活度稍差</p>
<p>3、 高并发读写需求，传统关系型数据库来说，硬盘I&#x2F;O是一个很大的瓶颈。</p>
<p><strong>常见关系型数据库管理系统(ORDBMS)：</strong></p>
<p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite）。</p>
<h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a><strong>非关系型数据库</strong></h4><p>非关系型数据库又称为 NoSQL（Not Only SQL)，意为不仅仅是 SQL，常用于存储非结构化的数据，数据通常以对象的形式存储在数据库中。</p>
<p><strong>优点：</strong></p>
<ol>
<li>格式灵活：存储数据的格式可以是 key - value 形式、文档形式、图片形式等，而关系型数据库只支持基础类型。</li>
<li>速度快：NoSQL 可以使用硬盘或者 RAM，而关系型数据库只能使用硬盘；</li>
<li>成本低： 海量数据的维护和处理非常轻松。 </li>
<li>高扩展：非关系型数据库具有扩展简单、高并发、高稳定性。</li>
<li>可以实现数据的分布式处理。</li>
</ol>
<p><strong>缺点：</strong></p>
<p>1、 不提供 SQL 支持，学习和使用成本高</p>
<p>2、 <strong>无事务处理</strong>；</p>
<p>3、 数据结构相对复杂，复杂查询方面稍欠；</p>
<p><strong>常见的NOSQL数据库：</strong></p>
<ol>
<li>键值数据库：Redis、Memcached、Riak </li>
<li>列族数据库：Bigtable、HBase、Cassandra </li>
<li>文档数据库：MongoDB、CouchDB、MarkLogic </li>
<li>图形数据库：Neo4j、InfoGrid</li>
</ol>
<h3 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h3><p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li><strong>连接器</strong>：建立连接。</li>
<li><strong>查询缓存</strong>：查询语句如果命中查询缓存就直接返回，否则继续往下执行。<strong>MySQL 8.0 已删除该模块</strong>；</li>
<li><strong>解析器</strong>：解析 SQL，对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li><strong>执行 SQL</strong>：<ul>
<li><strong>预处理</strong>阶段：检查表或字段是否存在，将 <code>select *</code> 中的 <code>*</code>  扩展为表中所有列。</li>
<li><strong>优化</strong>阶段：选择查询成本最小的执行计划。</li>
<li><strong>执行</strong>阶段：根据执行计划执行 SQL 查询语句，从<strong>存储引擎</strong>中读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cmysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<p>MySQL 架构分为两层：<strong>Server 层和存储引擎层</strong>。</p>
<ul>
<li><strong>Server 层负责建立连接、解析 SQL 和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用 Server 层，最常用的存储引擎是 InnoDB。我们常说的索引数据结构是由存储引擎层实现的，不同存储引擎支持的索引类型不同，InnoDB 支持的索引类型是 B+ 树 ，也就是说在数据表中创建的主键索引和二级索引使用的都是 <strong>B+ 树</strong>索引。</li>
</ul>
<h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><p>MySQL 支持多种存储引擎，可以通过 <code>show engines</code> 命令查看 MySQL 支持的存储引擎。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎"></p>
<p>从上图可以看出， MySQL 的默认存储引擎是 InnoDB，且只有 InnoDB 是事务性存储引擎，也就是说<strong>只有 InnoDB 支持事务</strong>。</p>
<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<p>你也可以通过 <code>show variables like &#39;%storage_engine%&#39;</code> 命令直接查看 MySQL 当前默认的存储引擎。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220510105837786.png" alt="查看 MySQL 当前默认的存储引擎"></p>
<h4 id="存储引擎架构"><a href="#存储引擎架构" class="headerlink" title="存储引擎架构"></a>存储引擎架构</h4><p>MySQL 存储引擎采用插件式架构，支持多种存储引擎，甚至可以为不同的表设置不同的存储引擎。<strong>存储引擎是基于表的，而不是数据库。</strong></p>
<h4 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h4><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有<strong>表级锁</strong>，而 InnoDB 支持<strong>行级锁</strong>和表级锁，默认行级锁。</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义的四个隔离级别，具有提交事务和回滚事务的能力。</p>
<p>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别可以解决幻读问题（基于 MVCC 和 Next-Key Lock）。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>外键对于<strong>维护数据一致性</strong>非常有帮助，但是对性能有一定的损耗。因此不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库异常崩溃后，重新启动时会保证数据库恢复到崩溃前的状态，恢复的过程依赖于 <code>redo log</code> 。</p>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>Multi-Version Concurrency Control 多版本并发控制</p>
<blockquote>
<p>这个对比有点废话，MyISAM 连行级锁都不支持。MVCC 可以看作行级锁的升级，可以有效减少加锁操作，提高性能。</p>
</blockquote>
<p><strong>6.索引实现不一样。</strong></p>
<p>MyISAM 使用 B Tree 作为索引结构，InnoDB 使用 B+ Tree 作为索引结构。</p>
<p><strong>InnoDB 引擎的数据文件就是索引文件</strong>，而 <strong>MyISAM 引擎的索引文件和数据文件是分离的</strong>。</p>
<h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shangping/p/11088503.html">数据库—–三大范式</a></p>
<ul>
<li>第一范式：<strong>每列都不可以再拆分</strong>。</li>
</ul>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/Users/SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306205358725.png" alt="image-20240306205358725"></p>
<ul>
<li>第二范式：<strong>非主键列完全依赖于主键</strong>，即<strong>主键可以确定所有非主键的值。</strong>也就是说如果一张表中包含了多个不同实体的属性，那么必须要拆分成多张表。</li>
</ul>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/Users/SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306205446367.png" alt="image-20240306205446367"></p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/Users/SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306205524003.png" alt="image-20240306205524003"></p>
<ul>
<li>第三范式：<strong>非主键列只依赖于主键，不依赖于其他非主键</strong>。也就是说如果已经分好了多张表的话，一张表中只能有另一张表的主键，不能有其他信息。</li>
</ul>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/Users/SuSu\AppData\Roaming\Typora\typora-user-images\image-20240306210237085.png" alt="image-20240306210237085"></p>
<p>注意事项：</p>
<p>1.第二范式与第三范式的本质区别：在于有没有分出两张表。</p>
<p>2.必须先满足第一范式才能满足第二范式，必须同时满足第一、第二范式才能满足第三范式。</p>
<h2 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h2><h3 id="inner-join-left-join-right-join"><a href="#inner-join-left-join-right-join" class="headerlink" title="inner join  &#x2F; left join &#x2F; right join"></a>inner join  &#x2F; left join &#x2F; right join</h3><ul>
<li>left join (左联接) 返回左表中的所有记录和右表中联结字段相等的记录</li>
<li>right join (右联接) 返回右表中的所有记录和左表中联结字段相等的记录</li>
<li>inner join (等值连接) 返回两个表中联结字段相等的行</li>
</ul>
<p>inner join 取<strong>交集</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.yisu.com/zixun/624524.html">mysql如何求交集</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询交集</span><br><span class="line">SELECT a.oname,a.odesc FROM object_a a INNER JOIN object_b b ON a.oname=b.oname AND a.odesc=b.odesc</span><br><span class="line"># 等价于</span><br><span class="line">SELECT a.oname,a.odesc FROM object_a a INNER JOIN object_b b USING(oname,odesc)</span><br></pre></td></tr></table></figure>

<h3 id="using-用法-（见上面）"><a href="#using-用法-（见上面）" class="headerlink" title="using 用法 （见上面）"></a>using 用法 （见上面）</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36925013/article/details/124622701?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-124622701-blog-79622414.pc_relevant_multi_platform_featuressortv2removedup&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5-124622701-blog-79622414.pc_relevant_multi_platform_featuressortv2removedup&utm_relevant_index=10">(Mysql 中用using() 简化连接join</a></p>
<ul>
<li>连接查询时如果是同名字段作为连接条件，using可以代替on出现（比on更好）</li>
<li>using 是针对<strong>同名字段</strong>（<strong>using(id)等价于on A.id&#x3D;B.id</strong>）</li>
<li>using 关键字使用后会自动合并对应字段为一个</li>
<li>using 可以同时使用多个字段作为条件</li>
</ul>
<h3 id="Union-和-Union-All-的区别"><a href="#Union-和-Union-All-的区别" class="headerlink" title="Union 和 Union All 的区别"></a>Union 和 Union All 的区别</h3><p>都是对两个结果集进行<strong>并集</strong>操作</p>
<p><strong>Union：不包括重复行，同时进行默认规则的排序；</strong></p>
<p><strong>Union All：包括重复行，不进行排序；</strong></p>
<h3 id="on和where的区别"><a href="#on和where的区别" class="headerlink" title="on和where的区别"></a>on和where的区别</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tayngh/article/details/99684035">MYSQL on和where的区别</a></p>
<p>外连接时：</p>
<ul>
<li><p>on条件是在<strong>生成临时表时使用的条件</strong>，它不管on中的条件是否为真，都会返回左（右）边表中的记录。</p>
</li>
<li><p>where条件是在<strong>临时表生成好后</strong>，再对临时表进行过滤的条件。</p>
</li>
</ul>
<p>内连接：</p>
<p>是从结果表中删除与其他被连接表中没有匹配行的所有行，所有在<strong>内连接时on和where的结果是相同的</strong>。</p>
<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>有以下三种常用的去重方式：</p>
<ul>
<li>distinct 去重关键字（要去重的字段要放在第一个）</li>
<li>group by 按照要去重的字段分组</li>
<li>union 操作符合并两个结果集会自动去除重复元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT distinct university from user_profile</span><br><span class="line">select university from user_profile group by university</span><br><span class="line">SELECT  university from user_profile union SELECT  university from user_profile</span><br></pre></td></tr></table></figure>



<h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h3><p>如果给定两个参数，第一个参数指定第一个返回记录行的<strong>偏移量</strong>，第二个参数指定返回记录行的<strong>最大数目</strong>。</p>
<p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。<br>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。<br>如果只给定一个参数，它表示返回最大的记录行数目。</p>
<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1。<br>初始记录行的偏移量是 0 (而不是 1)。</p>
<p>例5.检索记录行 6-10</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 5,5</span><br></pre></td></tr></table></figure>

<p>例6.检索记录行 11-last</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 10,-1</span><br></pre></td></tr></table></figure>

<p>例7.检索前 5 个记录行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT 5</span><br></pre></td></tr></table></figure>



<h3 id="确定集合"><a href="#确定集合" class="headerlink" title="确定集合"></a>确定集合</h3><p>用来查找属性值属于指定集合的元组。<br>格式为：</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220815212327699.png" alt="image-20220815212327699"> </p>
<p>IN：当列中的值与IN中的某个常量值相等时，则结果为True，表明此记录为符合查询条件的记录。<br>NOT IN：当列中的值与某个常量值相等时，结果为False，表明此记录为不符合查询条件的记录。</p>
<p>例17.查询所有班名是“电子信息工程技术”、“电子声像”或“电子组装技术”的班号和班名。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220815212310445.png" alt="image-20220815212310445"> </p>
<p>等价于：</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220815212255169.png" alt="image-20220815212255169"> </p>
<p>例18.查询班名既不是“电子信息工程技术”、也不是“电子声像”和“电子组装技术”的班号和班名。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220815212241613.png" alt="image-20220815212241613"> </p>
<p>等价于：</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220815212151942.png" alt="image-20220815212151942"> </p>
<h3 id="where过滤空值"><a href="#where过滤空值" class="headerlink" title="where过滤空值"></a>where过滤空值</h3><p>解法一：</p>
<p><strong><code>select device_id,gender,age,university</code></strong><br><strong><code>from user_profile</code></strong><br><strong><code>where age is not NULL;</code></strong></p>
<p>解法二：</p>
<p><strong><code>select device_id,gender,age,university</code></strong><br><strong><code>from user_profile</code></strong><br><strong><code>where age !=&#39;&#39;;</code></strong></p>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>复旦大学学生gpa最高值</p>
<hr>
<p><strong>问题分解：</strong></p>
<ul>
<li>限定条件：复旦大学学生，<code>university=&#39;复旦大学&#39;</code>；</li>
<li>gpa最高值：max(gpa)；当然也可以按 gpa 降序排序，取第一名</li>
</ul>
<hr>
<p><strong>细节问题：</strong></p>
<ul>
<li>表头重命名：as</li>
</ul>
<p><strong>完整代码：</strong></p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220815213744043.png" alt="image-20220815213744043"></p>
<h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND"></a>ROUND</h3><p>ROUND(x) 函数返回最接近于参数 x 的整数；</p>
<p>ROUND(x,y) 函数对参数 x 进行四舍五入的操作，返回值保留小数点后面指定的 y 位。</p>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><p><strong>MySQL 索引是帮助存储引擎快速获取数据的一种数据结构</strong>。</p>
<h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><p>优点：</p>
<ul>
<li>使用索引可以<strong>大大加快数据的检索速度</strong>（大大减少检索的数据量）。</li>
<li>通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。</li>
<li>可以加速表和表之间的连接。 </li>
<li>在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间，且时间随着数据量的增加而增加。 </li>
<li>对表中的数据进行增删改时，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<h3 id="索引的必要性"><a href="#索引的必要性" class="headerlink" title="索引的必要性"></a>索引的必要性</h3><p>[MySQL索引详解（优缺点，何时需要&#x2F;不需要创建索引，索引及sql语句的优化）](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/l199616j/p/11232392.html#:~:text=MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BD%95%E6%97%B6%E9%9C%80%E8%A6%81%2F%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%8F%8Asql%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%89">https://www.cnblogs.com/l199616j/p/11232392.html#:~:text=MySQL索引详解（优缺点，何时需要%2F不需要创建索引，索引及sql语句的优化）</a> 1 通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性。 2 可以加快数据的检索速度,3 可以加速表与表之间的连接 4 在使用分组和排序进行检索的时候，可以减少查询中分组和排序的时 )</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/superit401/article/details/51291603">mysql_建立索引的优缺点</a></p>
<h4 id="什么时候需要索引"><a href="#什么时候需要索引" class="headerlink" title="什么时候需要索引"></a><strong>什么时候需要索引</strong></h4><ol>
<li>主键自动创建唯一索引</li>
<li>频繁查询的字段应该创建索引</li>
<li>用于排序的字段创建索引将大大提高排序的速度</li>
<li>用于统计或者分组的字段；</li>
<li>在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>
<li>在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； </li>
<li>在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h4 id="什么时候不需要索引"><a href="#什么时候不需要索引" class="headerlink" title="什么时候不需要索引"></a><strong>什么时候不需要索引</strong></h4><ol>
<li>频繁更新的字段不适合创建索引，因为每次更新不仅要更新记录，还要更新索引</li>
<li>where 条件里用不到的字段，不创建索引；</li>
<li>表记录太少，不需要创建索引；</li>
<li>对于只有很少数据值的列，不创建索引。因为这些列的取值很少，例如<strong>性别列</strong>，在查询的结果中<strong>结果集的数据行仍会占表中数据行中的很大比例</strong>。增加索引并不能明显加快检索速度。</li>
<li>定义为 text, image 和 bit 数据类型的列，不创建索引。因为这些列的数据量要么相当大，要么取值很少。</li>
</ol>
<h3 id="创建索引的方法"><a href="#创建索引的方法" class="headerlink" title="创建索引的方法"></a>创建索引的方法</h3><p>1、使用 <code>CREATE TABLE</code> 语句配合 <code>INDEX </code> 或 <code>UNIQUE </code> 关键字在建表时直接创建索引；</p>
<p>2、使用 <code>ALTER TABLE</code> 语句来直接创建索引；</p>
<p>3、使用 <code>CREATE INDEX</code> 语句对表增加普通索引或 <code>UNIQUE</code> 索引。</p>
<p><strong>create table table_name ( […], INDEX [索引的名字] (列的列表) );</strong><br><strong>alter table table_name add index[索引的名字] (列的列表);</strong><br> <strong>create index &lt;索引的名字&gt; on table_name (列的列表);</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//普通索引</span><br><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    INDEX [indexName] (username(length))  </span><br><span class="line"> );  </span><br><span class="line"></span><br><span class="line">//唯一索引</span><br><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    UNIQUE [indexName] (username(length))  </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE (column_list);</span><br><span class="line">ALTER TABLE table_name ADD PRIMARY KEY (column_list);</span><br><span class="line">    </span><br><span class="line">CREATE INDEX index_name ON table_name (column_list)</span><br><span class="line">CREATE UNIQUE INDEX index_name ON table_name (column_list)</span><br></pre></td></tr></table></figure>



<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>按照四个角度来分类索引。</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
<h3 id="主键索引和辅助索引"><a href="#主键索引和辅助索引" class="headerlink" title="主键索引和辅助索引"></a>主键索引和辅助索引</h3><h4 id="主键索引-聚簇索引"><a href="#主键索引-聚簇索引" class="headerlink" title="主键索引(聚簇索引)"></a>主键索引(聚簇索引)</h4><p>数据表的主键使用的就是主键索引。</p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为 null、不能重复。由一个或多个列组成，用于唯一性标识数据表中的某一条记录</strong>。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显式的指定表的主键时，InnoDB 会检查表中是否有唯一索引且不允许存在 null 值的字段，如果有就选择该字段作为主键，否则就创建一个 6Byte 的自增主键。</p>
<h4 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h4><p><strong>二级索引又叫辅助索引，因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引都属于二级索引。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的是为了保证属性列数据的唯一性，而不是为了提高查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引用于快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引用于字符串类型的数据，对文本前几个字符创建索引，相比普通索引建立的数据更小。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引用于检索大文本数据中的关键字信息，是搜索引擎数据库使用的一种技术。</li>
</ol>
<h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code> 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引 (B+ 树) 的非叶子节点存储索引，<strong>叶子节点存储索引和索引对应的数据。</strong></p>
<h5 id="聚集索引的优点"><a href="#聚集索引的优点" class="headerlink" title="聚集索引的优点"></a><strong>聚集索引的优点</strong></h5><ul>
<li>聚集索引的查询速度非常快，因为 B+ 树本身就是多叉平衡树，叶子节点是有序的，<strong>定位到索引的节点，就相当于定位到了数据。</strong></li>
</ul>
<h5 id="聚集索引的缺点"><a href="#聚集索引的缺点" class="headerlink" title="聚集索引的缺点"></a><strong>聚集索引的缺点</strong></h5><ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+ 树是多叉平衡树，如果索引的数据不是有序的，就需要在插入时排序，类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度就比较慢。</li>
<li><strong>更新代价大</strong> ： 如果修改索引列的数据，那么对应的索引也会被修改，而且聚集索引的叶子节点还存放数据，修改代价较大。所以对<strong>于主键索引来说，主键一般不可修改的</strong>。</li>
</ol>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/btree.drawio.png" alt="主键索引 B+Tree" style="zoom:67%;">

<h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p><strong>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</strong></p>
<p>非聚集索引的叶子节点不一定存放数据的指针。比如二级索引的<strong>叶子节点存放的是主键，根据主键再回表查数据。</strong></p>
<h5 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a><strong>非聚集索引的优点</strong></h5><ul>
<li><strong>更新代价比聚集索引要小</strong> ，因为非聚集索引的叶子节点不存放数据。</li>
</ul>
<h5 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h5><ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> ：这可能是非聚集索引最大的缺点。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再回表查询。</li>
</ol>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p>
<p>聚集索引和非聚集索引:</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C20210420165326946.png" alt="img"></p>
<h5 id="非聚集索引一定回表查询吗"><a href="#非聚集索引一定回表查询吗" class="headerlink" title="非聚集索引一定回表查询吗 ?"></a>非聚集索引一定回表查询吗 ?</h5><p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE name=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
</blockquote>
<h3 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p><strong>覆盖索引即需要查询的字段正好是索引的字段，就可以直接根据该索引查到数据，无需回表查询。</strong></p>
<p>如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是列值 + 主键，然后会“回表”，也就是要通过主键再查找一次，这样就比较慢。覆盖索引就是要查询的字段和索引是对应的，不做回表操作！</p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>使用表中的多个字段创建索引，就是<strong>联合索引</strong>。</p>
<h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>最左前缀匹配原则指的是，在使用联合索引时 <strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成。</p>
<p><strong>建立联合索引时，要把区分度大的字段排在前面</strong>，这也可以过滤更多数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/base/how_select.html#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8">#</a></p>
<p>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，<strong>对索引字段先做判断，</strong>过滤掉不符合条件的记录，<strong>减少回表次数</strong>。</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 建立了联合索引（age，reword）：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引当遇到范围查询 (&gt;、&lt;、between、like) 就会停止匹配，也就是 <strong>a 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。</p>
<ul>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 reward 字段值。</li>
</ul>
</blockquote>
<h3 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h3><p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p>
</li>
<li><p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
</li>
<li><p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
</li>
<li><p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
</li>
<li><p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引代替普通索引。</p>
<h3 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h3><ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>索引最好设置为 NOT NULL</li>
<li>防止索引失效；</li>
</ul>
<h4 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h4><p>前缀索引就是使用字符串的前几个字符建立索引。</p>
<p>使用前缀索引可以减小索引字段大小，有效提高索引的查询速度。<strong>在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</strong></p>
<p>不过，前缀索引有一定的局限性，例如：</p>
<ul>
<li>order by 就无法使用前缀索引；</li>
<li>无法把前缀索引用作覆盖索引；</li>
</ul>
<h4 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h4><p>覆盖索引是指 SQL 中查询的所有字段正好是索引的字段，就可以直接根据该索引查到数据，无需回表查询。</p>
<blockquote>
<p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p>
<p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p>
</blockquote>
<p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作</p>
<h4 id="主键索引最好是自增的"><a href="#主键索引最好是自增的" class="headerlink" title="主键索引最好是自增的"></a>主键索引最好是自增的</h4><p>在建表时默认会将主键索引设置为自增，为什么要这样做呢？</p>
<p>InnoDB 创建主键索引是聚簇索引，数据被存放在了 B+ Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，当有一条新数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p>
<p><strong>如果使用自增主键</strong>，那么每次插入的新数据都是追加操作，不需要移动已有的数据。当页面写满时，就会自动开辟一个新页面，所以效率非常高。</p>
<p><strong>如果使用非自增主键</strong>，每次插入的主键的索引是随机的，可能会插入到数据页中间的位置，就需要移动已有的数据，甚至可能需要从一个页面复制数据到另外一个页面，这种情况称为<strong>页分裂</strong>。<strong>页分裂会导致索引结构不紧凑，从而影响查询效率</strong>。</p>
<h4 id="索引最好设置为-NOT-NULL"><a href="#索引最好设置为-NOT-NULL" class="headerlink" title="索引最好设置为 NOT NULL"></a>索引最好设置为 NOT NULL</h4><p>有两个原因：</p>
<ul>
<li><p>第一原因：<strong>索引列存在 NULL 会导致优化器难以优化</strong>，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂。比如进行索引统计时，<strong>count 会省略值为NULL 的行</strong>。</p>
</li>
<li><p>第二个原因：<strong>NULL 值是没意义的值，但是会占用物理空间</strong>，InnoDB 默认行存储格式 <code>COMPACT</code>，会用 1 字节空间存储 NULL 值列表。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C008eGmZEgy1gp6pbo6xd7j30v602u3yq.jpg" alt="img"></p>
</li>
</ul>
<h4 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h4><p>用上了索引并不意味着查询时就会用到索引，有些情况会导致索引失效，要避免写出索引失效的查询语句，否则查询效率会很低。</p>
<p>我之前写过索引失效的文章，想详细了解的可以去看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">谁还没碰过索引失效呢?(opens new window)</a></p>
<h5 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h5><ul>
<li>对索引使用<strong>左或左右模糊匹配</strong>会造成索引失效， <code>like %xx</code> 或 <code>like %xx%</code> 这两种方式都会造成索引失效，<strong>因为 B+ 树是按照「索引值」有序排列存储的，需要根据前缀进行比较。</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span> name 字段为二级索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%林&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>对索引使用函数、表达式运算</strong>：如果在查询条件中对索引使用函数、表达式运算，会造成索引失效；因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> name 为二级索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> length(name)<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>对索引字段类型隐式转换：</strong>如果索引字段是字符串类型，但是在条件查询中输入的参数是整型，会造成索引失效。在执行计划的结果中会发现这条语句走的全表扫描。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> phone 字段，是二级索引且类型是 <span class="type">varchar</span>。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</strong>。</p>
<p>id 是整型，但是下面这条语句还是走了索引扫描的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这时因为<strong>字符串部分是输入参数，也就需要将字符串转为数字</strong>，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong>联合索引非最左匹配</strong>：<strong>使用表中多个字段创建的索引就叫联合索引</strong>，联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的原则进行索引匹配，否则就会导致索引失效。因为<strong>在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</strong></li>
</ul>
<blockquote>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>需要注意的是，因为有查询优化器，所以 x 字段在 where 子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
</blockquote>
<ul>
<li><strong>在 WHERE 子句中，如果 OR 前的条件是索引字段，而 OR 后的条件不是索引字段</strong>，那么索引就会失效。因为只要有条件不是索引字段，就会进行全表扫描。</li>
</ul>
<h2 id="InnoDB-B-树"><a href="#InnoDB-B-树" class="headerlink" title="InnoDB &#x2F; B+树"></a>InnoDB &#x2F; B+树</h2><h3 id="Inno-DB-数据存储"><a href="#Inno-DB-数据存储" class="headerlink" title="Inno DB 数据存储"></a>Inno DB 数据存储</h3><p><strong>InnoDB 引擎以「数据页」为单位来读写</strong>，需要读一条记录时，会以页为单位整体读入内存。</p>
<p>即数据库 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都以 16KB 为单位，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 的内容刷新到磁盘中。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/243b1466779a9e107ae3ef0155604a17.png" alt="图片" style="zoom:50%;">





<h3 id="Inno-DB-数据页结构"><a href="#Inno-DB-数据页结构" class="headerlink" title="Inno DB 数据页结构"></a>Inno DB 数据页结构</h3><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/fabd6dadd61a0aa342d7107213955a72.png" alt="图片" style="zoom:67%;">

<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向链表</strong>，如下图所示：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/557d17e05ce90f18591c2305871af665.png" alt="图片" style="zoom:67%;">

<p>采用链表的结构是让数据页之间不需要是物理上的连续，而是逻辑上的连续。</p>
<p>数据页的主要作用是存储记录，也就是数据库的数据。</p>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，会存储用户记录的相对位置，起到<strong>记录的索引作用</strong>，方便快速找到记录。</p>
<p>页目录与记录的关系如下图：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/261011d237bec993821aa198b97ae8ce.png" alt="图片" style="zoom:67%;">

<p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>每个组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li>
<li>页目录会存储每组最后一条记录的地址偏移量，地址偏移量会按照顺序存储起来，地址偏移量也叫做槽（slot），<strong>槽相当于指针，指向了不同组的最后一条记录</strong>。</li>
</ol>
<p>从图可以看到，<strong>页目录由多个槽组成的</strong>。因为记录是按照「主键值」从小到大排序的，所以槽也是从小到大排序的。因此<strong>查找记录时，可以使用二分法快速定位要查询的记录在哪个槽，定位到槽后，再遍历槽内所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个数据页中的记录链表。</p>
<p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组只能有 1 条记录；</li>
<li>最后一个分组的记录条数在 1-8 条之间；</li>
<li>剩下分组的记录条数在 4-8 条之间。</li>
</ul>
<h3 id="B-树的查询"><a href="#B-树的查询" class="headerlink" title="B+ 树的查询"></a>B+ 树的查询</h3><p><strong>InnoDB 采用了 B+ 树构造索引</strong>，“矮胖”的 B+ 树数据结构可以减少进行磁盘 I&#x2F;O 的次数，而且更适合进行关键字的范围查询。</p>
<p>B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p>
<p>通过上图，我们看出 B+ 树的特点：</p>
<ul>
<li><strong>只有叶子节点才存放数据，非叶子节点仅存放索引。</strong></li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<p>定位记录时，先通过二分法快速定位到包含该记录的页，然后在页内再通过二分法快速定位到记录所在的分组（槽），最后在分组内进行遍历查找。</p>
<p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引。且由于数据在物理上只会保存一份，所以<strong>聚簇索引只能有一个</strong>。</p>
<p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的<strong>唯一列</strong>作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，为了实现非主键字段的快速搜索，就引出了二级索引，也是利用 B+ 树数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p>
<h3 id="为什么使用B-树作为索引"><a href="#为什么使用B-树作为索引" class="headerlink" title="为什么使用B+树作为索引"></a>为什么使用B+树作为索引</h3><p>MySQL 会将数据持久化到硬盘，存储功能由 MySQL 存储引擎实现的，InnoDB 是 MySQL 默认的存储引擎，采用 B+ 树作为索引的数据结构。</p>
<p>B 树和 B+ 都是多叉树，会将树的高度变矮，所以这两个数据结构非常适合检索磁盘中的数据。</p>
<p>但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 树作为索引的数据结构，原因有：</p>
<ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，而 B 树既存索引又存记录，所以 B + 树的非叶子节点可以存放更多的索引，因此 <strong>B+ 树比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O 次数会更少。</strong></li>
<li>B+ 树有大量的冗余节点，所有非叶子节点都是冗余索引，冗余索引能提高 <strong>B+ 树插入、删除时的效率</strong>，比如删除根节点时，不会像 B 树那样发生复杂的树变化；</li>
<li>B+ 树叶子节点间用链表连接，有利于范围查询，而 B 树只能通过树的遍历来完成范围查询，会涉及多个节点的磁盘 I&#x2F;O 操作，所以范围查询效率不如 B+ 树。</li>
</ul>
<h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><p>B+ 树与 B 树差异的点，主要是以下这几点：</p>
<ul>
<li>叶子节点才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li>
<li>所有索引都会出现在叶子节点，叶子节点间构成一个有序链表；</li>
<li>非叶子节点的索引会出现在子节点中，并且是子节点中最大或最小的索引。</li>
<li>非叶子节点有多少个索引，就有多少个子节点。</li>
</ul>
<h4 id="不使用B树的原因"><a href="#不使用B树的原因" class="headerlink" title="不使用B树的原因"></a>不使用B树的原因</h4><p>● B 树的非叶子节点也会存储 key 和 data，因此平均情况下，B 树的查找效率比 B+ 树更高。<br>● B 树的叶子节点是相互独立的，B+ 树的叶子节点有指向相邻节点的指针，因此 B+ 树排序和范围查询的效率更高。<br>● 因此 <strong>B 树更适合用于单一查询更多的数据库，如非关系型数据库。而 B+ 树则更适合用于排序和范围查询更多的数据库，如关系型数据库</strong>。</p>
<h4 id="不使用-Hash-表的原因"><a href="#不使用-Hash-表的原因" class="headerlink" title="不使用 Hash 表的原因"></a>不使用 Hash 表的原因</h4><p>● hash 冲突<br>● 不支持排序和范围查询</p>
<h4 id="不使用-BST（二叉搜索树）的原因"><a href="#不使用-BST（二叉搜索树）的原因" class="headerlink" title="不使用 BST（二叉搜索树）的原因"></a>不使用 BST（二叉搜索树）的原因</h4><p>● 不可能一次性把所有索引装入内存，只能逐一加载索引，因此 BST 的 I&#x2F;O 次数过多。且 BST 是二叉树，树的高度更高，存在极端情况下的线性高度问题。<br>● B+ 树单个节点包含的索引更多，相对需要的 I&#x2F;O 次数就更少。<br>● B+ 树高度一般为 2-4 层，只需要 2-4 次 I&#x2F;O。</p>
<h4 id="不使用红黑树的原因"><a href="#不使用红黑树的原因" class="headerlink" title="不使用红黑树的原因"></a>不使用红黑树的原因</h4><p>● 虽然红黑树结合了平衡树和 BST，解决了 BST 极端情况下的线性高度问题，但是依然存在着 BST 的缺点。<br>● 红黑树、BST 更适合在内存中使用，用于查找和排序。</p>
<h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><h3 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>事务由 MySQL 引擎实现，常见的 InnoDB 引擎就支持事务。</p>
<p><strong>InnoDB 支持事务，MyISAM 不支持事务</strong></p>
<p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致；例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不会被其他事务干扰。隔离性可以防止多个事务并发执行导致的数据不一致。</li>
<li><strong>持久性</strong>（<code>Durabilily</code>）：事务提交后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<blockquote>
<p>详解：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：<strong>一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节</strong>，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。</li>
<li><strong>一致性（Consistency）</strong>：是指<strong>事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</strong>比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li>
<li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li>
<li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
</blockquote>
<p><strong>InnoDB 引擎通过什么技术来保证事务的四个特性的呢？</strong></p>
<ul>
<li><strong>持久性通过 redo log（重做日志）保证</strong>；</li>
<li><strong>原子性通过 undo log（回滚日志） 保证</strong>；</li>
<li><strong>隔离性通过 MVCC（多版本并发控制） 或锁机制保证</strong>；</li>
<li><strong>一致性通过 持久性+原子性+隔离性 保证</strong>；</li>
</ul>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5CAIDC.png" alt="AID-&gt;C"></p>
<h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><p>如果多个事务并发运行并操作相同数据，可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> <strong>一个事务「读到」了另一个「未提交事务修改过的数据」</strong>；</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况。</li>
<li>**幻读（Phantom read）: **一个事务内多次查询符合某个条件的「记录数量」，出现前后两次记录数量不一样的情况。</li>
</ul>
<p>严重性：</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cd37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p>
<p><strong>不可重复读和幻读有什么区别呢？</strong></p>
<ul>
<li>不可重复读：同样的条件下，读取过的数据，当我们再次读取时值发生了变化。；</li>
<li>幻读：同样的条件下，第1次和第2次读出来的记录数不一样。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
<blockquote>
<p><strong>丢失修改（Lost to modify）:</strong> 两个事务同时访问一个数据，然后第一个事务先修改该数据，第二个事务接着也修改这个数据。这样第一个事务的修改结果就会丢失。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p>
</blockquote>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li><strong>READ-UNCOMMITTED(读未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 多次读取同一数据的结果是一致的，除非数据是被本身事务所修改的，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，可以防止脏读、不可重复读以及幻读。</li>
</ul>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/4e98ea2e60923b969790898565b4d643.png" alt="图片" style="zoom:67%;">

<p><strong>InnoDB 引擎的默认隔离级别是「可重复读」，但是它通过next-key lock 锁（行锁和间隙锁的组合）锁住了记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</strong></p>
<h3 id="隔离级别的实现方式"><a href="#隔离级别的实现方式" class="headerlink" title="隔离级别的实现方式"></a>隔离级别的实现方式</h3><p>MySQL 隔离级别基于锁和 MVCC 机制共同实现的。</p>
<ul>
<li>对于「读未提交」隔离级别的事务，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好；</li>
<li>对于「串行化」隔离级别的事务，通过<strong>读写锁</strong>来避免并行访问；</li>
<li>对于「读提交」和「可重复读」隔离级别的事务，<strong>通过 Read View 实现，它们的区别在于创建 Read View 的时机不同，Read View 可以理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。</strong><ul>
<li><strong>「读提交」隔离级别每次 select 时都会生成一个新的 Read View</strong>，这意味着事务期间多次读取同一条数据，前后两次读的数据可能会不一致，因为别的事务可能在这期间修改了数据，并提交了事务。</li>
<li><strong>「可重复读」隔离级别在启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，</strong>这样就保证了事务期间读到的数据都是事务启动前的记录。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两个隔离级别通过对比<strong>「事务的 Read View 里的字段」和「记录中的两个隐藏列」，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）</strong>。</p>
</blockquote>
<h3 id="MVCC-的实现方式"><a href="#MVCC-的实现方式" class="headerlink" title="MVCC 的实现方式"></a>MVCC 的实现方式</h3><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/readview结构.drawio.png" alt="img" style="zoom:67%;">

<p>Read View 有<strong>四个重要的字段</strong>：</p>
<ul>
<li>m_ids ：指创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指启动了但还没提交的事务</strong>。</li>
<li>min_trx_id ：指创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库应该分配给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id + 1；</li>
<li>creator_trx_id ：指<strong>创建该 Read View 的事务的事务 id</strong>。</li>
</ul>
<h4 id="聚簇索引记录中的两个隐藏列"><a href="#聚簇索引记录中的两个隐藏列" class="headerlink" title="聚簇索引记录中的两个隐藏列"></a>聚簇索引记录中的两个隐藏列</h4><p>使用 InnoDB 引擎的数据库表，它的聚簇索引记录中包含下面两个隐藏列：</p>
<ul>
<li>trx_id：当一个事务修改某条聚簇索引记录时，就会<strong>把这个事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li>roll_pointer：每次修改聚簇索引记录时，都会把旧的记录写入 undo 日志中，<strong>roll_pointer 隐藏列是个指针，会指向旧的记录</strong>，可以通过 roll_pointer 找到修改前的记录。</li>
</ul>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/f595d13450878acd04affa82731f76c5.png" alt="图片" style="zoom:67%;">

<h4 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h4><p>创建 Read View 后，可以将记录中的 trx_id 分成三种情况：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/ReadView.drawio.png" alt="img" style="zoom:67%;">

<p>一个事务访问记录时，除了自己的更新记录总是可见外，还有这几种情况：</p>
<ul>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表明该版本记录是在创建 Read View <strong>前</strong>由已经提交的事务生成的，所以该版本记录对当前事务<strong>可见</strong>。</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表明该版本是在创建 Read View <strong>后</strong>由才启动的事务生成的，所以该版本记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul>
<li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表明生成该版本记录的活跃事务仍然活跃着（还没提交事务），所以该版本记录对当前事务<strong>不可见</strong>。</li>
<li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表明生成该版本记录的活跃事务已经被提交，所以该版本记录对当前事务<strong>可见</strong>。</li>
</ul>
</li>
</ul>
<p>这种通过对比<strong>「事务的 Read View 里的字段」和「记录中的两个隐藏列」（版本链），来控制并发事务访问同一个记录时的行为，就叫 MVCC（多版本并发控制）</strong>。</p>
<h3 id="幻读的解决"><a href="#幻读的解决" class="headerlink" title="幻读的解决"></a>幻读的解决</h3><p>InnoDB 的默认隔离级别 RR（可重读）是<strong>可以解决幻读问题</strong>发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong> ：由 <strong>MVCC 机制</strong>来保证不出现幻读。</li>
<li><strong>当前读</strong>： 使用 <strong>Next-Key Lock 加锁</strong>来保证不出现幻读。</li>
</ul>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>在可重复读隔离级别下，<strong>普通查询是快照读，是不会看到别的事务插入的数据的</strong>，不会出现幻读。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p>
<p><code>select ... for update</code> 语句也是当前读，每次执行前都查询最新的数据。</p>
<p>如下图，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。</p>
<p><strong>Innodb 引擎为了解决「可重复读」隔离级别中使用「当前读」导致的幻读问题，就引出了 next - key 锁</strong>，即记录锁和间隙锁的组合。</p>
<ul>
<li>记录锁，锁记录本身；</li>
<li>间隙锁，锁两个值之间的空隙，防止其他事务在这个空隙插入新数据，从而避免幻读现象。</li>
</ul>
<p>比如，执行这条语句时，会锁住id &gt; 2，如果有其他事务在锁住的范围内插入数据就会被阻塞。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/3af285a8e70f4d4198318057eb955520.png" alt="img" style="zoom:50%;">

<h2 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h4><p>MyISAM 仅支持表级锁，一锁就锁整张表，所以并发写的情况下性能非常差。</p>
<p>InnoDB 不光支持表级锁，还支持行级锁，默认行级锁。行级锁的粒度更小，仅对相关的记录上锁（对一行或者多行记录加锁），所以并发写的情况下性能更高。</p>
<p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的锁，针对<strong>非索引字段</strong>加锁，对整张表加锁，加锁快，不会出现死锁，但是锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的锁，针对<strong>索引字段</strong>加锁，只对当前操作的行记录进行加锁。 行级锁大大减少了锁冲突的概率，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p>只有通过索引字段检索数据，InnoDB才会使用行级锁，否则将使用表锁！</p>
<p><strong>注意事项</strong>：</p>
<p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code> 条件中的字段没有命中索引或者索引失效的话，InnoDB 就会使用表级锁对表中所有行记录加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>
<p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>
<h4 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h4><p>表级锁和行级锁都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）：</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称<strong>读锁</strong>，事务读取记录时获取共享锁，允许多个事务同时获取。</li>
<li><strong>排他锁（X 锁）</strong> ：又称<strong>写锁</strong>&#x2F;<strong>独占锁</strong>，事务修改记录时获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那么其他事务不能再对这条事务加任何类型的锁。</li>
</ul>
<p>读读共享、读写互斥、写写互斥</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220724172405583.png" alt="image-20220724172405583"></p>
<p>对于一般的 <code>SELECT</code> 语句，由于 MVCC 的存在，InnoDB 不会加任何锁。不过， 可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>行锁和表锁会冲突，如果需要用到表锁，如何确定表中的记录没有行锁呢？意向锁可以快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是<strong>表级锁</strong>，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：如果事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：如果事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p>意向锁是数据引擎自己维护的，用户无法手动操作意向锁。在为数据加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据所在表的意向锁。</p>
<p>如果意向锁被占用了，说明这张表中的某些记录加了行锁，就无法对这张表再加表锁。</p>
<p>意向锁之间是互相兼容的。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220724191901458.png" alt="image-20220724191901458"></p>
<p>意向锁和表级的共享锁、排他锁互斥，不与行级的共享锁、排他锁互斥。</p>
<p><strong>读读共享、读写互斥、写写互斥</strong></p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220724191947649.png" alt="image-20220724191947649"></p>
<h4 id="InnoDB-行锁类型"><a href="#InnoDB-行锁类型" class="headerlink" title="InnoDB 行锁类型"></a>InnoDB 行锁类型</h4><p>MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock + Gap Lock，不仅会锁住记录本身，还会锁定一个范围，从而避免插入新记录，解决幻读问题。</li>
</ul>
<p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li>
<li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</li>
</ul>
<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
<p>InnoDB 存储引擎对读操作支持两种一致性锁定读方式，或者说对读操作支持两种加锁方式：</p>
<ul>
<li><code>SELECT ... FOR UPDATE</code>，对于读取的行记录加一个 X 排他锁，其他事务不能对锁定的行加任何锁</li>
<li><code>SELECT ... LOCK IN SHARE MODE</code>，对于读取的行记录添加一个 S 共享锁。其它事务可以向被锁定的行加 S 锁，但是不允许添加 X 锁，否则会被阻塞住</li>
</ul>
<h4 id="MySQL加锁方式"><a href="#MySQL加锁方式" class="headerlink" title="MySQL加锁方式"></a>MySQL加锁方式</h4><p>对记录加锁时，<strong>加锁的基本单位是 next - key lock</strong>，由记录锁和间隙锁组合而成，<strong>next-key lock 是 前开后闭 区间，而间隙锁是 前开后开 区间</strong>。</p>
<blockquote>
<p>next-key lock 在一些场景下会退化成记录锁或间隙锁。</p>
<p>例子id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。</p>
</blockquote>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C954708d2f29c2a619e861e57cdf74c11.png" alt="图片"></p>
<h5 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h5><ul>
<li><strong>用「唯一索引进行等值查询」时，如果查询的记录存在，next-key lock 会退化成「记录锁」</strong>。</li>
<li><strong>用「唯一索引进行等值查询」时，如果查询的记录不存在，next-key lock 会退化成「间隙锁」。</strong></li>
</ul>
<blockquote>
<p> 如果查询的记录存在</p>
</blockquote>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/2a944fb385d1de277dbfdc78102f36ba.png" alt="图片" style="zoom:67%;">

<p>会话1加锁变化过程如下：</p>
<ol>
<li>加锁的基本单位是 next-key lock，因此会话1的加锁范围是(8, 16];</li>
<li>但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 <strong>next-key lock 退化成记录锁，因此最终加锁的范围是 id &#x3D; 16 这一行</strong>。</li>
</ol>
<p>所以，会话 2 在修改 id&#x3D;16 的记录时会被阻塞，而会话 3 插入 id&#x3D;9 的记录可以正常执行。</p>
<blockquote>
<p>如果查询的记录不存在</p>
</blockquote>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/d82332993969a223fa3433eaf5185134.png" alt="图片" style="zoom:67%;">

<p>会话1加锁变化过程如下：</p>
<ol>
<li>加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是 (8, 16];</li>
<li>但是由于是用唯一索引进行等值查询，且查询的记录不存在，所以 next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。</li>
</ol>
<p>所以，会话 2 要往这个间隙里面插入 id&#x3D;9 的记录会被阻塞，但是会话 3 修改 id &#x3D;16 是可以正常执行的。</p>
<h5 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h5><p>范围查询和等值查询的加锁规则是不同的。</p>
<p>下面这两条查询语句，查询的结果虽然是一样的，但是加锁的范围是不一样的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">8</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/c12bdb8af1972d5f287978b489a83304.png" alt="图片" style="zoom:67%;">

<p>会话 1 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id &#x3D; 8，因此 next-key lock  加锁范围是 (4,8]，由于 id 是唯一索引，且记录是存在的，因此会退化成记录锁，最终只对 id &#x3D; 8 这一行加锁；</li>
<li>由于是范围查找，会继续往后找存在的记录，直到找到 id &#x3D; 16 这一行停下来，然后加 next-key lock 加锁范围 (8, 16]，但由于 id &#x3D; 16 不满足 id &lt; 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。</li>
</ol>
<p>所以，会话 1 这时主键索引的锁是记录锁 id&#x3D;8 和间隙锁 (8, 16)。</p>
<p>会话 2 往间隙锁里插入 id &#x3D; 9 的记录，所以会被锁住。而 id &#x3D; 8 是被加锁的，因此会话 3 的语句也会被阻塞。</p>
<p>由于 id &#x3D; 16 并没有加锁，所以会话 4 是可以正常执行。</p>
<h5 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="非唯一索引等值查询"></a>非唯一索引等值查询</h5><p>用非唯一索引进行等值查询时，查询的记录存不存在，加锁的规则也不同：</p>
<ul>
<li><strong>如果查询的记录存在，除了会加 next-key lock 外，还会额外加间隙锁，也就是会加两把锁</strong>。</li>
<li><strong>如果查询的记录不存在，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁</strong>。</li>
</ul>
<blockquote>
<p>如果查询的记录存在</p>
</blockquote>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/be6818bd1fd22c4e790b989bde11e6b1.png" alt="图片" style="zoom:67%;">



<p>会话 1 加锁变化过程如下：</p>
<ol>
<li>先对普通索引 b 加上 next-key lock，加锁范围是 (4,8];</li>
<li>因为是非唯一索引，且查询的记录存在，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。</li>
</ol>
<p>所以，会话1的普通索引 b 上共有两个锁，分别是 next-key lock (4,8] 和间隙锁 (8,16) 。</p>
<p>当会话 2 往间隙锁里插入 id &#x3D; 9 的记录就会被阻塞，会话 3 和会话 4 是因为更改了 next-key lock 范围里的记录而被阻塞。</p>
<p>b &#x3D; 16 这条记录没有加锁，所以会话 5 是可以正常执行的。</p>
<blockquote>
<p>如果查询的记录不存在</p>
</blockquote>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/案例5.drawio.png" alt="img" style="zoom:67%;">

<p>会话 1 加锁变化过程如下：</p>
<ol>
<li>先对普通索引 b 加上 next-key lock，范围是 (8,16];</li>
<li>由于查询的记录不存在，所以不会再额外加间隙锁，且 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。</li>
</ol>
<p>会话 2 因为往间隙锁里插入了 b &#x3D; 9 的记录，所以会被阻塞，而 b &#x3D; 16 是没有被加锁的，因此会话 3 的语句可以正常执行。</p>
<h5 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="非唯一索引范围查询"></a>非唯一索引范围查询</h5><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁</strong>。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/ac6c09c4011259d3397e62e52a37d384.png" alt="图片" style="zoom:67%;">

<p>会话 1 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 b &#x3D; 8，因此 next-key lock 加锁范围是 (4,8]，由于 b 不是唯一索引，所以不会退化成记录锁。</li>
<li>由于是范围查找，会继续往后找存在的记录，直到找到 b &#x3D; 16 这一行停下来，然后加 next-key lock 加锁范围是 (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。</li>
</ol>
<p>所以，会话 1 的普通索引 b 有两个 next-key lock，分别是 (4,8] 和 (8, 16]。这样，你就明白为什么会话 2 、会话 3 、会话 4 的语句都会被锁住了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>唯一索引等值查询：</p>
<ul>
<li>当查询的记录是存在的，next-key lock 会退化成「记录锁」。</li>
<li>当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。</li>
</ul>
<p>非唯一索引等值查询：</p>
<ul>
<li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。</li>
<li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。</li>
</ul>
<p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p>
<ul>
<li>唯一索引在满足一些条件时，next-key lock 退化为间隙锁和记录锁。</li>
<li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li>
</ul>
<h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h2><h3 id="日志的分类"><a href="#日志的分类" class="headerlink" title="日志的分类"></a>日志的分类</h3><p>更新语句会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：</p>
<ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎生成的日志，实现了事务的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎生成的日志，实现了事务的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<h4 id="redo-log-和-undo-log-的区别"><a href="#redo-log-和-undo-log-的区别" class="headerlink" title="redo log 和 undo log 的区别"></a>redo log 和 undo log 的区别</h4><p>这两种日志都属于 InnoDB 存储引擎的日志，区别在于：</p>
<ul>
<li>redo log 记录了此次事务<strong>「完成后」</strong>的数据状态；</li>
<li>undo log 记录了此次事务<strong>「开始前」</strong>的数据状态；</li>
</ul>
<p><strong>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务</strong>。</p>
<h4 id="binlog-和-redo-log-的区别"><a href="#binlog-和-redo-log-的区别" class="headerlink" title="binlog 和 redo log 的区别"></a>binlog 和 redo log 的区别</h4><ul>
<li><strong>binlog</strong> 主要用于数据库还原，属于<strong>数据级别</strong>的数据恢复，主从复制是 binlog 最常见的一个应用场景。<strong>redo log</strong> 主要用于保证事务的持久性，属于<strong>事务级别</strong>的数据恢复。</li>
<li>redo log 是 InnoDB 引擎特有的，binlog 是所有存储引擎共有的，因为 binlog 是 MySQL 的 Server 层实现的。</li>
<li>redo log 属于物理日志，主要记录某个数据页的修改。binlog 属于逻辑日志，主要记录数据库执行的所有 DDL 和 DML 语句。</li>
<li>binlog 通过追加的方式进行写入，大小没有限制。redo log 通过循环的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。</li>
</ul>
<p><strong>数据操纵语言</strong>（Data Manipulation Language, DML）   数据定义语言DDL (Data Definition Language)</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 两大作用：</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或用户执行了 ROLLBACK 语句，MySQL 就会使用 undo log 将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）时，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><blockquote>
<p> MySQL 的数据都是存在磁盘中的，要更新一条记录时，得先要从磁盘读取该记录，然后在内存中修改记录。修改完的记录不会直接写回磁盘，而是缓存起来。如果有查询语句再次命中这条记录，就会直接读取缓存中的记录，不需要再从磁盘中获取数据。</p>
</blockquote>
<p>为此，Innodb 存储引擎设计了<strong>缓冲池（Buffer Pool）</strong>，来<strong>提高数据库的读写性能</strong>。</p>
<p>有了 Buffer Pool 后：</p>
<ul>
<li>读取数据时，如果数据存在于 Buffer Pool 中，就会直接读取 Buffer Pool 中的数据。如果数据不存在于 Buffer Pool 中，才会去磁盘中读取。</li>
<li>修改数据时，如果数据存在于 Buffer Pool 中，就会直接修改 Buffer Pool 中数据所在的页，然后将该页设置为<strong>脏页</strong>（该页的数据和磁盘上的数据不一致），为了减少磁盘 I&#x2F;O，不会立即将脏页写入磁盘，而是由后台线程选择一个合适的时机将脏页写入磁盘。</li>
</ul>
<blockquote>
<p>Buffer Pool 缓存什么？</p>
</blockquote>
<p><strong>InnoDB 以「数据页」为单位进行读写</strong>，InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 <strong>16KB</strong>。因此，Buffer Pool 同样按「页」来划分。</p>
<p>MySQL 启动时，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的 <code>16KB</code> 大小划分出一个个的页，即缓存页</strong>。此时这些缓存页都是空闲的，随着程序的运行，磁盘中的页就会被缓存到 Buffer Pool 中。</p>
<p>所以，MySQL 刚启动时，会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，只有这些虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址映射起来。</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还缓存 Undo 页、插入缓存页、自适应哈希索引、锁信息等等。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/Users/SuSu\AppData\Roaming\Typora\typora-user-images\image-20240310144959039.png" alt="image-20240310144959039"></p>
<blockquote>
<p>Undo 页是记录什么？</p>
</blockquote>
<p>开启事务后，如果是更新操作，会把被更新的记录的旧值记下来，即生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页。</p>
<blockquote>
<p>查询一条记录，就只缓存一条记录吗？</p>
</blockquote>
<p>不是。查询一条记录时，InnoDB 会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><h4 id="redo-log-作用"><a href="#redo-log-作用" class="headerlink" title="redo log 作用"></a>redo log 作用</h4><p>redo log 是物理日志，记录某个数据页做了什么修改，比如 对 XX 表中 XX 数据页 XX 偏移量的地方做了XX 更新，每执行一个事务就会产生一条物理日志。</p>
<p>在事务提交时，不需要把将缓存在 Buffer Pool 里的脏页数据持久化到磁盘，先将 redo log 持久化到磁盘即可。当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，MySQL 重启后，可以根据 redo log 将所有数据恢复到最新的状态。</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<p>Buffer Pool 提高了读写效率，但是 Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。</p>
<p>为了防止断电导致数据丢失，当有记录需要更新的时候，InnoDB 引擎会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>，<strong>指 MySQL 的写操作不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上</strong>。</p>
<h4 id="redo-log-写入磁盘"><a href="#redo-log-写入磁盘" class="headerlink" title="redo log 写入磁盘"></a>redo log 写入磁盘</h4><p>实际上，事务产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每产生一条 redo log 就会写入到 redo log buffer，后续再持久化到磁盘</p>
<p>刷盘时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的内存大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这个策略可由 innodb_flush_log_at_trx_commit 参数控制。</li>
</ul>
<p>参数 <code>innodb_flush_log_at_trx_commit</code> 控制，可取的值有：0、1、2，<strong>默认值为 1</strong>，这三个值分别代表的策略如下：</p>
<ul>
<li><strong>参数为 0 时</strong>，每次事务提交时 <strong>redo log 还是留在 redo log buffer 中</strong> ，不会主动触发写入磁盘的操作。</li>
<li><strong>参数为 1 时</strong>，每次事务提交时都会<strong>将缓存在 redo log buffer 里的 redo log 持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li><strong>参数为 2 时</strong>，每次事务提交时都会将缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件中，注意写入「 redo log 文件」并不意味着写入到了磁盘</strong>。操作系统的文件系统中有个 Page Cache，Page Cache 专门用来缓存文件数据的，所以<strong>写入「 redo log文件」意味着写入操作系统的文件缓存</strong>。</li>
</ul>
<p>这三个参数的数据安全性和写入性能的比较如下：</p>
<ul>
<li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li>
<li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li>
</ul>
<p>所以，数据安全性和写入性能是熊掌不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>MySQL 每完成一条更新操作，<strong>Server 层</strong>就会生成一条 binlog，等事务提交时，就会将事务执行期间产生的所有 binlog 一起写入 binlog 文件。binlog 文件<strong>记录了数据库执行的所有 DDL 和 DML 语句</strong>，不会记录查询类的操作，如 SELECT 和 SHOW。</p>
<blockquote>
<p>为什么有了 binlog， 还要有 redo log？</p>
</blockquote>
<p>这个问题跟 MySQL 的时间线有关系。</p>
<p>最开始 MySQL 里并没有 InnoDB 引擎，自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</p>
<p>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用 redo log 来实现 crash-safe 能力。</p>
<h2 id="读写分离和主从复制"><a href="#读写分离和主从复制" class="headerlink" title="读写分离和主从复制"></a>读写分离和主从复制</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><strong>读写分离将对数据库的读写操作分散到不同的数据库节点上。</strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/9c624bc130d053860a5089cb9a53310a.png" alt="读写分离" style="zoom:67%;">

<p>一般情况下会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>
<h4 id="读写分离存在的问题"><a href="#读写分离存在的问题" class="headerlink" title="读写分离存在的问题"></a>读写分离存在的问题</h4><p>读写分离对于提升数据库的并发非常有效，但是也会引来一个问题：主库和从库的数据存在延迟。写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题，即<strong>主从同步延迟</strong>。</p>
<p>主从同步延迟问题的解决，没有特别好的一种方案。你可以根据自己的业务场景，参考一下下面几种解决办法：</p>
<p><strong>强制将读请求路由到主库处理。</strong></p>
<p>既然从库的数据过期了，那就直接从主库读取。这种方案会增加主库的压力，但是实现起来比较简单，也是我了解到的使用最多的一种方式。</p>
<p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HintManager</span> <span class="variable">hintManager</span> <span class="operator">=</span> HintManager.getInstance();</span><br><span class="line">hintManager.setMasterRouteOnly();</span><br><span class="line"><span class="comment">// 继续JDBC操作</span></span><br></pre></td></tr></table></figure>

<p>对于这种方案，可以将那些必须获取最新数据的读请求都交给主库处理。</p>
<p><strong>延迟读取</strong></p>
<p>既然主从同步存在延迟，那就在延迟之后读取，比如主从同步延迟 0.5s，那就 1s 之后再读取数据。这样很方便，但是不好。</p>
<p>可以这样设计业务流程：对于一些对数据比较敏感的场景，在完成写请求之后，避免立即进行读请求。比如支付成功之后，跳转到一个支付成功的页面，点击返回之后才返回自己的账户进行读请求。</p>
<p><a target="_blank" rel="noopener" href="https://funnylog.gitee.io/mysql45/22%E8%AE%B2MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%22%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%22%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95.html">MySQL45讲</a></p>
<h4 id="读写分离的实现方式"><a href="#读写分离的实现方式" class="headerlink" title="读写分离的实现方式"></a>读写分离的实现方式</h4><p>想要实现读写分离一般包含如下几步：</p>
<ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>
<li>保证主从数据库之间的数据是实时同步的，也就是我们常说的<strong>主从复制</strong>。</li>
<li>将写请求交给主数据库处理，读请求交给从数据库处理。</li>
</ol>
<h5 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a><strong>代理方式</strong></h5><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/461112716e30db118f4c784adc6e2ff7.png" alt="读写分离-代理层" style="zoom:67%;">

<p>可以在应用程序和数据库中间加一个代理层。应用程序所有的请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p>
<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p>
<h5 id="组件方式"><a href="#组件方式" class="headerlink" title="组件方式"></a><strong>组件方式</strong></h5><p>也可以通过引入第三方组件来分离读写请求，也是比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。</p>
<p>如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>
<p>你可以在 shardingsphere 官方找到sharding-jdbc 关于读写分离的操作<a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/">sharding-jdbc 关于读写分离的操作open in new window</a></p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="主从复制的实现"><a href="#主从复制的实现" class="headerlink" title="主从复制的实现"></a>主从复制的实现</h4><p>MySQL binlog 记录了 **MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)**。因此根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/主从复制过程.drawio.png" alt="MySQL 主从复制过程" style="zoom:67%;">

<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库中，每个从库把 binlog 写到中继日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ul>
<p>具体可以分为以下几步：</p>
<ol>
<li>主库将数据库中数据的变化写入  binlog</li>
<li>从库连接主库</li>
<li>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</li>
<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li>
<li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li>
<li>从库的 SQL 线程读取 relay log 同步本地数据（也就是再执行一遍 SQL ）。</li>
</ol>
<p> 看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p>
<p><strong>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</strong></p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p>
<p><strong>为了避免两份日志的逻辑不一致，事务的提交使用了「两阶段提交」</strong>。</p>
<p><strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入 binlog</strong>，具体如下：</p>
<ul>
<li><p><strong>prepare 阶段</strong>：将事务的 XID 写入 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到磁盘；</p>
</li>
<li><p><strong>commit 阶段</strong>：把 XID 写入 binlog，然后将 binlog 刷新到磁盘。接着提交事务，将 redo log 对应的事务状态设置为 commit（设置为 commit 状态后，redo log 也会刷新到磁盘， commit 状态是会刷盘的）。</p>
<blockquote>
<p>每个事务都有一个唯一的XID，而且这个XID在整个数据库中都是唯一的。</p>
</blockquote>
</li>
</ul>
<p><strong>问题</strong></p>
<p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p>
<ul>
<li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，一次是 binlog 刷盘。</li>
<li><strong>锁竞争激烈</strong>：两阶段提交能够保证「单事务」情况下两个日志的内容一致，但却不能保证「多事务」情况下两个日志的提交顺序一致。因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务情况下，两个日志的提交顺序一致。</li>
</ul>
<h4 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h4><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交时，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</strong>，如果说 10 个事务依次排队刷盘的时间成本是 10，那么将这 10 个事务一次性一起刷盘的时间成本则近似于 1。</p>
<p>引入组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p>
<ul>
<li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog  写入 binlog  文件（不刷盘）；</li>
<li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li>
<li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li>
</ul>
<p>上面<strong>三个阶段都有一个队列</strong>，每个阶段都有锁进行保护，保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p>
<p>对每个阶段引入队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，<strong>锁粒度减小了，使得多个阶段可以并发执行，从而提升效率</strong>。</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库。</p>
<p>下面这些操作都涉及到了分库：</p>
<ul>
<li>你将数据库中的用户表和用户订单表分别放在两个不同的数据库。</li>
<li>由于用户表数据量太大，你对用户表进行了水平切分，然后将切分后的 2 张用户表分别放在两个不同的数据库。</li>
</ul>
<h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p><strong>垂直拆分</strong></p>
<p>简单来说，垂直拆分是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>
<p><strong>水平拆分</strong></p>
<p>简单来说，水平拆分是对数据表行的拆分，把一张行比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>遇到下面几种场景可以考虑分库分表：</p>
<ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢（分表）。</li>
<li>数据库中数据占用的空间越来越大，备份时间越来越长（分库）。</li>
<li>应用的并发量太大（分库）。</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p><strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作，所以需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</p>
</li>
<li><p><strong>事务问题</strong> ：同一个数据库中的表分布在不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足要求了。</p>
</li>
<li><p><strong>分布式 id</strong> ：分库之后， 数据分布在不同服务器的数据库中，数据库的自增主键已经没办法满足主键唯一了。这时就需要引入分布式 id 为不同的数据节点生成全局唯一主键。</p>
</li>
</ul>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p>
<p>比较简单同时也是非常常用的方案就是<strong>停机迁移</strong>。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>
<p>如果你不想停机迁移数据的话，可以考虑<strong>双写方案</strong>。双写方案针对不能停机迁移的场景，实现起来比较复杂。具体原理是这样的：</p>
<ul>
<li>对老库的更新操作（增删改），同时也要写入新库（双写）。保证新库里的数据是最新的。</li>
<li>双写只会让老库中被更新过的数据同步到新库，还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>
<li>重复上一步的操作，直到老库和新库的数据一致为止。</li>
</ul>
<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p>
<h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/60649996bfc69acb1953063dddf0c2e6.png" alt="img" style="zoom:33%;">

<p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="慢查询的定位及优化"><a href="#慢查询的定位及优化" class="headerlink" title="慢查询的定位及优化"></a>慢查询的定位及优化</h3><p><strong>慢查询日志</strong></p>
<p>开启 MySQL 的<strong>“慢查询日志”</strong>功能，然后稍作配置即可。慢查询日志功能会把查询时间大于设置时间的 SQL 记录下来，并保存到文件中，只需要查看这个文件内容就可以找到对应的慢 SQL 了。</p>
<p><strong>慢查询日志的配置</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>开启或关闭慢查询日志</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="keyword">ON</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>慢查询的时间阈值，<span class="keyword">SQL</span>执行超过此时间则会被记录到日志</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>指定生成的慢查询日志路径</span><br><span class="line">slow_query_log_file <span class="operator">=</span> <span class="operator">/</span>opt<span class="operator">/</span>soft<span class="operator">/</span>mysql<span class="operator">/</span>log<span class="operator">/</span>slow.log</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>是否记录未使用索引的<span class="keyword">SQL</span></span><br><span class="line">log_queries_not_using_indexes<span class="operator">=</span><span class="keyword">on</span></span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<ul>
<li><strong>是否命中索引：</strong>分析语句的执行计划，获得索引使用情况，之后修改语句或者修改索引，使得语句尽可能命中索引。</li>
<li><strong>是否加载了不需要的数据列：</strong>分析语句看看结果是否加载了不需要的列，对语句进行修改。</li>
<li><strong>数据量是否太大：</strong>考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h3 id="行计划-explain"><a href="#行计划-explain" class="headerlink" title="行计划  explain"></a>行计划  explain</h3><p>Mysql 提供了 explain 命令对 SQL 进行分析，只要在 SQL 语句前加上 explain 关键字，就可以得到 SQL 的执行计划，执行计划包含了 SQL 中表的读取顺序、查询类型、使用的索引、使用索引的长度 、扫描了多少条记录等，通过执行计划可以快速定位到哪些地方可以进行优化。</p>
<p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Cimage-20220802165905848.png" alt="image-20220802165905848"></p>
<ul>
<li><strong>select_type</strong>：用于区分查询语句的类型，通过这个列可以区分SQL属于简单的select、联合查询、子查询等。<ul>
<li><strong>SIMPLE：</strong> 简单的 select 查询，不包含任何子查询或联合查询</li>
<li><strong>PRIMARY：</strong> 主查询，如果有子查询的话最外层的查询会被标记为 PRIMARY。</li>
<li><strong>SUBQUERY：</strong> 该语句属于子查询语句。</li>
<li><strong>DERIVED ：</strong> 生成的临时表的查询语句会被标记为 DERIVED 。</li>
<li><strong>UNION ：</strong> 标记为 UNION 类型的查询语句。</li>
<li><strong>UNION RESULT:</strong> 从 UNION 语句中获取结果。</li>
</ul>
</li>
<li>**type (重要)**：通过 type 可以直观的判断 SQL 的性能，type包括以下几种类型： system 、const 、eq_ref、ref、Range、Index、All，他性能依次从高到低。<ul>
<li><strong>System：</strong> 表只有一行记录。</li>
<li><strong>Const：</strong> 通过索引一次就找到了数据，一般出现在使用 primary key 或 unique 索引匹配到了数据，匹配的条件是常量（字符串、数字）。</li>
<li><strong>eq_ref：</strong> 使用了主键索引或非空唯一索引，在表中只有一条记录与索引相匹配，匹配条件是某个表的列。</li>
<li><strong>ref：</strong> 非唯一性索引扫描，和eq_ref 不同的是eq_ref 匹配的是唯一索引，ref它返回所有匹配某个单独值的行,它可能会找到多个符合条件的行。</li>
<li><strong>range：</strong> 范围数据扫描。</li>
<li><strong>index：</strong> 全索引扫描，通过扫描整棵索引树获取到结果。</li>
<li><strong>All：</strong> 全表扫描。</li>
</ul>
</li>
<li><strong>possible_keys:</strong>  可能使用到的索引 。</li>
<li>**key: ** 实际使用到的索引。如果为空，则说明没有使用索引。</li>
<li><strong>key_len：</strong> 使用到的索引 key 的长度，如果为联合索引则显示已命中的联合索引长度之和（如：联合索引为 a + b + c ，如果索引命中了 a + b ，那么长度就为a+b的索引长度，通常可以通过 key_len 来分析联合索引所命中的情况）。</li>
</ul>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul>
<li><strong>前缀索引优化：</strong>当大字符串的字段作为索引时，可以使用前缀索引减小索引项的大小，从而增加一个索引页中存储的索引值，有效提高索引的查询速度。前缀索引有一定的局限性：<ul>
<li>order by 就无法使用前缀索引</li>
<li>无法把前缀索引用作覆盖索引</li>
</ul>
</li>
<li><strong>覆盖索引优化</strong>：使用覆盖索引可以避免回表操作，提高检索速度；同时不需要查询出整行记录，减少了大量的 I&#x2F;O 操作。</li>
<li><strong>主键索引最好是自增的</strong></li>
<li><strong>索引最好设置为 NOT NULL</strong><ul>
<li>索引列存在 NULL 会导致优化器难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为 NULL 的行。</li>
<li>NULL 是一个没意义的值，但是会占用物理空间，带来存储空间的问题，导致更多的存储空间占用</li>
</ul>
</li>
<li><strong>防止索引失效</strong></li>
</ul>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul>
<li><p>**禁止使用SELECT *，必须使用 SELECT &lt;字段列表&gt; 进行查询**，原因如下：</p>
<ul>
<li>消耗更多的 CPU 和 IO 资源</li>
<li>无法使用覆盖索引</li>
</ul>
</li>
<li><p><strong>避免使用子查询，可以把子查询优化为连接查询，因为子查询的性能比连接查询要差</strong>。子查询性能差的原因：</p>
<p><strong>子查询的结果集无法使用索引</strong>，通常子查询的结果集会被存储到临时表中，临时表不存在索引，所以查询性能会受到影响。特别是返回结果集比较大的子查询，其对查询性能的影响也就越大。</p>
</li>
<li><p><strong>避免使用 JOIN 关联太多的表</strong></p>
<ul>
<li>MySQL 是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置</li>
<li>对于同一个 SQL ，多关联一个表，就会多分配一个关联缓存，一个 SQL 中关联的表越多，所占用的内存也就越大。</li>
<li>如果程序中大量使用多表关联的 SQL，同时 join_buffer_size 设置的也不合理，就会造成内存溢出，影响到数据库的稳定性。</li>
</ul>
</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><h3 id="概念和优缺点"><a href="#概念和优缺点" class="headerlink" title="概念和优缺点"></a>概念和优缺点</h3><p>Redis 是基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存、消息队列、分布式锁等场景</strong>。</p>
<p>Redis 提供了多种数据类型，比如 String (字符串)、Hash (哈希)、 List (列表)、Set (集合)、Zset (有序集合)、Bitmaps (位图)、HyperLogLog (基数统计)、GEO (地理信息)、Stream (流)，且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p>
<p>除此之外，Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p>
<p><strong>优点：</strong></p>
<ul>
<li>读写性能极高， Redis 读的速度是 110000 次 &#x2F; s，写的速度是 81000 次 &#x2F; s。</li>
<li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li>
<li>支持事务， Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操<br>作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li>
<li>数据结构丰富，除了支持 string 类型的 value 外，还支持 hash、set、zset、list 等数据结构。<br>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
<li>丰富的特性 – Redis 还支持 publish&#x2F;subscribe（发布&#x2F;订阅模式），通知， key 过期等特性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合用在较小数据量的高性能操作和运算上。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</li>
</ul>
<h3 id="Redis-高速原因"><a href="#Redis-高速原因" class="headerlink" title="Redis 高速原因"></a>Redis 高速原因</h3><ul>
<li><p><strong>内存存储</strong>：Redis 使用内存 (in-memeroy) 存储，没有磁盘 IO 开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)。</p>
</li>
<li><p><strong>单线程实现</strong>（Redis 6.0以前）：Redis 使用单线程处理网络请求，避免了多个线程之间线程切换和锁竞争的开销。</p>
</li>
<li><p><strong>非阻塞IO</strong>：Redis 使用多路 IO 复用技术，将 epoll 作为多路 IO 复用技术的实现，再加上 Redis 自身的事件处理模型，将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I&#x2F;O 上浪费过多时间。</p>
</li>
<li><p>优化的数据结构：Redis 有很多优化的数据结构实现，应用层可以直接使用以提升性能。</p>
</li>
<li><p>使用底层模型不同：Redis 自己构建了 VM (虚拟内存)机制。</p>
</li>
</ul>
<blockquote>
<p>Redis 的 VM (虚拟内存) 机制就是把不经常访问的数据 (冷数据) 从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据 (热数据) 。通过 VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。<br>Redis 提高数据库容量的办法有两种：一种是可以将数据分割到多个 RedisServer 上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。需要特别注意的是Redis并没有使用 OS 提供的 Swap，而是自己实现。</p>
</blockquote>
<h3 id="Redis-和-Memcached-的区别"><a href="#Redis-和-Memcached-的区别" class="headerlink" title="Redis 和 Memcached 的区别"></a>Redis 和 Memcached 的区别</h3><p>Redis 可以用作缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，要弄清楚 Redis 和 Memcached 的区别。</p>
<p>Redis 与 Memcached <strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用做缓存。</li>
<li>都有过期策略。</li>
<li>性能都非常高。</li>
<li>都是分布式缓存。</li>
</ol>
<p>Redis 与 Memcached <strong>区别</strong>：</p>
<ul>
<li><strong>Redis 支持的数据类型更丰富</strong>（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li><strong>Redis 支持数据的持久化</strong>，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li><strong>Redis 有原生的集群模式</strong>，Memcached 没有原生的集群模式；</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能</strong>，而 Memcached 不支持；</li>
<li><strong>网络 IO 模型</strong>：Redis使用单线程的多路 IO 复用模型，Memcached 使用多线程的非阻塞 IO 模式。</li>
<li><strong>Redis 支持服务器端的数据操作</strong>：Memcached 需要将数据拿到客户端修改再set回去，大大增加了网络IO的次数。而 Redis 支持在服务器端进行数据操作。</li>
</ul>
<h3 id="为什么用-Redis-而不用-map-guava-做缓存"><a href="#为什么用-Redis-而不用-map-guava-做缓存" class="headerlink" title="为什么用 Redis 而不用 map&#x2F;guava 做缓存?"></a><strong>为什么用 Redis 而不用 map&#x2F;guava 做缓存?</strong></h3><p>缓存分为本地缓存和分布式缓存，map 和 guava 是本地缓存，特点是轻量以及快速，但是它们的生命周期随着 jvm 的销毁而结束，且在多实例的情况下，每个实例都各自保存一份缓存，缓存不具有一致性。<br>Redis 是<strong>分布式缓存</strong>，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 Redis 服务的高可用，架构上较为复杂。</p>
<p><strong>对比:</strong></p>
<ul>
<li>Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 最多分几个 G 内存；</li>
<li>Redis <strong>缓存可以持久化</strong>，Map 是内存对象，程序一重启数据就没了；</li>
<li>Redis 是<strong>分布式缓存</strong>，Map 是本地缓存；</li>
<li>Redis 每秒可以处理百万级并发，Map 只是一个普通的对象；</li>
<li>Redis 缓存<strong>有过期机制</strong>，Map 没有；</li>
<li>Redis 可单独部署，多个项目之间可以共享，本地内存无法共享；</li>
<li>Redis 有专门的管理工具可以查看缓存数据</li>
</ul>
<h3 id="使用-Redis-缓存的原因"><a href="#使用-Redis-缓存的原因" class="headerlink" title="使用 Redis 缓存的原因"></a>使用 Redis 缓存的原因</h3><p>因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p>
<p><em><strong>1、高性能</strong></em></p>
<p>用户第一次访问 MySQL 中的数据会比较慢，因为需要从硬盘中读取。将用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据时就可以直接从Redis 缓存中获取，<strong>操作 Redis 缓存就是直接操作内存，速度相当快</strong>。</p>
<p><em><strong>2、高并发</strong></em></p>
<p>Redis 的 QPS 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p>
<p><strong>直接操作缓存能够承受的请求是远远大于直接访问数据库的</strong>，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h3 id="数据类型和使用场景"><a href="#数据类型和使用场景" class="headerlink" title="数据类型和使用场景"></a>数据类型和使用场景</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/五种数据类型.png" alt="img" style="zoom: 50%;">

<p>后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。</p>
<p>Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流）</p>
<p><strong>应用场景</strong></p>
<p>Redis 五种数据类型的应用场景：</p>
<ul>
<li>String 类型：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型：消息队列。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
</ul>
<p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p>
<ul>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
<h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><p>这五种数据类型都由多种数据结构实现的，主要是出于时间和空间的考虑，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。</p>
<p>这五种数据类型与底层数据结构对应关系图如下</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/9fa26a74965efbf0f56b707a03bb9b7f.png" alt="img" style="zoom: 50%;">

<h4 id="SDS（String的底层结构）"><a href="#SDS（String的底层结构）" class="headerlink" title="SDS（String的底层结构）"></a>SDS（String的底层结构）</h4><p><strong>C语言字符串的缺陷</strong></p>
<ul>
<li>**获取字符串长度的时间复杂度为O(N)**。C语言的字符数组以”\0”结尾，获取字符串长度就是从头开始遍历到”\0”结束，然后统计字符的个数。</li>
<li><strong>只能保存文本数据，不能保存像图片、音频、视频这样的二进制数据。</strong>因为除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾。</li>
<li><strong>C 语言的字符串是不会记录自身的缓冲区大小的，在拼接字符串的时候可能会造成缓冲区溢出</strong>。</li>
</ul>
<p><strong>SDS结构设计</strong></p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/image-20220818081642889.png" alt="image-20220818081642889" style="zoom: 50%;">

<ul>
<li><strong>SDS的成员变量</strong><ul>
<li><strong>len：</strong>记录了字符串的长度</li>
<li><strong>alloc：</strong>记录了分配给字符数组的空间长度</li>
<li><strong>flags：</strong>用来表示不同类型的SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64</li>
<li>**buf[]**：字符数组，用来保存实际数据</li>
</ul>
</li>
<li><strong>SDS相比于C的改进</strong><ul>
<li><strong>O(1)时间复杂度获取字符串长度</strong>。通过len属性直接返回字符串长度</li>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>使用len属性来记录长度，所以可存储包含 “\0” 的数据</strong>。</li>
<li><strong>不会发生缓冲区溢出</strong>。在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话Redis会自动扩大SDS的空间大小(<strong>小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容</strong>)，然后才执行实际的修改操作，避免发生缓冲区溢出。</li>
<li><strong>节省内存空间</strong>。SDS的flags有5种类型，这 5 种类型的主要<strong>区别就在于它们的len和alloc的数据类型不同</strong>，如sdshdr16其数据类型为16位，sdshdr32则是32位。<strong>SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong></li>
</ul>
</li>
</ul>
<h4 id="哈希表（hash和set的底层结构）"><a href="#哈希表（hash和set的底层结构）" class="headerlink" title="哈希表（hash和set的底层结构）"></a>哈希表（hash和set的底层结构）</h4><ul>
<li><p><strong>底层存储</strong>：底层采用数组+链表的形式存储元素，采用拉链法解决哈希冲突</p>
</li>
<li><p><strong>rehash：</strong>哈希结构体内部定义了两个哈希表，在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<ul>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
<li><strong>存在的问题：如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong></li>
</ul>
</li>
<li><p><strong>渐进式hash</strong>：为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。渐进式 rehash 步骤如下：</p>
<ul>
<li>给「哈希表 2」分配空间，<strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会依次将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong></li>
<li>在此期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。查找、删除和更新操作时，会先去「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。<strong>所有的添加操作都会直接添加到「哈希表 2」上</strong></li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</li>
</ul>
</li>
<li><p><strong>rehash触发条件</strong>：rehash 的触发条件跟<strong>负载因子（load factor）</strong>有关系，负载因子&#x3D;哈希表已保存节点数量&#x2F;哈希表大小。触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作</strong></li>
</ul>
</li>
</ul>
<h4 id="跳表（zset的底层结构）"><a href="#跳表（zset的底层结构）" class="headerlink" title="跳表（zset的底层结构）"></a>跳表（zset的底层结构）</h4><ul>
<li><strong>定义：</strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是<strong>能快读定位数据。</strong></li>
<li><strong>底层实现</strong><ul>
<li>跳表结构包含了：<ul>
<li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li>
<li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li>
<li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量</li>
</ul>
</li>
<li>每个Zset元素包括以下几部分：<ul>
<li>元素值ele、元素权重值score、后向指针。其中后向指针指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</li>
<li><strong>level数组</strong>：跳表的特性是通过一个<strong>zskiplistLevel 结构体类型的 level 数组</strong>来实现的，level数组中的每一个元素代表跳表的一层，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</li>
<li><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</li>
</ul>
</li>
</ul>
</li>
<li><strong>跳表节点的查询过程</strong><ul>
<li>跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的元素和权重来进行判断：如果当前节点的权重「小于」要查找的权重，或者当前节点的权重「等于」要查找的权重，并且当前节点的元素「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
<li>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</li>
</ul>
</li>
</ul>
<h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p>6.0 以前使用单线程模型处理网络 IO 和执行命令，6.0 以后使用单线程模型执行命令，多线程模型处理网络 IO，<strong>回答时只说单线程模型</strong></p>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;数据读写-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
</li>
<li><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过<strong>多路 IO 复用</strong> 来监听客户端的大量连接（或者说是监听多个 socket），它会将事件注册到内核中并监听每个事件是否发生。<strong>I&#x2F;O 多路复用技术让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
</li>
<li><p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p>
<ul>
<li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li>
<li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来<strong>异步释放 Redis 内存</strong>，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要<strong>删除一个大 key 的时候，不要使用 del 命令删除</strong>，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该<strong>使用 unlink 命令来异步删除大key</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p> <strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的<strong>文件事件处理器（file event handler）。由于</strong>文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p> Redis 服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件; 2. 时间事件。</p>
</blockquote>
<p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p>
<p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/后台线程.jpg" alt="img" style="zoom: 33%;">

<p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p>
<ul>
<li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li>
<li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li>
<li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 &#x2F; free(dict) 删除数据库所有对象 &#x2F; free(skiplist) 释放跳表对象；</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Redis 初始化的时候，会做下面这几件事情：</p>
<ul>
<li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 一个服务端 socket</li>
<li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li>
<li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li>
</ul>
<p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情：</p>
<ul>
<li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li>
<li>接着，调用 epoll_wait 函数等待事件的到来：<ul>
<li>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li>
<li>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li>
<li>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li>
</ul>
</li>
</ul>
<p>Redis 6.0 版本之前的单线模式如下图：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/redis单线程模型.drawio.png" alt="img" style="zoom:50%;">

<p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I&#x2F;O 和命令处理都是单线程。 </p>
<h4 id="单线程仍然高速的理由"><a href="#单线程仍然高速的理由" class="headerlink" title="单线程仍然高速的理由"></a>单线程仍然高速的理由</h4><p><strong>QPS</strong>：全名 Queries Per Second，意思是“每秒查询率”，是一台服务器每秒能够响应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W&#x2F;每秒</strong></p>
<ul>
<li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li>
<li>Redis 采用单线程模型<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li>
<li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是我们经常听到的 select&#x2F;epoll 机制。该机制允许内核中同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，实现一个 Redis 线程处理多个 IO 流的效果。</li>
</ul>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><strong>Redis 6.0 版本引入的多线程处理网络IO</strong></p>
<h4 id="Redis-6-0-之前为什么使用单线程"><a href="#Redis-6-0-之前为什么使用单线程" class="headerlink" title="Redis 6.0 之前为什么使用单线程"></a>Redis 6.0 之前为什么使用单线程</h4><p>我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I&#x2F;O 和执行命令）为什么还要使用单线程呢？</p>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li><strong>Redis 的性能瓶颈不在 CPU ，主要在内存和网络</strong>；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
<h4 id="Redis-6-0-之后为什么引入多线程"><a href="#Redis-6-0-之后为什么引入多线程" class="headerlink" title="Redis 6.0 之后为什么引入多线程"></a>Redis 6.0 之后为什么引入多线程</h4><p><strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</strong>。</p>
<p>所以为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。<strong>但是对于命令的执行，Redis 仍然使用单线程来处理</strong>，因此，也不需要担心线程安全问题。</p>
<p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上</strong></p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><h3 id="数据不丢失"><a href="#数据不丢失" class="headerlink" title="数据不丢失"></a>数据不丢失</h3><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p>
<p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li><strong>AOF 日志</strong>：每执行一条<strong>写操作命令</strong>，就把该命令以追加的方式写入到一个文件里；</li>
<li><strong>RDB 快照</strong>：将某一时刻的内存数据以二进制的方式写入磁盘；</li>
<li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li>
</ul>
<h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img" style="zoom:50%;">

<h4 id="先执行命令的好处和坏处"><a href="#先执行命令的好处和坏处" class="headerlink" title="先执行命令的好处和坏处"></a>先执行命令的好处和坏处</h4><p>Redis 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p>
<ul>
<li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li>
</ul>
<p>当然，这样做也会带来风险：</p>
<ul>
<li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li>
<li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li>
</ul>
<h4 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h4><p>Redis 提供了 3 种写回硬盘的策略，<strong>控制内核缓冲区写入到硬盘的时间</strong>。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/98987d9417b2bab43087f45fc959d32a.png" alt="img" style="zoom: 50%;">

<p>Redis 写入 AOF 日志的过程，如下图：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png" alt="img" style="zoom:50%;">

<p>具体说说：</p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><blockquote>
<p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
</blockquote>
<p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是<strong>在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</strong>。</p>
<p><strong>过程</strong></p>
<p>①触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会<strong>读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</strong>（新的 AOF 文件）。</p>
<blockquote>
<p>Redis 的<strong>重写 AOF 过程是由&#x3D;&#x3D;后台子进程&#x3D;&#x3D; bgrewriteaof来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li><strong>子进程进行 AOF 重写期间，主进程可以继续处理命令请求</strong>，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，**创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生&#x3D;&#x3D;「写时复制」&#x3D;&#x3D;**，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>但是重写过程中，主进程依然可以正常处理命令，那问题来了，重写 AOF 日志过程中，<strong>如果主进程修改了已经存在 key-value</strong>，那么会发生写时复制，此时这个 key-value 数据在<strong>子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</strong></p>
</blockquote>
<p>②为了解决<strong>重写 AOF 日志过程中，主进程修改了已经存在 key-value</strong>的这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<blockquote>
<p>在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 <strong>AOF 重写缓冲区</strong>中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>
</blockquote>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/202105270918298.png" alt="img" style="zoom:50%;">

<h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>因为 <strong>AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢</strong></p>
<blockquote>
<p>为了解决这个问题，Redis 增加了 RDB 快照。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。</p>
</blockquote>
<p>所以，<strong>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据</strong>，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<h4 id="RDB-做快照时会阻塞线程吗"><a href="#RDB-做快照时会阻塞线程吗" class="headerlink" title="RDB 做快照时会阻塞线程吗"></a>RDB 做快照时会阻塞线程吗</h4><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<blockquote>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p>
<ul>
<li>900 秒之内，对数据库进行了至少 1 次修改；</li>
<li>300 秒之内，对数据库进行了至少 10 次修改；</li>
<li>60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
</blockquote>
<h4 id="RDB-在执行快照的时候，数据能修改吗？"><a href="#RDB-在执行快照的时候，数据能修改吗？" class="headerlink" title="RDB 在执行快照的时候，数据能修改吗？"></a>RDB 在执行快照的时候，数据能修改吗？</h4><p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/c34a9d1f58d602ff1fe8601f7270baa7.png" alt="img" style="zoom: 50%;">

<p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/ebd620db8a1af66fbeb8f4d4ef6adc68.png" alt="img" style="zoom: 50%;">

<p><strong>数据丢失：</strong></p>
<p>Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主线程的内存数据和子线程的内存数据已经分离了，<strong>子线程写入到 RDB 文件的内存数据只能是原本（修改前）的内存数据</strong>。</p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p><strong>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</strong></p>
<p><strong>AOF 优点是丢失数据少，但是数据恢复不快。</strong></p>
<p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主进程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主进程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/f67379b60d151262753fec3b817b8617.png" alt="img" style="zoom: 50%;">

<p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</li>
</ul>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p>单机Redis存在单点风险问题，如果Redis宕机，会导致大量请求直接落到数据库，造成数据库压力过大。<strong>如果保证Redis服务的高可用？</strong></p>
<p>① <strong>主从复制</strong>：基于主从复制搭建一个Redis集群，主节点master负责处理写请求，从节点slave负责处理读请求，master宕机时从slave中选出一台作为master即可。</p>
<p>② **Redis Sentinel(哨兵模式)**：基于主从复制的Redis集群解决方案，用于解决集群主从节点的故障切换问题。</p>
<p>③ **Redis Cluster(切片集群)**：Redis Sentinel方案主要提高了Redis集群的可用性和读吞吐量，并不能缓解写压力以及解决缓存数据量过大的问题，此时就需要用到Redis分片集群了。</p>
<h3 id="集群方式"><a href="#集群方式" class="headerlink" title="集群方式"></a>集群方式</h3><h4 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h4><p>将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点 (master)，后者称为从节点 (slave)，数据的复制是单向的，只能由主节点到从节点。</p>
<p>所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。主从服务器之间的命令复制是<strong>异步</strong>进行的。具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，<strong>主从服务器间的数据就不一致了</strong>。</p>
<p><strong>作用</strong></p>
<ul>
<li><strong>数据冗余：</strong>主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复</li>
<li><strong>读写分离：</strong>可以用于实现读写分离，主库写、从库读</li>
<li><strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
</ul>
<p><strong>主从数据同步</strong></p>
<ul>
<li><p><strong>全量同步</strong></p>
<p>Redis 全量同步发生在 Slave 初始化阶段，这时 Slave 需要将 Master 上的所有数据都复制一份。具体步骤如下：</p>
<ul>
<li>当一个从库启动时，从库给主库发送 psync 命令进行数据同步</li>
<li>当主库接收到 psync 命令后就会保存 RDB 文件并发送给从库，发送期间会使用 replication buffer 记录后续的所有写操作 ，从库收到数据后，会先清空当前数据库，然后加载从主库获取的RDB 文件。</li>
<li>当主库完成 RDB 文件发送后，再把将保存发送RDB文件期间写操作的 replication buffer 发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</li>
</ul>
</li>
<li><p><strong>增量同步</strong></p>
<p>Redis 增量同步是指 Slave 初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程，主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
</li>
</ul>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="img" style="zoom: 50%;">

<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>Redis 的主从服务器如果出现故障宕机，需要手动恢复。为了解决这个问题，Redis 增加了哨兵模式（<strong>Redis Sentinel</strong>），哨兵模式可以监控主从服务器，并提供<strong>主从节点故障转移功能。</strong></p>
<p><strong>作用</strong></p>
<ul>
<li><strong>监控：</strong>监控所有 Redis 节点的状态是否正常</li>
<li><strong>通知：</strong>可以通过 API 通知系统管理员或者其他计算机程序，其中一个受监控的 Redis 实例出现问题</li>
<li><strong>故障切换：</strong>如果一个 master 出现故障，Sentinel 会进行故障切换，自动将一台 slave 升级为 master，确保整个 Redis 系统的可用性</li>
</ul>
<p><strong>多哨兵模式</strong></p>
<p>只用一个哨兵监控 Redis 服务器可能会出现问题，让<strong>多个哨兵通过投票的方式来确定 Redis 服务器是否真的不可用，可以避免误判</strong>。这些哨兵中会有一个 <strong>Leader 来负责故障切换</strong>。Leader 的选取主要用到分布式领域的共识算法，共识算法就是让分布式系统中的节点就一个问题达成共识，哨兵选取 Leader 使用的是 <strong>Raft 算法</strong>。</p>
<p><strong>故障切换的过程</strong></p>
<p>假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行切换过程，当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，最终由 Leader 来进行切换操作。切换成功后，就会通过<strong>发布订阅</strong>模式，让各个哨兵把自己监控的从服务器实现切换主机。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/26f88373d8454682b9e0c1d4fd1611b4.png" alt="img" style="zoom: 50%;">

<h4 id="切片集群模式"><a href="#切片集群模式" class="headerlink" title="切片集群模式"></a>切片集群模式</h4><p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p>
<p><strong>定义和作用</strong></p>
<p>主从复制和 Redis 哨兵本质上是通过增加副本的方式提高 Redis 服务的可用性和读吞吐量，这两种方案都不支持横向扩展来<strong>缓解写压力以及解决缓存数据量过大的问题</strong>，如果写压力太大或缓存数据量太大可以采用 Redis 切片集群。<strong>Redis 切片集群就是部署多台 Redis 实例，这些 Redis 实例没有主从之分，同时对外提供读&#x2F;写服务，缓存的数据相对均匀地分布在这些 Redis 实例上</strong>。</p>
<p><strong>Redis Cluster</strong></p>
<ul>
<li>Redis Cluster是Redis3.0提出的分片集群解决方案，通过分片来进行数据管理，采用的是<strong>虚拟槽分区</strong>，每一个键值对都属于一个**hash slot(虚拟槽)**，虚拟槽均匀的分布在多个Redis实例上。</li>
<li>当要读取数据时只需要计算出对应key所在的虚拟槽即可；Redis Cluster是去中心化的，任何一个Redis实例宕机其他实例不受影响；当要新增Redis实例时只需要将一些虚拟槽从已有的实例中移动过去。</li>
<li><strong>虚拟槽分区机制解耦了数据与节点之间的关系，提升了集群的横向扩展性和容错性</strong>。</li>
<li>Redis Cluster是一个典型的分布式系统，各个节点需要互相通信，基于<strong>Gossip协议</strong>来实现数据的最终一致性(每个Redis节点都维护了一份集群的状态信息)</li>
</ul>
<p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p>
<ul>
<li>根据键值对的 key，按照 CRC16（<strong>循环校验码（CRC码）</strong>） 算法计算一个 16 bit 的值。</li>
<li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li>
</ul>
<p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p>
<ul>
<li><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384&#x2F;9 个。</li>
<li><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li>
</ul>
<p><strong>数据、哈希槽，以及节点三者的映射分布关系</strong></p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/笔记/八股笔记.assets/redis切片集群映射分布关系.jpg" alt="img" style="zoom: 50%;">

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.10 –p 6379 cluster addslots 0,1</span><br><span class="line">redis-cli -h 192.168.1.11 –p 6379 cluster addslots 2,3</span><br></pre></td></tr></table></figure>

<p>然后在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到对应的节点 1 和节点 2 上了。</p>
<p>需要注意的是，在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</p>
<h3 id="集群脑裂"><a href="#集群脑裂" class="headerlink" title="集群脑裂"></a>集群脑裂</h3><h4 id="脑裂定义"><a href="#脑裂定义" class="headerlink" title="脑裂定义"></a>脑裂定义</h4><p>由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p>
<p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 <strong>如果主节点的网络突然发生了问题，它与所有的从节点都失联了</strong>，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p>
<blockquote>
<p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是<strong>哨兵就会在「从节点」中选举出一个 leeder 作为主节点</strong>，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>当主节点发现从节点下线或者通信超时的总数量大于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<p>在 Redis 的配置文件中有两个参数我们可以设置：</p>
<ul>
<li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li>
<li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p>
<p>这两个配置项组合后的要求是，<strong>主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</strong></p>
<p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p>
<blockquote>
<p>再来举个例子。</p>
<p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。</p>
<p>同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。</p>
<p>这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p>
</blockquote>
<h2 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h2><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>先说一下对 key 设置过期时间的命令。 设置 key 过期时间的命令一共有 4 个：</p>
<ul>
<li><code>expire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 秒后过期，比如 expire key 100 表示设置 key 在 100 秒后过期。</li>
<li><code>pexpire &lt;key&gt; &lt;n&gt;</code>：设置 key 在 n 毫秒后过期，比如 pexpire key2 100000 表示设置 key2 在 100000 毫秒（100 秒）后过期。</li>
<li><code>expireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到秒）之后过期，比如 expireat key3 1655654400 表示 key3 在时间戳 1655654400 后过期（精确到秒）；</li>
<li><code>pexpireat &lt;key&gt; &lt;n&gt;</code>：设置 key 在某个时间戳（精确到毫秒）之后过期，比如 pexpireat key4 1655654400000 表示 key4 在时间戳 1655654400000 后过期（精确到毫秒）</li>
</ul>
<h3 id="判定过期"><a href="#判定过期" class="headerlink" title="判定过期"></a>判定过期</h3><p>如果对 key 设置了过期时间，Redis 就会把这个 key 带上过期时间存储到<strong>过期字典</strong>中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p>
<p>字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。</p>
<p>查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与系统时间进行对比，如果没有过期就读取。</li>
</ul>
<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配合使用。</p>
<p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p>
<ul>
<li>定时删除；</li>
<li>惰性删除；</li>
<li>定期删除；</li>
</ul>
<h4 id="定时删除策略"><a href="#定时删除策略" class="headerlink" title="定时删除策略"></a>定时删除策略</h4><p>定时删除策略的做法是，<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></p>
<p><strong>优点</strong>：可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。</p>
<p><strong>缺点</strong>：在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。</p>
<h4 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h4><p>惰性删除策略：<strong>不主动删除过期键，每次访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p>
<p><strong>优点</strong>：因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</p>
<p><strong>缺点</strong>：如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</p>
<h4 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h4><p>定期删除策略：<strong>每隔一段时间「随机」取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p>
<p><strong>优点</strong>：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。</li>
<li>难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li>
</ul>
<h4 id="Redis使用的过期删除策略"><a href="#Redis使用的过期删除策略" class="headerlink" title="Redis使用的过期删除策略"></a>Redis使用的过期删除策略</h4><p>惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p>
<p>Redis 的惰性删除流程：</p>
<p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与系统时间进行对比，如果没有过期就读取。</li>
</ul>
<p>Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个，也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<h3 id="持久化时的过期内存处理"><a href="#持久化时的过期内存处理" class="headerlink" title="持久化时的过期内存处理"></a>持久化时的过期内存处理</h3><p>Redis 持久化文件有两种格式：AOF（Append Only File）和 RDB（Redis Database）</p>
<p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p>
<ul>
<li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li>
<li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li>
</ul>
<p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p>
<ul>
<li><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</li>
<li>RDB 加载阶段：要看服务器是主服务器还是从服务器，分别对应以下两种情况：<ul>
<li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<h3 id="主从模式的过期内存处理"><a href="#主从模式的过期内存处理" class="headerlink" title="主从模式的过期内存处理"></a>主从模式的过期内存处理</h3><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p>
<h2 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h2><p>过期删除策略是删除已过期的 key，而当 Redis 的运行内存已经超过设置的最大内存之后，就会使用内存淘汰策略删除符合条件的 key。</p>
<p> 在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><strong>1、不进行数据淘汰的策略</strong></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：当运行内存超过设置的最大内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p>
<p><strong>2、进行数据淘汰的策略</strong></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 </p>
<p><strong>在设置了过期时间的数据中进行淘汰</strong>：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>：<strong>淘汰所有设置了过期时间的键值中最久未使用的键值</strong>；</li>
<li><strong>volatile-lfu</strong>：淘汰所有设置了过期时间的键值中最少使用的键值；</li>
</ul>
<p><strong>在所有数据范围内进行淘汰</strong>：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰所有键值中最久未使用的键值；</li>
<li><strong>allkeys-lfu</strong>：淘汰所有键值中最少使用的键值。</li>
</ul>
<h3 id="LRU和LFU"><a href="#LRU和LFU" class="headerlink" title="LRU和LFU"></a>LRU和LFU</h3><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p>
<p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，<strong>最新操作的键会被移动到表头</strong>，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<h4 id="Redis-LRU"><a href="#Redis-LRU" class="headerlink" title="Redis LRU"></a>Redis LRU</h4><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<h4 id="Redis-LFU"><a href="#Redis-LFU" class="headerlink" title="Redis LFU"></a>Redis LFU</h4><p><strong>最不经常使用</strong>(最少次)算法（Least Frequently Used）</p>
<p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/lru字段.png" alt="img" style="zoom: 50%;">

<h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存异常（缓存雪崩、缓存击穿、缓存穿透）"><a href="#缓存异常（缓存雪崩、缓存击穿、缓存穿透）" class="headerlink" title="缓存异常（缓存雪崩、缓存击穿、缓存穿透）"></a>缓存异常（缓存雪崩、缓存击穿、缓存穿透）</h3><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/061e2c04e0ebca3425dd75dd035b6b7b.png" alt="图片" style="zoom:67%;">

<h3 id="如何避免缓存雪崩"><a href="#如何避免缓存雪崩" class="headerlink" title="如何避免缓存雪崩"></a>如何避免缓存雪崩</h3><p>缓存雪崩：<strong>大量缓存数据在同一时间过期，如果此时有大量的请求，就都无法在 Redis 中处理，于是全部请求都直接访问数据库，导致数据库的压力骤增，严重的会造成数据库宕机</strong>。</p>
<p>对于缓存雪崩问题，可以采用两种方案解决。</p>
<ul>
<li><p><strong>均匀设置过期时间：</strong> 可以在原有的失效时间基础上增加一个随机值，这样每个缓存的过期时间就不重复了，能够降低缓存集体失效的概率。</p>
</li>
<li><p><strong>互斥锁：</strong>处理请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求数据库来构建缓存</strong>，当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
</li>
<li><p><del><strong>设置缓存不过期：</strong> 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。(<strong>内存淘汰策略</strong>)</del></p>
<blockquote>
<p> 实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><em>后台更新缓存</em></p>
<p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p>
<p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p>
<p>解决上面的问题的方式有两种。</p>
<p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</p>
<p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p>
<p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p>
<p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p>
</blockquote>
<h3 id="如何避免缓存击穿"><a href="#如何避免缓存击穿" class="headerlink" title="如何避免缓存击穿"></a>如何避免缓存击穿</h3><p>数据库中会有一些数据被频繁地访问，称为热点数据。</p>
<p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量请求访问该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>。</p>
<p>缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩的一个子集。 可以采取下面两种方案：</p>
<ul>
<li><strong>互斥锁方案</strong>，保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li><strong>不给热点数据设置过期时间</strong>，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<h3 id="如何避免缓存穿透"><a href="#如何避免缓存穿透" class="headerlink" title="如何避免缓存穿透"></a>如何避免缓存穿透</h3><p>缓存穿透就是用户访问的数据<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。如果<strong>有大量这样的请求</strong>，数据库的压力就会骤增。</p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li><strong>非法请求的限制</strong>：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li>
<li><strong>设置空值或者默认值</strong>：针对发生缓存穿透的数据，可以在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li>
<li><strong>使用布隆过滤器快速判断数据是否存在</strong>：向数据库写入数据时，使用布隆过滤器做个标记，用户请求可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，保证数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p>
<blockquote>
<p> 布隆过滤器会通过 3 个操作完成标记：</p>
<ul>
<li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ul>
</blockquote>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p>
<h3 id="动态缓存热点数据"><a href="#动态缓存热点数据" class="headerlink" title="动态缓存热点数据"></a>动态缓存热点数据</h3><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而<strong>只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p>
<p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p>
<p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p>
<ul>
<li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li>
<li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li>
<li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li>
</ul>
<p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>常见的缓存更新策略共有3种：</p>
<ul>
<li>Cache Aside（旁路缓存）策略；</li>
<li>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略；</li>
<li>Write Back（写回）策略；</li>
</ul>
<p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。</p>
<h4 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h4><p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/6e3db3ba2f829ddc14237f5c7c00e7ce.png" alt="img" style="zoom: 50%;">

<p><strong>写策略的步骤：</strong></p>
<ul>
<li>先更新数据库中的数据，再删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<p>注意，写策略的步骤的顺序顺序不能倒过来，即<strong>不能先删除缓存再更新数据库</strong>，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。</p>
<blockquote>
<p><strong>为什么「先更新数据库再删除缓存」不会有数据不一致的问题？</strong></p>
<p>继续用「读 + 写」请求的并发的场景来分析。</p>
<p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。 从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p>
<p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p>
</blockquote>
<p><strong>Cache Aside 策略适合读多写少的场景，不适合写多的场景</strong>，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p>
<ul>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li>
</ul>
<h4 id="Read-Write-Through（读穿-写穿）策略"><a href="#Read-Write-Through（读穿-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h4><p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p>
<p><em><strong>1、Read Through 策略</strong></em></p>
<p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p>
<p><em><strong>2、Write Through 策略</strong></em></p>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul>
<li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li>
<li>如果缓存中数据不存在，直接更新数据库，然后返回；</li>
</ul>
<p>Read Through&#x2F;Write Through 策略的特点是由缓存节点而非应用程序来和数据库打交道，在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都不提供写入数据库和自动加载数据库中的数据的功能。而我们在使用本地缓存的时候可以考虑使用这种策略。</p>
<h4 id="Write-Back（写回）策略"><a href="#Write-Back（写回）策略" class="headerlink" title="Write Back（写回）策略"></a>Write Back（写回）策略</h4><p>Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p>
<p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p>
<p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p>
<p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p>
<p><strong>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险</strong>，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p>
<h2 id="缓存与数据库的一致性"><a href="#缓存与数据库的一致性" class="headerlink" title="缓存与数据库的一致性"></a>缓存与数据库的一致性</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>​		当我们更新数据库中的数据时，需要同步Redis中缓存的数据，常用的两种方法是：先更新数据库再删除缓存、先删除缓存再更新数据库，无论是哪种方法在并发情况下都会出现<strong>缓存与数据库的数据不一致问题</strong>，举例如下：</p>
<ul>
<li>先更新数据库，再删除缓存：请求1进行更新操作，更新数据库后，还未来得及进行缓存清除，此时请求2查询同一条数据，会查到redis中缓存的旧数据</li>
<li>先删除缓存，再更新数据库：请求1进行更新操作，执行缓存删除后，还未更新数据库的数据，此时请求2查询同一条数据，由于缓存中没有对应数据，直接查到了数据库中的旧数据，并就其写入redis</li>
</ul>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h4><p>延迟双删的步骤如下：① 先删除缓存 ② 更新数据库 ③ 延迟一段时间再删除缓存</p>
<p>延迟时间怎么设置：</p>
<p>延迟时间应该大于一次读请求的时间，这么做的目的是确保其他的读请求结束，当前写请求可以删除读请求造成的缓存脏数据。</p>
<h4 id="异步更新缓存-基于订阅binlog的同步机制"><a href="#异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="异步更新缓存(基于订阅binlog的同步机制)"></a>异步更新缓存(基于订阅binlog的同步机制)</h4><p>​		通过订阅binlog，使用消息队列将MySQL的增、删、改操作推送到Redis，Redis再根据binlog中的记录，对Redis进行更新，实现异步更新缓存。通常是采用canal+kafka来实现</p>
<h1 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h1><h2 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h2><h3 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h3><p>可以把消息队列看作是一个<strong>存放消息的容器</strong>，需要使用消息时，直接从容器中取出消息使用即可。</p>
<p>消息队列是分布式系统中重要的组件之一。使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。</p>
<p>队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p>
<h3 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h3><p>消息队列能为我们的系统带来下面三点好处：</p>
<ol>
<li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li>
<li><strong>削峰&#x2F;限流</strong></li>
<li><strong>降低系统耦合性。</strong></li>
</ol>
<h4 id="通过异步处理提高系统性能（减少响应所需时间）"><a href="#通过异步处理提高系统性能（减少响应所需时间）" class="headerlink" title="通过异步处理提高系统性能（减少响应所需时间）"></a>通过异步处理提高系统性能（减少响应所需时间）</h4><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能" style="zoom:67%;">

<p>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费。</p>
<p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>。</p>
<blockquote>
<p>比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
</blockquote>
<h4 id="削峰-限流"><a href="#削峰-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h4><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></p>
<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/削峰-消息队列.png" alt="削峰" style="zoom: 25%;">



<h4 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h4><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/消息队列-解耦.png" alt="解耦" style="zoom:67%;">



<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</p>
<p><strong>消息队列使用&#x3D;&#x3D;发布-订阅模式&#x3D;&#x3D;工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<h3 id="消息队列的问题"><a href="#消息队列的问题" class="headerlink" title="消息队列的问题"></a>消息队列的问题</h3><ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后就需要考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h2 id="消息队列规范"><a href="#消息队列规范" class="headerlink" title="消息队列规范"></a>消息队列规范</h2><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>JMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p><strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p>
<h4 id="JMS消息模型"><a href="#JMS消息模型" class="headerlink" title="JMS消息模型"></a>JMS消息模型</h4><p><strong>① 点到点（P2P）模型</strong></p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/队列模型23.png" alt="队列模型" style="zoom:67%;">

<p>使用<strong>队列（Queue）作为消息通信载体；满足生产者与消费者模式</strong>，支持多个消费者，但一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>② 发布&#x2F;订阅（Pub&#x2F;Sub）模型</strong></p>
<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/res/发布订阅模型.png" alt="发布订阅模型" style="zoom:67%;">

<p>发布订阅模型（Pub&#x2F;Sub） 使用 <strong>Topic 作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过 topic 传递给所有的订阅者，</strong>在一条消息广播之后才订阅的用户是收不到该条消息的。</p>
<h4 id="JMS消息正文模式"><a href="#JMS消息正文模式" class="headerlink" title="JMS消息正文模式"></a>JMS消息正文模式</h4><p>JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java 原始值的数据流</li>
<li>MapMessage–一套名称-值对</li>
<li>TextMessage–一个字符串对象</li>
<li>ObjectMessage–一个序列化的 Java 对象</li>
<li>BytesMessage–一个字节的数据流</li>
</ul>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th align="center">对比方向</th>
<th align="left">JMS</th>
<th align="left">AMQP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="left">Java API</td>
<td align="left">协议</td>
</tr>
<tr>
<td align="center">跨语言</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="center">跨平台</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="center">支持消息类型</td>
<td align="left">提供两种消息模型：①Peer-2-Peer;②Pub&#x2F;sub</td>
<td align="left">提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub&#x2F;sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td align="center">支持消息类型</td>
<td align="left">支持多种消息类型 ，我们在上面提到过</td>
<td align="left">byte[]（二进制）</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li>
<li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可<strong>序列化</strong>后发送）。</li>
<li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题&#x2F;订阅 方式两种。</li>
</ul>
<h2 id="常见消息队列对比"><a href="#常见消息队列对比" class="headerlink" title="常见消息队列对比"></a>常见消息队列对比</h2><p><img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5Ccb7df4942684886ee759dbb10d4bd760.png" alt="img"></p>
<table>
<thead>
<tr>
<th>对比 方向</th>
<th>概要</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。</td>
</tr>
<tr>
<td>可用性</td>
<td>都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>时效性</td>
<td>RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。</td>
</tr>
<tr>
<td>功能支持</td>
<td>除了 Kafka，其他三个功能都较为完备。 <strong>Kafka 功能较为简单，主要支持简单的 MQ 功能</strong>，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
</tr>
<tr>
<td>消息丢失</td>
<td>ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的</li>
<li>Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有<strong>可能消息重复消费</strong>，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<h2 id="保证消息的消费顺序"><a href="#保证消息的消费顺序" class="headerlink" title="保证消息的消费顺序"></a>保证消息的消费顺序</h2><p>分区中的消息是有序的，不同分区之间的消息无法保证其有序性，因此要想严格保证消息的消费顺序，需要将消息放入同一个分区中</p>
<ul>
<li>一个topic一个partition，不推荐，背离了kafka设计的初衷</li>
<li>**发送消息的时候将消息的key设为相同(推荐)**。当producer发送数据的时候如果没有指定分区，则会根据key % (partition的数量)的方式来确定消息的分区，相同的key会被分配到相同的分区。</li>
</ul>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p><strong>LEO</strong>：每个副本中Log文件的最后一个offset</p>
<p><strong>HW：</strong>所有副本中最小的LEO</p>
<p><strong>ISR</strong>（In-Sync Replicas）：能够和 leader 保持同步的 follower + leader本身 组成的集合。</p>
<ul>
<li><p><strong>follower故障</strong></p>
<p>follower 发生故障后会被临时踢出 ISR（动态的同步副本集合 ），待该 follower 恢复后，follower 会读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。等该 <strong>follower</strong> <strong>的</strong> <strong>LEO</strong> <strong>大于等于该</strong> <strong>Partition</strong> <strong>的</strong> <strong>HW</strong>，即 follower 追上 leader 之后，就可以重新加入 ISR 了。</p>
</li>
<li><p><strong>leader故障</strong></p>
<p>leader 发生故障之后，会从 ISR 中选出一个新的 leader之后，为保证多个副本之间的数据一致性，其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader同步数据。</p>
</li>
</ul>
<h2 id="消息队列可能的问题"><a href="#消息队列可能的问题" class="headerlink" title="消息队列可能的问题"></a>消息队列可能的问题</h2><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p><strong>发生场景</strong></p>
<ul>
<li>topic 特性使得不在线的消费者上线后收不到之前的消息了，如果一段时间消费者都不在线，那消息就始终处于未被处理的状态。</li>
<li>服务器异常重启，导致内存中的数据丢失</li>
<li>消息设置了失效时间，过了时间就进入死信队列了</li>
<li>消费者自动回复 ack，但是 ack 之后处理消息的过程中出现故障或异常，导致消息被消费者接收单未处理</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>可追溯消息，默认 topic 数据是不进行持久化的，可以设置可追溯策略，最近多少条、最近多长时间、最近多少字节。</li>
<li>做高可用，保证消息不因节点故障或网络故障丢失</li>
<li>死信队列，对死信队列的数据进行重新推送或重新消费</li>
<li>ack，消息被消费处理完成后再回复broker可以去清除该消息了</li>
<li>消息重投、重试机制</li>
<li>记录日志，将处理异常的或者可能丢失的筛选出来重新处理</li>
</ul>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p><strong>发生场景</strong></p>
<p>网络环境差等因素导致重复发送多条相同业务的消息、自动重试等，导致业务数据错乱。</p>
<p><strong>解决办法</strong></p>
<p>设计幂等，使得消息重试多少次得到的结果都是一样的。</p>
<h3 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h3><p><strong>发生场景</strong></p>
<ul>
<li>分组或者独占消费者（exclusive和selector），即设定消息只能有特定的消费者接收消费，或者消费者设定了只接收特定属性值的消息。</li>
<li>消费者的消费能力远小于生产者的生产能力（也许是存在短时间消息生产高峰或者消费者节点出现故障）</li>
</ul>
<p><strong>问题表现</strong></p>
<ul>
<li>内存占用越来越多，内存可能溢出；</li>
<li>如果设置了消息持久化，磁盘空间占用越来越大；</li>
<li>主要还是影响业务响应时间；</li>
<li>内存溢出或者磁盘占满还可能导致消息丢失。</li>
</ul>
<p><strong>解决办法</strong></p>
<ul>
<li>分组或独占消费者：定期检查发现追踪。</li>
<li>消费者能力不足：增加节点，多线程提升消费效率，优化IO模型与IO传递速度。</li>
<li>broker容量有限：增加容量，JVM参数配置，是否有不自动清除的垃圾数据、死信未处理、做高可用集群。</li>
<li>生产者短时间产生大量消息：检查产生的数据是否正常、程序是否有问题；事前做好压测和测试，预留处理能力。</li>
</ul>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ol>
<li>命名空间的方式有两种：一种使用全限定名，一种是段名称（全局唯一）</li>
<li>命名空间实现的是java代码与数据库语言的映射，而MyBatis实现的是JVM和数据库的连接</li>
<li>实现 SQL 和 java 代码映射的方式有两种，一种是xml映射，另外一种是直接在接口上添加注解</li>
<li>Mybatis 和 Springboot 搭配使用时，MyBatis-Spring-Boot-Starter已经默认处理：<ol>
<li>自动探测存在的datasource</li>
<li>自动创建一个以datasource为源的SqlSessionFactory实例</li>
<li>自动创建并注册一个SqlSessionTemplate实例</li>
<li>自动扫描Mapper（@mapper或者@Repository），将他们注册到Spring的context中，自动注入成bean</li>
</ol>
</li>
<li>使用MyBatis-Spring-Boot-Starter可以手动指定扫描（@MappperScan）</li>
<li>如果在Springboot中至少有两个SqlSessionFactoryBean，则需要手动指定（@Bean）</li>
<li>MyBatis实现分页两种方式：<ol>
<li>逻辑分页 （先一次性拿到所有的结果，然后分页获取，不适合较大的数据量）<ol>
<li>RowBounds</li>
</ol>
</li>
<li>物理分页<ol>
<li>SQL 语句，直接在select语句实现limit关键字</li>
<li>拦截器（Inteceptor），实现动态地拼接select</li>
</ol>
</li>
</ol>
</li>
<li>Mybatis缓存：MyBatis总共有两级缓存，一般先访问二级缓存再访问一级缓存<ol>
<li>一级缓存：一级缓存是sqlsession的本地缓存，它存在的时间受到当前的sqlsession影响</li>
<li>二级缓存：二级缓存是各个sqlsession之间的共享缓存，是一个全局的缓存<img src="/2024/11/20/%E5%90%8E%E7%AB%AF/.%5Cres%5C1681108101364-3dfe0ee9-3cc3-403e-adf6-201938faa631.png" alt="image.png"></li>
</ol>
</li>
</ol>
<h2 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h2><ol>
<li>封装常用操作</li>
<li>提供常用的CRUD</li>
<li>提供高级功能，分页，逻辑删除</li>
<li>丰富插件管理</li>
<li>通过配置文件和注解配置简洁</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Xu Wenjin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/11/20/%E5%90%8E%E7%AB%AF/">http://example.com/2024/11/20/%E5%90%8E%E7%AB%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring%E6%A1%86%E6%9E%B6/">Spring框架</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/Spring%E6%A1%86%E6%9E%B6%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/12/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-java/" title="基础八股杂烩"><img class="cover" src="/img/cover/%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">基础八股杂烩</div></div><div class="info-2"><div class="info-item-1">本文杂烩了Java基础和计网等相关八股。</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC82MDYzOS8zNzExMA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">1.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">Spring 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">Spring概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A8%A1%E5%9D%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">Spring模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Core-Container"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">Core Container</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Messaging"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">Messaging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Data-Access-Intergration"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">Data Access &#x2F; Intergration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Web"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">Spring Web</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Test"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">Spring Test</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Spring-MVC-Spring-Boot"><span class="toc-number">1.1.3.</span> <span class="toc-text">Spring &#x2F; Spring MVC &#x2F; Spring Boot</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean"><span class="toc-number">1.2.</span> <span class="toc-text">Spring Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bean的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8EBean%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">声明Bean的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component-%E5%92%8C-Bean-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">@Component 和 @Bean 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5-Bean-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">注入 Bean 的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired-%E5%92%8C-Resource-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.5.</span> <span class="toc-text">@Autowired 和 @Resource 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">Bean的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.7.</span> <span class="toc-text">单例 Bean 的线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%92%8C%E6%9C%89%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">无状态和有状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%9C%89%E7%8A%B6%E6%80%81Bean%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">解决有状态Bean的线程安全问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.8.</span> <span class="toc-text">Bean 的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IOC"><span class="toc-number">1.3.</span> <span class="toc-text">Spring IOC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">IOC的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">IOC 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">IOC容器的启动过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E5%AE%9A%E4%B9%89%E8%A6%86%E7%9B%96"><span class="toc-number">1.3.4.</span> <span class="toc-text">Bean的定义覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.5.</span> <span class="toc-text">循环依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">三级缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-B-A%E5%BE%AA%E7%8E%AF%E6%B3%A8%E5%85%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">A-B-A循环注入的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP"><span class="toc-number">1.4.</span> <span class="toc-text">Spring AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">AOP定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">AOP体系与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E4%B8%BB%E8%A6%81%E5%81%9A%E4%B8%89%E4%BB%B6%E4%BA%8B%E6%83%85"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">AOP主要做三件事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">AOP相关概念和注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-AOP-%E5%92%8C-AspectJ-AOP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">Spring AOP 和 AspectJ AOP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AspectJ-%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.</span> <span class="toc-text">AspectJ 定义的通知类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.5.</span> <span class="toc-text">多个切面的执行顺序控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.6.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">JDK动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">CGLIB动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cglib-%E5%92%8C-JDK-%E7%9A%84-Proxy-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">Cglib 和 JDK 的 Proxy 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">Spring事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">事务管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">事务属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">事务状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">事务传播机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">编程式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">execute()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">声明式事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot"><span class="toc-number">1.6.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E4%BC%98%E7%82%B9"><span class="toc-number">1.6.1.</span> <span class="toc-text">Spring Boot优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot-Starters"><span class="toc-number">1.6.2.</span> <span class="toc-text">Spring Boot Starters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%B5%8C-Servlet-%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">内嵌 Servlet 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">修改嵌入式容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.4.</span> <span class="toc-text">常用基本注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBootApplication-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">@SpringBootApplication 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ComponentScan%E3%80%81-Import"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">@ComponentScan、@Import</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Conditional"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">@Conditional</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful-Web-%E6%9C%8D%E5%8A%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.5.</span> <span class="toc-text">RESTful Web 服务常用的注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Bean-%E7%9B%B8%E5%85%B3"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">Spring Bean 相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">处理常见的HTTP请求类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">前后端传值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">1.6.6.</span> <span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.7.</span> <span class="toc-text">启动机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringApplication%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">SpringApplication的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A8%E6%96%AD%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E6%98%AFWeb%E7%8E%AF%E5%A2%83"><span class="toc-number">1.6.7.1.1.</span> <span class="toc-text">推断应用类型是否是Web环境</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">run()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">1.6.8.</span> <span class="toc-text">配置文件读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-value-%E8%AF%BB%E5%8F%96%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">通过 @value 读取简单的配置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-ConfigurationProperties-%E8%AF%BB%E5%8F%96%E5%B9%B6%E4%B8%8E-bean-%E7%BB%91%E5%AE%9A"><span class="toc-number">1.6.8.2.</span> <span class="toc-text">通过 @ConfigurationProperties 读取并与 bean 绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-ConfigurationProperties-%E8%AF%BB%E5%8F%96%E5%B9%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.6.8.3.</span> <span class="toc-text">通过 @ConfigurationProperties 读取并校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-PropertySource-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A-properties-%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.8.4.</span> <span class="toc-text">通过 @PropertySource 读取指定 properties 文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C"><span class="toc-number">1.6.9.</span> <span class="toc-text">请求参数检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">校验注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E4%BD%93-RequestBody"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">验证请求体(RequestBody)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0-Path-Variables-%E5%92%8C-Request-Parameters"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">验证请求参数(Path Variables 和 Request Parameters)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.6.10.</span> <span class="toc-text">全局异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.11.</span> <span class="toc-text">定时任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">2.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">MySQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">MySQL 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.2.</span> <span class="toc-text">关系型数据库与非关系型数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">关系型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">非关系型数据库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">MySQL 基础架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.4.</span> <span class="toc-text">MySQL 存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">存储引擎架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-%E5%92%8C-InnoDB"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">MyISAM 和 InnoDB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">2.1.5.</span> <span class="toc-text">数据库三大范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">MySQL 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inner-join-left-join-right-join"><span class="toc-number">2.2.1.</span> <span class="toc-text">inner join  &#x2F; left join &#x2F; right join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-%E7%94%A8%E6%B3%95-%EF%BC%88%E8%A7%81%E4%B8%8A%E9%9D%A2%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">using 用法 （见上面）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Union-%E5%92%8C-Union-All-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">Union 和 Union All 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#on%E5%92%8Cwhere%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.4.</span> <span class="toc-text">on和where的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D"><span class="toc-number">2.2.5.</span> <span class="toc-text">去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit-%E5%88%86%E9%A1%B5"><span class="toc-number">2.2.6.</span> <span class="toc-text">limit 分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E9%9B%86%E5%90%88"><span class="toc-number">2.2.7.</span> <span class="toc-text">确定集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#where%E8%BF%87%E6%BB%A4%E7%A9%BA%E5%80%BC"><span class="toc-number">2.2.8.</span> <span class="toc-text">where过滤空值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by"><span class="toc-number">2.2.9.</span> <span class="toc-text">order by</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROUND"><span class="toc-number">2.2.10.</span> <span class="toc-text">ROUND</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.</span> <span class="toc-text">MySQL 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">索引优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.3.2.</span> <span class="toc-text">索引的必要性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">什么时候需要索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">什么时候不需要索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">创建索引的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.4.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.5.</span> <span class="toc-text">主键索引和辅助索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">主键索引(聚簇索引)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">二级索引(辅助索引)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.6.</span> <span class="toc-text">聚集索引与非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.3.6.1.1.</span> <span class="toc-text">聚集索引的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.6.1.2.</span> <span class="toc-text">聚集索引的缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">非聚集索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.3.6.2.1.</span> <span class="toc-text">非聚集索引的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.6.2.2.</span> <span class="toc-text">非聚集索引的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97"><span class="toc-number">2.3.6.2.3.</span> <span class="toc-text">非聚集索引一定回表查询吗 ?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.7.</span> <span class="toc-text">覆盖索引和联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.7.1.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.7.2.</span> <span class="toc-text">联合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.8.</span> <span class="toc-text">最左前缀匹配原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">2.3.9.</span> <span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.10.</span> <span class="toc-text">创建索引的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.11.</span> <span class="toc-text">优化索引的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.11.1.</span> <span class="toc-text">前缀索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.11.2.</span> <span class="toc-text">覆盖索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E6%98%AF%E8%87%AA%E5%A2%9E%E7%9A%84"><span class="toc-number">2.3.11.3.</span> <span class="toc-text">主键索引最好是自增的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E8%AE%BE%E7%BD%AE%E4%B8%BA-NOT-NULL"><span class="toc-number">2.3.11.4.</span> <span class="toc-text">索引最好设置为 NOT NULL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">2.3.11.5.</span> <span class="toc-text">防止索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">2.3.11.5.1.</span> <span class="toc-text">索引失效</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-B-%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">InnoDB &#x2F; B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Inno-DB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">Inno DB 数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inno-DB-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.2.</span> <span class="toc-text">Inno DB 数据页结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.4.3.</span> <span class="toc-text">B+ 树的查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">为什么使用B+树作为索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E5%92%8C-B-%E6%A0%91"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">B 树和 B+ 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8B%E6%A0%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">不使用B树的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8-Hash-%E8%A1%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">不使用 Hash 表的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8-BST%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">不使用 BST（二叉搜索树）的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">不使用红黑树的原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.5.</span> <span class="toc-text">MySQL 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">事务的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.5.2.</span> <span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.3.</span> <span class="toc-text">并发事务的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">2.5.4.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.5.</span> <span class="toc-text">隔离级别的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.6.</span> <span class="toc-text">MVCC 的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-View"><span class="toc-number">2.5.6.1.</span> <span class="toc-text">Read View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%9A%90%E8%97%8F%E5%88%97"><span class="toc-number">2.5.6.2.</span> <span class="toc-text">聚簇索引记录中的两个隐藏列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">2.5.6.3.</span> <span class="toc-text">MVCC多版本并发控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">2.5.7.</span> <span class="toc-text">幻读的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">2.5.7.1.</span> <span class="toc-text">快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">2.5.7.2.</span> <span class="toc-text">当前读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">MySQL 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text">锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">表级锁和行级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">共享锁和排他锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.1.4.</span> <span class="toc-text">InnoDB 行锁类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.1.5.</span> <span class="toc-text">MySQL加锁方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.6.1.5.1.</span> <span class="toc-text">唯一索引等值查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.6.1.5.2.</span> <span class="toc-text">唯一索引范围查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.6.1.5.3.</span> <span class="toc-text">非唯一索引等值查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.6.1.5.4.</span> <span class="toc-text">非唯一索引范围查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.1.5.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%97%A5%E5%BF%97"><span class="toc-number">2.7.</span> <span class="toc-text">MySQL 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.7.1.</span> <span class="toc-text">日志的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E5%92%8C-undo-log-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">redo log 和 undo log 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog-%E5%92%8C-redo-log-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">binlog 和 redo log 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-number">2.7.2.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer-pool"><span class="toc-number">2.7.3.</span> <span class="toc-text">buffer pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">2.7.4.</span> <span class="toc-text">redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E4%BD%9C%E7%94%A8"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">redo log 作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98"><span class="toc-number">2.7.4.2.</span> <span class="toc-text">redo log 写入磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog"><span class="toc-number">2.7.5.</span> <span class="toc-text">binlog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%92%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.8.</span> <span class="toc-text">读写分离和主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">2.8.1.</span> <span class="toc-text">读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">读写分离存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">读写分离的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.1.2.1.</span> <span class="toc-text">代理方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.1.2.2.</span> <span class="toc-text">组件方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">2.8.2.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">主从复制的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%8F%90%E4%BA%A4"><span class="toc-number">2.8.2.3.</span> <span class="toc-text">组提交</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">2.9.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93"><span class="toc-number">2.9.1.</span> <span class="toc-text">分库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.9.3.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">2.9.4.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="toc-number">2.9.5.</span> <span class="toc-text">数据迁移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E6%96%B9%E6%A1%88"><span class="toc-number">2.9.6.</span> <span class="toc-text">推荐方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">2.10.</span> <span class="toc-text">优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%8F%8A%E4%BC%98%E5%8C%96"><span class="toc-number">2.10.1.</span> <span class="toc-text">慢查询的定位及优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E8%AE%A1%E5%88%92-explain"><span class="toc-number">2.10.2.</span> <span class="toc-text">行计划  explain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.10.3.</span> <span class="toc-text">索引优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">2.10.4.</span> <span class="toc-text">查询优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">3.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%9F%BA%E7%A1%80"><span class="toc-number">3.1.</span> <span class="toc-text">Redis 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">概念和优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%AB%98%E9%80%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.1.2.</span> <span class="toc-text">Redis 高速原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">Redis 和 Memcached 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-Redis-%E8%80%8C%E4%B8%8D%E7%94%A8-map-guava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">为什么用 Redis 而不用 map&#x2F;guava 做缓存?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.1.5.</span> <span class="toc-text">使用 Redis 缓存的原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">Redis 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">数据类型和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SDS%EF%BC%88String%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">SDS（String的底层结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88hash%E5%92%8Cset%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">哈希表（hash和set的底层结构）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%EF%BC%88zset%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">跳表（zset的底层结构）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">Redis 线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">单线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BB%8D%E7%84%B6%E9%AB%98%E9%80%9F%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">单线程仍然高速的理由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">Redis 6.0 之前为什么使用单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">Redis 6.0 之后为什么引入多线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">Redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">3.4.1.</span> <span class="toc-text">数据不丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97"><span class="toc-number">3.4.2.</span> <span class="toc-text">AOF 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">先执行命令的好处和坏处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">写回策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">重写机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-%E5%BF%AB%E7%85%A7"><span class="toc-number">3.4.3.</span> <span class="toc-text">RDB 快照</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E5%81%9A%E5%BF%AB%E7%85%A7%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">RDB 做快照时会阻塞线程吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%83%BD%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">RDB 在执行快照的时候，数据能修改吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.4.4.</span> <span class="toc-text">混合持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-number">3.5.</span> <span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">集群方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-1"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">切片集群模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%84%91%E8%A3%82"><span class="toc-number">3.5.2.</span> <span class="toc-text">集群脑裂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%91%E8%A3%82%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">脑裂定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">3.6.</span> <span class="toc-text">过期删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">3.6.1.</span> <span class="toc-text">设置过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%BF%87%E6%9C%9F"><span class="toc-number">3.6.2.</span> <span class="toc-text">判定过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.</span> <span class="toc-text">过期删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">定时删除策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">惰性删除策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">定期删除策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.3.4.</span> <span class="toc-text">Redis使用的过期删除策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%E7%9A%84%E8%BF%87%E6%9C%9F%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86"><span class="toc-number">3.6.4.</span> <span class="toc-text">持久化时的过期内存处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%87%E6%9C%9F%E5%86%85%E5%AD%98%E5%A4%84%E7%90%86"><span class="toc-number">3.6.5.</span> <span class="toc-text">主从模式的过期内存处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">3.7.</span> <span class="toc-text">内存淘汰</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.7.1.</span> <span class="toc-text">内存淘汰策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E5%92%8CLFU"><span class="toc-number">3.7.2.</span> <span class="toc-text">LRU和LFU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-LRU"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">Redis LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LFU"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">LFU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-LFU"><span class="toc-number">3.7.2.4.</span> <span class="toc-text">Redis LFU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.8.</span> <span class="toc-text">缓存设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%EF%BC%88%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="toc-number">3.8.1.</span> <span class="toc-text">缓存异常（缓存雪崩、缓存击穿、缓存穿透）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">3.8.2.</span> <span class="toc-text">如何避免缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">3.8.3.</span> <span class="toc-text">如何避免缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">3.8.4.</span> <span class="toc-text">如何避免缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">3.8.5.</span> <span class="toc-text">布隆过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.8.6.</span> <span class="toc-text">动态缓存热点数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">3.8.7.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Aside%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">3.8.7.1.</span> <span class="toc-text">Cache Aside（旁路缓存）策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-Write-Through%EF%BC%88%E8%AF%BB%E7%A9%BF-%E5%86%99%E7%A9%BF%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">3.8.7.2.</span> <span class="toc-text">Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Write-Back%EF%BC%88%E5%86%99%E5%9B%9E%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">3.8.7.3.</span> <span class="toc-text">Write Back（写回）策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.9.</span> <span class="toc-text">缓存与数据库的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.9.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">3.9.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">延迟双删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-%E5%9F%BA%E4%BA%8E%E8%AE%A2%E9%98%85binlog%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.9.2.2.</span> <span class="toc-text">异步更新缓存(基于订阅binlog的同步机制)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Message-Queue"><span class="toc-number">4.</span> <span class="toc-text">Message Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80"><span class="toc-number">4.1.</span> <span class="toc-text">消息队列基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">消息队列的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text">消息队列的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%EF%BC%88%E5%87%8F%E5%B0%91%E5%93%8D%E5%BA%94%E6%89%80%E9%9C%80%E6%97%B6%E9%97%B4%EF%BC%89"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">通过异步处理提高系统性能（减少响应所需时间）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8A%E5%B3%B0-%E9%99%90%E6%B5%81"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">削峰&#x2F;限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">降低系统耦合性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.</span> <span class="toc-text">消息队列的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A7%84%E8%8C%83"><span class="toc-number">4.2.</span> <span class="toc-text">消息队列规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMS"><span class="toc-number">4.2.1.</span> <span class="toc-text">JMS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMS%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">JMS消息模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JMS%E6%B6%88%E6%81%AF%E6%AD%A3%E6%96%87%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">JMS消息正文模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMQP"><span class="toc-number">4.2.2.</span> <span class="toc-text">AMQP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.3.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94"><span class="toc-number">4.3.</span> <span class="toc-text">常见消息队列对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">保证消息的消费顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">4.5.</span> <span class="toc-text">数据一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">消息队列可能的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="toc-number">4.6.1.</span> <span class="toc-text">消息丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">4.6.2.</span> <span class="toc-text">重复消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="toc-number">4.6.3.</span> <span class="toc-text">消息堆积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis"><span class="toc-number">5.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatisPlus"><span class="toc-number">5.2.</span> <span class="toc-text">MyBatisPlus</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Xu Wenjin</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">欢迎浏览我的博客</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'

  const loadLivere = (el, path) => {
    window.livereOptions = {
      refer: path || location.pathname
    }

    if (isShuoshuo) {
      window.shuoshuoComment.destroyLivere = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if (isShuoshuo) {
    'Livere' === 'Livere'
      ? window.shuoshuoComment = { loadComment: loadLivere }
      : window.loadOtherComment = loadLivere
    return
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="关键字搜索" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>